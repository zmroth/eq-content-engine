# EQEmu Documentation: Quest API

> Extracted from docs.eqemu.dev - 85 pages

---

## Lua [Appearance]

*Source: quest-api/constants/lua-appearance/index.html*

# Lua [Appearance]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Appearance.Crouching
Appearance.Dead
Appearance.Looting
Appearance.Sitting
Appearance.Standing
`
```

---

## Lua [BT]

*Source: quest-api/constants/lua-bt/index.html*

# Lua [BT]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`BT.Animal
BT.Atenha_Ra
BT.Boxes
BT.Construct
BT.Dragon
BT.Dragon3
BT.Draz_Nurakk
BT.Extraplanar
BT.Giant
BT.Greater_Akheva
BT.Humanoid
BT.Insect
BT.InvisMan
BT.Khati_Sha
BT.Luggald
BT.Lycanthrope
BT.Magical
BT.Monster
BT.Muramite
BT.NoTarget
BT.NoTarget2
BT.Plant
BT.RaidGiant
BT.Seru
BT.Special
BT.Summoned
BT.Summoned2
BT.Summoned3
BT.SummonedUndead
BT.SwarmPet
BT.Undead
BT.Vampire
BT.VeliousDragon
BT.Zek
`
```

---

## Lua [Class]

*Source: quest-api/constants/lua-class/index.html*

# Lua [Class]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Class.ADVENTURE_MERCHANT
Class.ADVENTURE_RECRUITER
Class.ALT_CURRENCY_MERCHANT
Class.BANKER
Class.BARD
Class.BARDGM
Class.BEASTLORD
Class.BEASTLORDGM
Class.BERSERKER
Class.BERSERKERGM
Class.CLERIC
Class.CLERICGM
Class.DARK_REIGN_MERCHANT
Class.DISCORD_MERCHANT
Class.DRUID
Class.DRUIDGM
Class.ENCHANTER
Class.ENCHANTERGM
Class.FELLOWSHIP_MASTER
Class.GUILD_BANKER
Class.GUILD_TRIBUTE_MASTER
Class.LDON_TREASURE
Class.MAGICIAN
Class.MAGICIANGM
Class.MERCENARY_MASTER
Class.MERCHANT
Class.MONK
Class.MONKGM
Class.NECROMANCER
Class.NECROMANCERGM
Class.NORRATHS_KEEPERS_MERCHANT
Class.PALADIN
Class.PALADINGM
Class.RANGER
Class.RANGERGM
Class.ROGUE
Class.ROGUEGM
Class.SHADOWKNIGHT
Class.SHADOWKNIGHTGM
Class.SHAMAN
Class.SHAMANGM
Class.TRIBUTE_MASTER
Class.WARRIOR
Class.WARRIORGM
Class.WIZARD
Class.WIZARDGM
`
```

---

## Lua [ClientVersion]

*Source: quest-api/constants/lua-clientversion/index.html*

# Lua [ClientVersion]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`ClientVersion.RoF
ClientVersion.RoF2
ClientVersion.SoD
ClientVersion.SoF
ClientVersion.Titanium
ClientVersion.UF
ClientVersion.Underfoot
ClientVersion.Unknown
`
```

---

## Lua [Database]

*Source: quest-api/constants/lua-database/index.html*

# Lua [Database]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Database.Content
Database.Default
`
```

---

## Lua [Event]

*Source: quest-api/constants/lua-event/index.html*

# Lua [Event]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Event.aa_buy
Event.aa_exp_gained
Event.aa_gained
Event.aa_loss
Event.aggro_say
Event.alt_currency_gain
Event.alt_currency_loss
Event.alt_currency_merchant_buy
Event.alt_currency_merchant_sell
Event.augment_insert
Event.augment_insert_client
Event.augment_item
Event.augment_remove
Event.augment_remove_client
Event.bot_create
Event.cast
Event.cast_begin
Event.cast_on
Event.click_door
Event.click_object
Event.combat
Event.combine_failure
Event.combine_success
Event.command
Event.connect
Event.consider
Event.consider_corpse
Event.crystal_gain
Event.crystal_loss
Event.damage_given
Event.damage_taken
Event.death
Event.death_complete
Event.death_zone
Event.despawn
Event.despawn_zone
Event.destroy_item
Event.destroy_item_client
Event.disconnect
Event.discover_item
Event.drop_item
Event.drop_item_client
Event.duel_lose
Event.duel_win
Event.encounter_load
Event.encounter_unload
Event.enter
Event.enter_area
Event.enter_zone
Event.entity_variable_delete
Event.entity_variable_set
Event.entity_variable_update
Event.environmental_damage
Event.equip_item
Event.equip_item_bot
Event.equip_item_client
Event.exit
Event.exp_gain
Event.feign_death
Event.fish_failure
Event.fish_start
Event.fish_success
Event.forage_failure
Event.forage_success
Event.gm_command
Event.group_change
Event.hate_list
Event.hp
Event.inspect
Event.item_click
Event.item_click_cast
Event.item_click_cast_client
Event.item_click_client
Event.item_enter_zone
Event.killed_merit
Event.language_skill_up
Event.ldon_points_gain
Event.ldon_points_loss
Event.leave_area
Event.level_down
Event.level_up
Event.loot
Event.loot_added
Event.loot_zone
Event.memorize_spell
Event.merchant_buy
Event.merchant_sell
Event.payload
Event.player_pickup
Event.popup_response
Event.proximity_say
Event.read
Event.say
Event.scale_calc
Event.scribe_spell
Event.signal
Event.skill_up
Event.slay
Event.spawn
Event.spawn_zone
Event.spell_buff_tic
Event.spell_effect
Event.spell_effect_translocate_complete
Event.spell_fade
Event.target_change
Event.task_accepted
Event.task_before_update
Event.task_complete
Event.task_fail
Event.task_stage_complete
Event.task_update
Event.test_buff
Event.tick
Event.timer
Event.timer_pause
Event.timer_resume
Event.timer_start
Event.timer_stop
Event.trade
Event.unaugment_item
Event.unequip_item
Event.unequip_item_bot
Event.unequip_item_client
Event.unhandled_opcode
Event.unmemorize_spell
Event.unscribe_spell
Event.use_skill
Event.warp
Event.waypoint_arrive
Event.waypoint_depart
Event.weapon_proc
Event.zone
`
```

---

## Lua [ExpeditionLockMessage]

*Source: quest-api/constants/lua-expeditionlockmessage/index.html*

# Lua [ExpeditionLockMessage]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`ExpeditionLockMessage.Begin
ExpeditionLockMessage.Close
ExpeditionLockMessage.None
`
```

---

## Lua [ExpSource]

*Source: quest-api/constants/lua-expsource/index.html*

# Lua [ExpSource]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`ExpSource.Death
ExpSource.GM
ExpSource.Kill
ExpSource.LDoNChest
ExpSource.Quest
ExpSource.Resurrection
ExpSource.Sacrifice
ExpSource.Task
`
```

---

## Lua [Faction]

*Source: quest-api/constants/lua-faction/index.html*

# Lua [Faction]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Faction.Ally
Faction.Amiable
Faction.Apprehensive
Faction.Dubious
Faction.Indifferent
Faction.Kindly
Faction.Scowls
Faction.Threatenly
Faction.Warmly
`
```

---

## Lua [Filter]

*Source: quest-api/constants/lua-filter/index.html*

# Lua [Filter]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Filter.Auctions
Filter.BadWords
Filter.BardSongs
Filter.BardSongsOnPets
Filter.DOT
Filter.DamageShields
Filter.FocusEffects
Filter.GroupChat
Filter.GuildChat
Filter.HealOverTime
Filter.ItemSpeech
Filter.MeleeCrits
Filter.MissedMe
Filter.MyMisses
Filter.NPCSpells
Filter.None
Filter.OOC
Filter.OthersHit
Filter.OthersMiss
Filter.PCSpells
Filter.PetHits
Filter.PetMisses
Filter.PetSpells
Filter.Shouts
Filter.Socials
Filter.SpellCrits
Filter.SpellDamage
Filter.Strikethrough
Filter.Stuns
`
```

---

## Lua [InventoryWhere]

*Source: quest-api/constants/lua-inventorywhere/index.html*

# Lua [InventoryWhere]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`InventoryWhere.Bank
InventoryWhere.Cursor
InventoryWhere.Personal
InventoryWhere.SharedBank
InventoryWhere.Trading
`
```

---

## Lua [JournalMode]

*Source: quest-api/constants/lua-journalmode/index.html*

# Lua [JournalMode]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`JournalMode.Log1
JournalMode.Log2
JournalMode.None
`
```

---

## Lua [Language]

*Source: quest-api/constants/lua-language/index.html*

# Lua [Language]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Language.Alaran
Language.Barbarian
Language.CombineTongue
Language.CommonTongue
Language.DarkElvish
Language.DarkSpeech
Language.Dragon
Language.Dwarvish
Language.ElderDragon
Language.ElderElvish
Language.ElderTeirDal
Language.Elvish
Language.Erudian
Language.Faerie
Language.Froglok
Language.Gnoll
Language.Gnomish
Language.Goblin
Language.Hadal
Language.Halfling
Language.Lizardman
Language.MaxValue
Language.Ogre
Language.OldErudian
Language.Orcish
Language.ThievesCant
Language.Troll
Language.Unknown27
Language.VahShir
`
```

---

## Lua [Material]

*Source: quest-api/constants/lua-material/index.html*

# Lua [Material]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Material.Arms
Material.Bracer
Material.Chest
Material.Count
Material.Feet
Material.Hands
Material.Head
Material.Invalid
Material.Legs
Material.Max
Material.Primary
Material.Secondary
Material.Wrist
`
```

---

## Lua [MT]

*Source: quest-api/constants/lua-mt/index.html*

# Lua [MT]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`MT.Auction
MT.AuctionEcho
MT.Black
MT.Blue
MT.BrightBlue
MT.Broadcasts
MT.Channel1
MT.Channel10
MT.Channel2
MT.Channel3
MT.Channel4
MT.Channel5
MT.Channel6
MT.Channel7
MT.Channel8
MT.Channel9
MT.Chat
MT.Chat10Echo
MT.Chat1Echo
MT.Chat2Echo
MT.Chat3Echo
MT.Chat4Echo
MT.Chat5Echo
MT.Chat6Echo
MT.Chat7Echo
MT.Chat8Echo
MT.Chat9Echo
MT.CritMelee
MT.Cyan
MT.DS
MT.DarkGray
MT.Default
MT.DefaultText
MT.DiceRoll
MT.DimGray
MT.Disciplines
MT.DoTDamage
MT.Emote
MT.EmoteEcho
MT.Experience
MT.FocusEffect
MT.Gray
MT.Green
MT.Group
MT.GroupEcho
MT.Guild
MT.GuildEcho
MT.ItemLink
MT.ItemSpeech
MT.Leadership
MT.LightBlue
MT.LightGray
MT.LightNavy
MT.Lime
MT.LootMessages
MT.Magenta
MT.MerchantBuySell
MT.MerchantOffer
MT.MoneySplit
MT.MyPet
MT.NPCEnrage
MT.NPCFlurry
MT.NPCQuestSay
MT.NPCRampage
MT.NonMelee
MT.OOC
MT.OOCEcho
MT.OtherDeath
MT.OtherHits
MT.OtherHitsYou
MT.OtherMisses
MT.OtherMissesYou
MT.OtherSpells
MT.PetCrit
MT.PetFlurry
MT.PetResponse
MT.PetSpell
MT.RaidSay
MT.Red
MT.Say
MT.SayEcho
MT.Shout
MT.ShoutECho
MT.Skills
MT.SpellCrits
MT.SpellFailure
MT.Spells
MT.StrikeThrough
MT.Stun
MT.System
MT.Tell
MT.TellEcho
MT.TooFarAway
MT.Unused1
MT.Unused2
MT.White
MT.Who
MT.WornOff
MT.YellForHelp
MT.Yellow
MT.YouHitOther
MT.YouMissOther
MT.YourDeath
`
```

---

## Lua [Opcode]

*Source: quest-api/constants/lua-opcode/index.html*

# Lua [Opcode]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Opcode.0x0193
Opcode.0x0347
Opcode.AAAction
Opcode.AAExpUpdate
Opcode.AcceptNewTask
Opcode.AckPacket
Opcode.Action
Opcode.Action2
Opcode.AdventureData
Opcode.AdventureDetails
Opcode.AdventureFinish
Opcode.AdventureInfo
Opcode.AdventureInfoRequest
Opcode.AdventureLeaderboardReply
Opcode.AdventureLeaderboardRequest
Opcode.AdventureMerchantPurchase
Opcode.AdventureMerchantRequest
Opcode.AdventureMerchantResponse
Opcode.AdventureMerchantSell
Opcode.AdventurePointsUpdate
Opcode.AdventureRequest
Opcode.AdventureStatsReply
Opcode.AdventureStatsRequest
Opcode.AdventureUpdate
Opcode.AltCurrency
Opcode.AltCurrencyMerchantReply
Opcode.AltCurrencyMerchantRequest
Opcode.AltCurrencyPurchase
Opcode.AltCurrencyReclaim
Opcode.AltCurrencySell
Opcode.AltCurrencySellSelection
Opcode.Animation
Opcode.AnnoyingZoneUnknown
Opcode.ApplyPoison
Opcode.ApproveName
Opcode.ApproveWorld
Opcode.ApproveZone
Opcode.Assist
Opcode.AssistGroup
Opcode.AugmentInfo
Opcode.AugmentItem
Opcode.AutoAttack
Opcode.AutoAttack2
Opcode.AutoFire
Opcode.Bandolier
Opcode.BankerChange
Opcode.Barter
Opcode.Bazaar
Opcode.BazaarInspect
Opcode.BazaarSearch
Opcode.BecomeCorpse
Opcode.BecomeTrader
Opcode.Begging
Opcode.BeginCast
Opcode.Bind_Wound
Opcode.BlockedBuffs
Opcode.BoardBoat
Opcode.Buff
Opcode.BuffCreate
Opcode.BuffRemoveRequest
Opcode.Bug
Opcode.CameraEffect
Opcode.Camp
Opcode.CancelTask
Opcode.CancelTrade
Opcode.CastSpell
Opcode.ChangeSize
Opcode.ChannelMessage
Opcode.CharInventory
Opcode.CharacterCreate
Opcode.CharacterCreateRequest
Opcode.Charm
Opcode.ChatMessage
Opcode.ClearBlockedBuffs
Opcode.ClearNPCMarks
Opcode.ClearObject
Opcode.ClearSurname
Opcode.ClickDoor
Opcode.ClickObject
Opcode.ClickObjectAction
Opcode.ClientError
Opcode.ClientReady
Opcode.ClientTimeStamp
Opcode.ClientUpdate
Opcode.CloseContainer
Opcode.CloseTributeMaster
Opcode.ColoredText
Opcode.CombatAbility
Opcode.Command
Opcode.CompletedTasks
Opcode.ConfirmDelete
Opcode.Consent
Opcode.ConsentDeny
Opcode.ConsentResponse
Opcode.Consider
Opcode.ConsiderCorpse
Opcode.Consume
Opcode.ControlBoat
Opcode.CorpseDrag
Opcode.CorpseDrop
Opcode.CrashDump
Opcode.CrystalCountUpdate
Opcode.CrystalCreate
Opcode.CrystalReclaim
Opcode.CustomTitles
Opcode.Damage
Opcode.Death
Opcode.DelegateAbility
Opcode.DeleteCharacter
Opcode.DeleteCharge
Opcode.DeleteItem
Opcode.DeletePetition
Opcode.DeleteSpawn
Opcode.DeleteSpell
Opcode.DenyResponse
Opcode.Disarm
Opcode.DisarmTraps
Opcode.DisciplineTimer
Opcode.DisciplineUpdate
Opcode.DiscordMerchantInventory
Opcode.DoGroupLeadershipAbility
Opcode.DuelAccept
Opcode.DuelDecline
Opcode.DumpName
Opcode.Dye
Opcode.DynamicWall
Opcode.DzAddPlayer
Opcode.DzChooseZone
Opcode.DzChooseZoneReply
Opcode.DzCompass
Opcode.DzExpeditionEndsWarning
Opcode.DzExpeditionInfo
Opcode.DzExpeditionInvite
Opcode.DzExpeditionInviteResponse
Opcode.DzExpeditionLockoutTimers
Opcode.DzListTimers
Opcode.DzMakeLeader
Opcode.DzMemberList
Opcode.DzMemberListName
Opcode.DzMemberListStatus
Opcode.DzPlayerList
Opcode.DzQuit
Opcode.DzRemovePlayer
Opcode.DzSetLeaderName
Opcode.DzSwapPlayer
Opcode.Emote
Opcode.EndLootRequest
Opcode.EnduranceUpdate
Opcode.EnterChat
Opcode.EnterWorld
Opcode.EnvDamage
Opcode.ExpUpdate
Opcode.ExpansionInfo
Opcode.ExploreUnknown
Opcode.FaceChange
Opcode.Feedback
Opcode.FeignDeath
Opcode.FellowshipUpdate
Opcode.FindPersonReply
Opcode.FindPersonRequest
Opcode.FinishTrade
Opcode.FinishWindow
Opcode.FinishWindow2
Opcode.Fishing
Opcode.Fling
Opcode.FloatListThing
Opcode.Forage
Opcode.ForceFindPerson
Opcode.FormattedMessage
Opcode.FriendsWho
Opcode.GMApproval
Opcode.GMBecomeNPC
Opcode.GMDelCorpse
Opcode.GMEmoteZone
Opcode.GMEndTraining
Opcode.GMEndTrainingResponse
Opcode.GMFind
Opcode.GMGoto
Opcode.GMHideMe
Opcode.GMKick
Opcode.GMKill
Opcode.GMLastName
Opcode.GMNameChange
Opcode.GMSearchCorpse
Opcode.GMServers
Opcode.GMSummon
Opcode.GMToggle
Opcode.GMTrainSkill
Opcode.GMTrainSkillConfirm
Opcode.GMTraining
Opcode.GMZoneRequest
Opcode.GMZoneRequest2
Opcode.GetGuildMOTD
Opcode.GetGuildMOTDReply
Opcode.GetGuildsList
Opcode.GiveMoney
Opcode.GroundSpawn
Opcode.GroupAcknowledge
Opcode.GroupCancelInvite
Opcode.GroupDelete
Opcode.GroupDisband
Opcode.GroupDisbandOther
Opcode.GroupDisbandYou
Opcode.GroupFollow
Opcode.GroupFollow2
Opcode.GroupInvite
Opcode.GroupInvite2
Opcode.GroupLeaderChange
Opcode.GroupLeadershipAAUpdate
Opcode.GroupMakeLeader
Opcode.GroupRoles
Opcode.GroupUpdate
Opcode.GroupUpdateB
Opcode.GroupUpdateLeaderAA
Opcode.GuildBank
Opcode.GuildCreate
Opcode.GuildDelete
Opcode.GuildDemote
Opcode.GuildInvite
Opcode.GuildInviteAccept
Opcode.GuildLeader
Opcode.GuildMOTD
Opcode.GuildManageAdd
Opcode.GuildManageBanker
Opcode.GuildManageRemove
Opcode.GuildManageStatus
Opcode.GuildMemberLevelUpdate
Opcode.GuildMemberList
Opcode.GuildMemberUpdate
Opcode.GuildPeace
Opcode.GuildPromote
Opcode.GuildPublicNote
Opcode.GuildRemove
Opcode.GuildStatus
Opcode.GuildTributeInfo
Opcode.GuildUpdate
Opcode.GuildWar
Opcode.GuildsList
Opcode.HPUpdate
Opcode.Heartbeat
Opcode.Hide
Opcode.HideCorpse
Opcode.Illusion
Opcode.IncreaseStats
Opcode.InitialHPUpdate
Opcode.InitialMobHealth
Opcode.InspectAnswer
Opcode.InspectMessageUpdate
Opcode.InspectRequest
Opcode.InstillDoubt
Opcode.InterruptCast
Opcode.ItemLinkClick
Opcode.ItemLinkResponse
Opcode.ItemLinkText
Opcode.ItemName
Opcode.ItemPacket
Opcode.ItemPreview
Opcode.ItemVerifyReply
Opcode.ItemVerifyRequest
Opcode.ItemViewUnknown
Opcode.Jump
Opcode.KeyRing
Opcode.KnowledgeBase
Opcode.LDoNButton
Opcode.LDoNDisarmTraps
Opcode.LDoNInspect
Opcode.LDoNOpen
Opcode.LDoNPickLock
Opcode.LDoNSenseTraps
Opcode.LFGAppearance
Opcode.LFGCommand
Opcode.LFGGetMatchesRequest
Opcode.LFGGetMatchesResponse
Opcode.LFGResponse
Opcode.LFGuild
Opcode.LFPCommand
Opcode.LFPGetMatchesRequest
Opcode.LFPGetMatchesResponse
Opcode.LeadershipExpToggle
Opcode.LeadershipExpUpdate
Opcode.LeaveAdventure
Opcode.LeaveBoat
Opcode.LevelAppearance
Opcode.LevelUpdate
Opcode.LoadSpellSet
Opcode.LocInfo
Opcode.LockoutTimerInfo
Opcode.LogServer
Opcode.Login
Opcode.LoginAccepted
Opcode.LoginComplete
Opcode.LoginUnknown1
Opcode.LoginUnknown2
Opcode.Logout
Opcode.LogoutReply
Opcode.LootComplete
Opcode.LootItem
Opcode.LootRequest
Opcode.MOTD
Opcode.ManaChange
Opcode.ManaUpdate
Opcode.MarkNPC
Opcode.Marquee
Opcode.MemorizeSpell
Opcode.Mend
Opcode.MendHPUpdate
Opcode.MercenaryAssign
Opcode.MercenaryCommand
Opcode.MercenaryDataRequest
Opcode.MercenaryDataResponse
Opcode.MercenaryDataUpdate
Opcode.MercenaryDataUpdateRequest
Opcode.MercenaryDismiss
Opcode.MercenaryHire
Opcode.MercenarySuspendRequest
Opcode.MercenarySuspendResponse
Opcode.MercenaryTimer
Opcode.MercenaryTimerRequest
Opcode.MercenaryUnknown1
Opcode.MercenaryUnsuspendResponse
Opcode.MobEnduranceUpdate
Opcode.MobHealth
Opcode.MobManaUpdate
Opcode.MobRename
Opcode.MobUpdate
Opcode.MoneyOnCorpse
Opcode.MoneyUpdate
Opcode.MoveCoin
Opcode.MoveDoor
Opcode.MoveItem
Opcode.MoveLogDisregard
Opcode.MoveLogRequest
Opcode.MultiLineMsg
Opcode.NewSpawn
Opcode.NewTitlesAvailable
Opcode.NewZone
Opcode.OnLevelMessage
Opcode.OpenContainer
Opcode.OpenDiscordMerchant
Opcode.OpenGuildTributeMaster
Opcode.OpenInventory
Opcode.OpenTributeMaster
Opcode.PDeletePetition
Opcode.PVPLeaderBoardDetailsReply
Opcode.PVPLeaderBoardDetailsRequest
Opcode.PVPLeaderBoardReply
Opcode.PVPLeaderBoardRequest
Opcode.PVPStats
Opcode.PetBuffWindow
Opcode.PetCommands
Opcode.Petition
Opcode.PetitionBug
Opcode.PetitionCheckIn
Opcode.PetitionCheckout
Opcode.PetitionCheckout2
Opcode.PetitionDelete
Opcode.PetitionQue
Opcode.PetitionRefresh
Opcode.PetitionResolve
Opcode.PetitionSearch
Opcode.PetitionSearchResults
Opcode.PetitionSearchText
Opcode.PetitionUnCheckout
Opcode.PetitionUpdate
Opcode.PickPocket
Opcode.PlayEverquestRequest
Opcode.PlayEverquestResponse
Opcode.PlayMP3
Opcode.PlayerProfile
Opcode.PlayerStateAdd
Opcode.PlayerStateRemove
Opcode.Poll
Opcode.PollResponse
Opcode.PopupResponse
Opcode.PostEnterWorld
Opcode.PotionBelt
Opcode.PreLogoutReply
Opcode.PurchaseLeadershipAA
Opcode.QueryResponseThing
Opcode.RaidInvite
Opcode.RaidJoin
Opcode.RaidUpdate
Opcode.RandomNameGenerator
Opcode.RandomReply
Opcode.RandomReq
Opcode.ReadBook
Opcode.RecipeAutoCombine
Opcode.RecipeDetails
Opcode.RecipeReply
Opcode.RecipesFavorite
Opcode.RecipesSearch
Opcode.ReclaimCrystals
Opcode.ReloadUI
Opcode.RemoveAllDoors
Opcode.RemoveBlockedBuffs
Opcode.RemoveNimbusEffect
Opcode.Report
Opcode.ReqClientSpawn
Opcode.ReqNewZone
Opcode.RequestClientZoneChange
Opcode.RequestDuel
Opcode.RequestKnowledgeBase
Opcode.RequestTitles
Opcode.RespawnWindow
Opcode.RespondAA
Opcode.RestState
Opcode.Rewind
Opcode.RezzAnswer
Opcode.RezzComplete
Opcode.RezzRequest
Opcode.Sacrifice
Opcode.SafeFallSuccess
Opcode.SafePoint
Opcode.Save
Opcode.SaveOnZoneReq
Opcode.SelectTribute
Opcode.SendAAStats
Opcode.SendAATable
Opcode.SendCharInfo
Opcode.SendExpZonein
Opcode.SendFindableNPCs
Opcode.SendGuildTributes
Opcode.SendLoginInfo
Opcode.SendMaxCharacters
Opcode.SendMembership
Opcode.SendMembershipDetails
Opcode.SendSystemStats
Opcode.SendTitleList
Opcode.SendTributes
Opcode.SendZonepoints
Opcode.SenseHeading
Opcode.SenseTraps
Opcode.ServerListRequest
Opcode.ServerListResponse
Opcode.SessionReady
Opcode.SetChatServer
Opcode.SetChatServer2
Opcode.SetGroupTarget
Opcode.SetGuildMOTD
Opcode.SetGuildRank
Opcode.SetRunMode
Opcode.SetServerFilter
Opcode.SetStartCity
Opcode.SetTitle
Opcode.SetTitleReply
Opcode.SharedTaskPlayerList
Opcode.Shielding
Opcode.ShopDelItem
Opcode.ShopEnd
Opcode.ShopEndConfirm
Opcode.ShopItem
Opcode.ShopPlayerBuy
Opcode.ShopPlayerSell
Opcode.ShopRequest
Opcode.SimpleMessage
Opcode.SkillUpdate
Opcode.Sneak
Opcode.Some3ByteHPUpdate
Opcode.Some6ByteHPUpdate
Opcode.SomeItemPacketMaybe
Opcode.Sound
Opcode.SpawnAppearance
Opcode.SpawnDoor
Opcode.SpawnPositionUpdate
Opcode.SpecialMesg
Opcode.SpellEffect
Opcode.Split
Opcode.Stamina
Opcode.Stun
Opcode.Surname
Opcode.SwapSpell
Opcode.TGB
Opcode.TargetBuffs
Opcode.TargetCommand
Opcode.TargetHoTT
Opcode.TargetMouse
Opcode.TargetReject
Opcode.TaskActivity
Opcode.TaskActivityComplete
Opcode.TaskDescription
Opcode.TaskHistoryReply
Opcode.TaskHistoryRequest
Opcode.TaskSelectWindow
Opcode.Taunt
Opcode.TestBuff
Opcode.TimeOfDay
Opcode.Track
Opcode.TrackTarget
Opcode.TrackUnknown
Opcode.TradeAcceptClick
Opcode.TradeBusy
Opcode.TradeCoins
Opcode.TradeMoneyUpdate
Opcode.TradeRequest
Opcode.TradeRequestAck
Opcode.TradeSkillCombine
Opcode.Trader
Opcode.TraderBuy
Opcode.TraderDelItem
Opcode.TraderItemUpdate
Opcode.TraderShop
Opcode.Translocate
Opcode.TributeInfo
Opcode.TributeItem
Opcode.TributeMoney
Opcode.TributeNPC
Opcode.TributePointUpdate
Opcode.TributeTimer
Opcode.TributeToggle
Opcode.TributeUpdate
Opcode.Untargetable
Opcode.UpdateAA
Opcode.UpdateLeadershipAA
Opcode.VetClaimReply
Opcode.VetClaimRequest
Opcode.VetRewardsAvaliable
Opcode.VoiceMacroIn
Opcode.VoiceMacroOut
Opcode.WeaponEquip1
Opcode.WearChange
Opcode.Weather
Opcode.Weblink
Opcode.WhoAllRequest
Opcode.WhoAllResponse
Opcode.WorldClientReady
Opcode.WorldComplete
Opcode.WorldLogout
Opcode.WorldObjectsSent
Opcode.WorldUnknown001
Opcode.World_Client_CRC1
Opcode.World_Client_CRC2
Opcode.XTargetAutoAddHaters
Opcode.XTargetRequest
Opcode.XTargetResponse
Opcode.YellForHelp
Opcode.ZoneChange
Opcode.ZoneComplete
Opcode.ZoneEntry
Opcode.ZoneGuildList
Opcode.ZoneInUnknown
Opcode.ZonePlayerToBind
Opcode.ZoneServerInfo
Opcode.ZoneServerReady
Opcode.ZoneSpawns
Opcode.ZoneUnavail
`
```

---

## Lua [Rule]

*Source: quest-api/constants/lua-rule/index.html*

# Lua [Rule]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Rule.AAExpMultiplier
Rule.AERampageMaxDistance
Rule.AI_EngagedBeneficialOtherChance
Rule.AI_EngagedBeneficialSelfChance
Rule.AI_EngagedDetrimentalChance
Rule.AI_EngagedNoSpellMaxRecast
Rule.AI_EngagedNoSpellMinRecast
Rule.AI_HealHPPct
Rule.AI_IdleBeneficialChance
Rule.AI_IdleNoSpellMaxRecast
Rule.AI_IdleNoSpellMinRecast
Rule.AI_PursueDetrimentalChance
Rule.AI_PursueNoSpellMaxRecast
Rule.AI_PursueNoSpellMinRecast
Rule.AI_SpellCastFinishedFailRecast
Rule.ActiveInvSnapshots
Rule.AddMaxClientsPerIP
Rule.AddMaxClientsStatus
Rule.AdditiveBonusWornType
Rule.AdjustProcPerMinute
Rule.AggroPlayerPets
Rule.AggroRadius
Rule.AggroRadiusPuller
Rule.AllowAnyWeaponTransformation
Rule.AllowApplyPoisonCommand
Rule.AllowApplyPotionCommand
Rule.AllowBotEquipAnyRaceGear
Rule.AllowCamelCaseNames
Rule.AllowCorpse
Rule.AllowCrossClassTrainers
Rule.AllowCrossZoneSpellsOnBots
Rule.AllowCrossZoneSpellsOnMercs
Rule.AllowCrossZoneSpellsOnPets
Rule.AllowDoubleInvis
Rule.AllowExtraDmgSkill
Rule.AllowFocusOnSkillDamageSpells
Rule.AllowItemTGB
Rule.AllowMQTarget
Rule.AllowMercSuspendInCombat
Rule.AllowMercs
Rule.AllowMultipleOfSameAugment
Rule.AllowOwnerOptionAutoDefend
Rule.AllowPickpocketCommand
Rule.AllowRaidTargetBlind
Rule.AllowSpellMemorizeFromItem
Rule.AllowTickPulling
Rule.AllyFactionMinimum
Rule.AlternateAugmentationSealer
Rule.AlwaysNotifyNewLeaderOnChange
Rule.AlwaysSendTargetsBuffs
Rule.AmiablyFactionMinimum
Rule.AnimalsOpenDoors
Rule.Anims
Rule.ApprehensivelyFactionMinimum
Rule.ArcheryBaseDamage
Rule.ArcheryBaseDamageBonus
Rule.ArcheryBonusLevelRequirement
Rule.ArcheryBonusRequiresStationary
Rule.ArcheryConsumesAmmo
Rule.ArcheryCritDifficulty
Rule.ArcheryHitPenalty
Rule.ArcheryNPCMultiplier
Rule.AssassinateLevelRequirement
Rule.AssassinateOnlyHumanoids
Rule.AssistNoTargetSelf
Rule.AttackCommandRange
Rule.AuditTrail
Rule.AugmentItemAllowInvisibleAugments
Rule.AutoGrantAAExpansion
Rule.AutoInjectSaylinksToClientMessage
Rule.AutoInjectSaylinksToSay
Rule.AutoShutdownDelay
Rule.AutosaveIntervalS
Rule.AutosaveIntervalSeconds
Rule.AvgDefProcsPerMinute
Rule.AvgProcsPerMinute
Rule.AvgSpellProcsPerMinute
Rule.BackstabBaseDamage
Rule.BackstabIgnoresBane
Rule.BackstabIgnoresElemental
Rule.BandolierSwapDelay
Rule.BardAggroCap
Rule.BardTrackingDistanceMultiplier
Rule.BaseCritChance
Rule.BaseCritRatio
Rule.BaseHPRegenBonusRaces
Rule.BaseImmunityLevel
Rule.BaseInstrumentSoftCap
Rule.BaseProcChance
Rule.BaseRunSpeedCap
Rule.BashACBonusDivisor
Rule.BashBaseDamage
Rule.BashTwoHanderUseShoulderAC
Rule.BatchPlayerEventProcessChunkSize
Rule.BatchPlayerEventProcessIntervalSeconds
Rule.BeastlordTrackingDistanceMultiplier
Rule.BeginCast
Rule.BerserkerFrenzyEnd
Rule.BerserkerFrenzyStart
Rule.BerserkerTrackingDistanceMultiplier
Rule.BindAnywhere
Rule.BlueModifier
Rule.BootHour
Rule.BotCharacterLevel
Rule.BotExpansionSettings
Rule.BotGroupXP
Rule.BotHealOnLevel
Rule.BotLevelsWithOwner
Rule.BotsCanClickItems
Rule.BotsClickItemsMinLvl
Rule.BotsHasteCap
Rule.BotsHastev3Cap
Rule.BotsIgnoreLevelBasedHasteCaps
Rule.BreakFeignDeathWhenCastOn
Rule.BreakSneakWhenCastOn
Rule.BuffFriends
Rule.BuffLevelRestrictions
Rule.BuffsFadeOnDeath
Rule.BuyCostMod
Rule.CallOfTheHeroAggroClearDist
Rule.CanClickMageEpicV1
Rule.CanTakeNoDrop
Rule.CanTakeQuestItems
Rule.CasterStopMeleeLevel
Rule.CazicTouchBotsOwner
Rule.CazicTouchTargetsPetOwner
Rule.ChaBonusMod
Rule.ChaPenaltyMod
Rule.ChannelsIgnoreNameFilter
Rule.CharacterSelectExpansionSettings
Rule.ChargeMercPurchaseCost
Rule.ChargeMercUpkeepCost
Rule.CharismaCharmDuration
Rule.CharismaEffectiveness
Rule.CharismaEffectivenessCap
Rule.CharmAggroOverLevel
Rule.CharmBreakCheckChance
Rule.CharmDisablesSpecialAbilities
Rule.CheckCursorEmptyWhenLooting
Rule.CheckForWaterOnSendTo
Rule.CheckForWaterWhenFishing
Rule.ChooseLeaderCooldownTime
Rule.Classic2HBAnimation
Rule.ClassicMasterWu
Rule.ClassicNPCBackstab
Rule.ClassicTauntSystem
Rule.ClassicTripleAttack
Rule.ClassicTripleAttackChanceBerserker
Rule.ClassicTripleAttackChanceMonk
Rule.ClassicTripleAttackChanceRanger
Rule.ClassicTripleAttackChanceWarrior
Rule.ClearTempMerchantlist
Rule.ClearXTargetDelay
Rule.ClericInnateHealFocus
Rule.ClericTrackingDistanceMultiplier
Rule.ClientAggroCheckIdleInterval
Rule.ClientAggroCheckMovingInterval
Rule.ClientDataRate
Rule.ClientLinkdeadMS
Rule.ClientPetsUseOwnerNameInLastName
Rule.ClientPositionUpdates
Rule.ClientRemovalDelayMS
Rule.ClientStunMessage
Rule.CommandSpellRank
Rule.CompoundLifetapHeals
Rule.CompressZoneStream
Rule.CorpseDecayTime
Rule.CorpseOwnerOnlineTime
Rule.CorpseResTime
Rule.CorpseUnlockTimer
Rule.CrashReporting
Rule.CreationLimit
Rule.CriticalDamage
Rule.CriticallyWoundedAggroMod
Rule.CurrentExpansion
Rule.CurrentTargetAggroMod
Rule.CustomFilesAdminLevel
Rule.CustomFilesKey
Rule.CustomFilesUrl
Rule.DOTBonusDamageSplitOverDuration
Rule.DOTsScaleWithSpellDmg
Rule.DamageMessages
Rule.DeathExpLossLevel
Rule.DeathExpLossMaxLevel
Rule.DeathExpLossMultiplier
Rule.DeathItemLossLevel
Rule.DeathKeepLevel
Rule.DeathSaveCharismaMod
Rule.DefProcPerMinAgiContrib
Rule.DefaultAOEMaxTargets
Rule.DefaultGuild
Rule.DefaultGuildRank
Rule.DefaultRampageTargets
Rule.DefensiveProcPenaltyLevelGap
Rule.DefensiveProcPenaltyLevelGapModifier
Rule.DeleteOnDuplicate
Rule.DeleteTimer
Rule.DeleteTransformationMold
Rule.DialogueWindowAnimatesNPCsIfNoneSet
Rule.DisableAttuneable
Rule.DisableBardFocusEffects
Rule.DisableLastNames
Rule.DisableLore
Rule.DisableNoDrop
Rule.DisableNoPet
Rule.DisableNoRent
Rule.DisableNoTransfer
Rule.DisablePotionBelt
Rule.DisableSpellFocusEffects
Rule.DismountWater
Rule.DistanceForRescueAccept
Rule.DistanceForRescueComplete
Rule.DivineInterventionHeal
Rule.DoubleBackstabLevelRequirement
Rule.DragCorpseDistance
Rule.DragonPunchBaseDamage
Rule.DruidTrackingDistanceMultiplier
Rule.DubiouslyFactionMinimum
Rule.DuelCorpseResTime
Rule.DyeCommandRequiresDyes
Rule.EXPFromDmgShield
Rule.EagleStrikeBaseDamage
Rule.EbonCrystalItemID
Rule.Emote
Rule.EmptyCorpseDecayTime
Rule.EmptyNPCCorpseDecayTime
Rule.EmptyShutdownDelaySeconds
Rule.EmptyShutdownEnabled
Rule.EnableAggroMeter
Rule.EnableAltCurrencySell
Rule.EnableAntiSpam
Rule.EnableAutoLogin
Rule.EnableBardMelody
Rule.EnableBlockedBuffs
Rule.EnableCharacterEXPMods
Rule.EnableChecksumVerification
Rule.EnableDevTools
Rule.EnableDirectToInventoryDelivery
Rule.EnableDiscoveredItems
Rule.EnableFearPathing
Rule.EnableFoodRequirement
Rule.EnableGroupEXPModifier
Rule.EnableGroupMemberEXPModifier
Rule.EnableHungerPenalties
Rule.EnableIPExemptions
Rule.EnableInDynamicZoneStatus
Rule.EnableLoggedOffReplenishments
Rule.EnableMQFastMemDetector
Rule.EnableMQGateDetector
Rule.EnableMQGhostDetector
Rule.EnableMQWarpDetector
Rule.EnableMQZoneDetector
Rule.EnableMailKeyIPVerification
Rule.EnableMailSystem
Rule.EnableMeritBasedFaction
Rule.EnableNPCQuestJournal
Rule.EnablePVPRegions
Rule.EnableParcelDelivery
Rule.EnableParcelMerchants
Rule.EnablePruning
Rule.EnableRaidEXPModifier
Rule.EnableRaidMemberEXPModifier
Rule.EnableRangerAutoFire
Rule.EnableResistSoftCap
Rule.EnableReturnHomeButton
Rule.EnableShadowrest
Rule.EnableSneakPull
Rule.EnableSpellBuckets
Rule.EnableSpellGlobals
Rule.EnableTGB
Rule.EnableTaskProximity
Rule.EnableTaskSystem
Rule.EnableTestBuff
Rule.EnableTutorialButton
Rule.EnableVoiceMacros
Rule.EnableWarpToTrader
Rule.EnableWarriorShielding
Rule.EnableXTargetting
Rule.EnableZoneControllerGlobals
Rule.Enabled
Rule.EnchanterTrackingDistanceMultiplier
Rule.EnduranceRegenMultiplier
Rule.EnforceAugmentRestriction
Rule.EnforceAugmentUsability
Rule.EnforceAugmentWear
Rule.EnforceCharacterLimitAtLogin
Rule.EnvironmentDamageMulipliter
Rule.EvacClearAggroInSameZone
Rule.EvacClearCharmPet
Rule.ExcludedFaceTargetRaces
Rule.ExcludedFleeAllyFactionIDs
Rule.ExemptMaxClientsStatus
Rule.ExpMultiplier
Rule.ExpPerPoint
Rule.ExpRewardsIgnoreLevelBasedEXPMods
Rule.ExpansionSettings
Rule.ExperiencePercentCapPerKill
Rule.ExpireRead
Rule.ExpireTrash
Rule.ExpireUnread
Rule.ExtraAllowedKickClassesBitmask
Rule.FRProjectileItem_NPC
Rule.FRProjectileItem_SOF
Rule.FRProjectileItem_Titanium
Rule.FVNoDropFlag
Rule.Fear
Rule.FearBreakCheckChance
Rule.FeignKillsPet
Rule.FinalExpMultiplier
Rule.FinalRaidExpMultiplier
Rule.Find
Rule.FindBestZHeightAdjust
Rule.FinishBuffing
Rule.FinishingBlowOnlyWhenFleeing
Rule.FishingChance
Rule.FishingLineLength
Rule.FishingLineStepSize
Rule.FishingRodLength
Rule.FixBeaconHeading
Rule.FixPathingZMaxDeltaSendTo
Rule.FixPathingZOnSendTo
Rule.FixZWhenPathing
Rule.FlatItemExtraSpellAmt
Rule.FleeGray
Rule.FleeGrayHPRatio
Rule.FleeGrayMaxLevel
Rule.FleeHPRatio
Rule.FleeIfNotAlone
Rule.FlyingKickBaseDamage
Rule.FocusCombatProcs
Rule.FoodLossPerUpdate
Rule.ForageChance
Rule.FrenzyBaseDamage
Rule.FrontalStunImmunityClasses
Rule.FrontalStunImmunityRaces
Rule.FullEndurOnDeath
Rule.FullGroupEXPModifier
Rule.FullManaOnDeath
Rule.GMAccountIPList
Rule.GlobalChatLevelLimit
Rule.GlobalLootMultiplier
Rule.GrantHoTTOnCreate
Rule.GraveyardTimeMS
Rule.GreenModifier
Rule.GroupBuffing
Rule.GroupExpMultiplier
Rule.GroupInvitesRequireTarget
Rule.GroupMemberEXPModifier
Rule.GuildHallExpirationDays
Rule.HOTBonusHealingSplitOverDuration
Rule.HOTsScaleWithHealAmt
Rule.HPRegenMultiplier
Rule.HarmTouchCritRatio
Rule.HasteCap
Rule.Hastev3Cap
Rule.HeadshotOnlyHumanoids
Rule.HealAmountMessageFilterThreshold
Rule.HealOnLevel
Rule.HealRotationMaxMembers
Rule.HealRotationMaxTargets
Rule.HeroicAgilityMultiplier
Rule.HeroicDexterityMultiplier
Rule.HeroicIntelligenceIncreaseSpellDmgMultiplier
Rule.HeroicIntelligenceMultiplier
Rule.HeroicStaminaMultiplier
Rule.HeroicStatsUseDataBucketsToScale
Rule.HeroicStrengthMultiplier
Rule.HeroicWisdomIncreaseHealAmtMultiplier
Rule.HeroicWisdomMultiplier
Rule.HideMeCommandDisablesTells
Rule.HitBoxMod
Rule.HotZoneBonus
Rule.IPExemptionZones
Rule.IPLimitDisconnectAll
Rule.IgnoreLevelBasedHasteCaps
Rule.IgnoreSpellDmgLvlRestriction
Rule.IksarCommonTongue
Rule.IllusionsAlwaysPersist
Rule.IndifferentlyFactionMinimum
Rule.InitialAggroBonus
Rule.InitialPetAggroBonus
Rule.IntAggroThreshold
Rule.IntervalDurationMS
Rule.InvSnapshotHistoryD
Rule.InvSnapshotMinIntervalM
Rule.InvSnapshotMinRetryM
Rule.InvisRequiresGroup
Rule.IsGMPetitionWindowEnabled
Rule.ItemATKCap
Rule.ItemAccuracyCap
Rule.ItemAvoidanceCap
Rule.ItemCastsUseFocus
Rule.ItemClairvoyanceCap
Rule.ItemCombatEffectsCap
Rule.ItemDSMitigationCap
Rule.ItemDamageShieldCap
Rule.ItemDoTShieldingCap
Rule.ItemEnduranceRegenCap
Rule.ItemExtraDmgCap
Rule.ItemExtraSkillDamageCalcAsPercent
Rule.ItemExtraSpellAmtCalcAsPercent
Rule.ItemHealAmtCap
Rule.ItemHealthRegenCap
Rule.ItemIDToEnablePorts
Rule.ItemManaRegenCap
Rule.ItemShieldingCap
Rule.ItemSpellDmgCap
Rule.ItemSpellShieldingCap
Rule.ItemStrikethroughCap
Rule.ItemStunResistCap
Rule.July242002PetResists
Rule.Jun182014HundredHandsRevamp
Rule.KarmaGlobalChatLimit
Rule.KarmaUpdateIntervalMS
Rule.KeepLevelOverMax
Rule.KeepOneRecordPerCompletedTask
Rule.KickBaseDamage
Rule.KillProcessOnDynamicShutdown
Rule.KillsPerGroupLeadershipAA
Rule.KillsPerRaidLeadershipAA
Rule.KindlyFactionMinimum
Rule.LDoNBaseTrapDifficulty
Rule.LDoNCriticalFailTrapThreshold
Rule.LDoNLootCountModifier
Rule.LDoNTrapDistanceUse
Rule.LastFightingDelayMovingMax
Rule.LastFightingDelayMovingMin
Rule.LazyLoadBank
Rule.LeashDistance
Rule.LeaveCorpses
Rule.LeaveCursorMoneyOnCorpse
Rule.LeaveNakedCorpses
Rule.LegacyComputeDefense
Rule.LegacyManaburn
Rule.LegacyManaburnCap
Rule.LevelBasedEXPMods
Rule.LevelDifferenceRollBonus
Rule.LevelDifferenceRollCheck
Rule.LevelToStopACTwinkControl
Rule.LevelToStopDamageCaps
Rule.LightBlueModifier
Rule.LiveLikeEnrage
Rule.LiveLikeFocusEffects
Rule.LivelikeBreakCharmOnInvis
Rule.LockoutDurationMultiplier
Rule.MOTD
Rule.MQFastMemExemptStatus
Rule.MQGateExemptStatus
Rule.MQGhostExemptStatus
Rule.MQWarpDetectionDistanceFactor
Rule.MQWarpExemptStatus
Rule.MQZoneExemptStatus
Rule.MagicianTrackingDistanceMultiplier
Rule.MaintainIntoxicationAcrossZones
Rule.MajorNPCCorpseDecayTime
Rule.ManaRegen
Rule.ManaRegenMultiplier
Rule.ManaTapsOnAnyClass
Rule.ManaTapsRequireNPCMana
Rule.MarkMQWarpLT
Rule.MarqueeHPUpdates
Rule.MaxAAEXPPerKill
Rule.MaxBarterSearchResults
Rule.MaxBuffSlotsNPC
Rule.MaxBuyerInventorySearchResults
Rule.MaxCharmDurationForPlayerCharacter
Rule.MaxClientsPerIP
Rule.MaxClientsSetByStatus
Rule.MaxDiscSlotsNPC
Rule.MaxDistanceToClickDoors
Rule.MaxDraggedCorpses
Rule.MaxExpLevel
Rule.MaxFearDurationForPlayerCharacter
Rule.MaxFlurryHits
Rule.MaxLevel
Rule.MaxLevelForTutorial
Rule.MaxLevelRange
Rule.MaxMessagesBeforeKick
Rule.MaxNavmeshNodes
Rule.MaxNumberForGroup
Rule.MaxPermanentPlayerChannels
Rule.MaxProcs
Rule.MaxRaceID
Rule.MaxRampageTargets
Rule.MaxScalingProcAggro
Rule.MaxSearchResults
Rule.MaxSongSlotsNPC
Rule.MaxTotalSlotsNPC
Rule.MaxTotalSlotsPET
Rule.MaxTradeskillSearchSkillDiff
Rule.MaxTrainResearch
Rule.MaxTrainSpecializations
Rule.MaxTrainTradeskills
Rule.MaxUpdateMessages
Rule.MaximumLevelStunsCripplingBlow
Rule.MaximumMessagesPerInterval
Rule.MaximumQuestErrors
Rule.MaximumTauntDistance
Rule.MeleeCritDifficulty
Rule.MeleePush
Rule.MeleePushChance
Rule.MeleePushForceClientPercent
Rule.MeleePushForcePetPercent
Rule.MeleeRangeAggroMod
Rule.MendAlwaysSucceedValue
Rule.MercsHasteCap
Rule.MercsHastev3Cap
Rule.MercsIgnoreLevelBasedHasteCaps
Rule.MinAggroLevel
Rule.MinGMAntiHackStatus
Rule.MinHastedDelay
Rule.MinNumberForGroup
Rule.MinOfflineTimeToReplenishments
Rule.MinOfflineTimeToReturnHome
Rule.MinRangedAttackDist
Rule.MinStatusForNoDropExemptions
Rule.MinStatusToBypassAntiSpam
Rule.MinStatusToBypassCheckSumVerification
Rule.MinStatusToBypassLockedServer
Rule.MinStatusToBypassPlayerCountRequirements
Rule.MinStatusToLevelTarget
Rule.MinStatusToSummonItem
Rule.MinStatusToZoneAnywhere
Rule.MinimumMessagesPerInterval
Rule.MinorNPCCorpseDecayTime
Rule.MobCloseScanDistance
Rule.MobPathingVisualDebug
Rule.MobZVisualDebug
Rule.ModernAAScalingAALimit
Rule.ModernAAScalingAAMinimum
Rule.ModernAAScalingEnabled
Rule.ModernAAScalingStartPercent
Rule.MonkTrackingDistanceMultiplier
Rule.NPCAggroMaxDistanceEnabled
Rule.NPCAssistCap
Rule.NPCAssistCapTimer
Rule.NPCAttackMagicLevel
Rule.NPCBackstabMod
Rule.NPCBashKickLevel
Rule.NPCBuffLevelRestrictions
Rule.NPCCanCrit
Rule.NPCFlurryChance
Rule.NPCGateDistanceBind
Rule.NPCGateNearBind
Rule.NPCGatePercent
Rule.NPCHasteCap
Rule.NPCHastev3Cap
Rule.NPCHealOnGate
Rule.NPCHealOnGateAmount
Rule.NPCIgnoreBaseImmunity
Rule.NPCIgnoreLevelBasedHasteCaps
Rule.NPCInnateProcOverride
Rule.NPCKickStunLevel
Rule.NPCSpellPush
Rule.NPCToNPCAggroTimerMax
Rule.NPCToNPCAggroTimerMin
Rule.NPC_UseFocusFromItems
Rule.NPC_UseFocusFromSpells
Rule.NPCsUseFrontalStunImmunityClasses
Rule.NPCsUseFrontalStunImmunityRaces
Rule.NPCtoNPCPush
Rule.NavmeshStepSize
Rule.NecromancerTrackingDistanceMultiplier
Rule.NewLevelScaling
Rule.NoSkillsOnHorse
Rule.NormalizedAAEnabled
Rule.NormalizedAANumberOfWhiteConPerAA
Rule.NumberKillsForBossSpawn
Rule.OOCRegen
Rule.OPClientUpdateVisualDebug
Rule.OgreCommonTongue
Rule.OldMinMana
Rule.OldRaceRezEffects
Rule.OldRainTargets
Rule.OldResurrectionSicknessSpell
Rule.OldResurrectionSicknessSpellID
Rule.OnInviteReceiveAlreadyinGroupMessage
Rule.OneProcPerWeapon
Rule.PCAccuracyAvoidanceMod2Scale
Rule.PCAttackPowerScaling
Rule.PCKickStunLevel
Rule.PEQZoneDebuff1
Rule.PEQZoneDebuff2
Rule.PEQZoneHPRatio
Rule.PEQZoneReuseTime
Rule.PVPEnableGuardFactionAssist
Rule.PVPMinLevel
Rule.PVPSettings
Rule.PaladinTrackingDistanceMultiplier
Rule.ParcelDeliveryCostMod
Rule.ParcelDeliveryDelay
Rule.ParcelMaxItems
Rule.ParcelPruneDelay
Rule.PerCharacterBucketMaxLevel
Rule.PerCharacterQglobalMaxLevel
Rule.PeriodicCheckTimer
Rule.PetAttackMagicLevel
Rule.PetAttackRange
Rule.PetBaseCritChance
Rule.PetPowerLevelCap
Rule.PetSpellAggroMod
Rule.PetTauntRange
Rule.PetZoneWithOwner
Rule.PetsUseReagents
Rule.PlayerCreationAllowed
Rule.PlayerCreationLimit
Rule.PlayerCreationRequiredLevel
Rule.PlayerCreationRequiredStatus
Rule.PlayerCreationRequiredTime
Rule.PlayerDropItems
Rule.PlayerEventsQSProcess
Rule.PlayerLogAAPurchases
Rule.PlayerLogAARate
Rule.PlayerLogAlternateCurrencyTransactions
Rule.PlayerLogChat
Rule.PlayerLogConnectDisconnect
Rule.PlayerLogDeaths
Rule.PlayerLogDeletes
Rule.PlayerLogHandins
Rule.PlayerLogIssuedCommandes
Rule.PlayerLogLevels
Rule.PlayerLogMerchantTransactions
Rule.PlayerLogMoves
Rule.PlayerLogNPCKills
Rule.PlayerLogQGlobalUpdate
Rule.PlayerLogTaskUpdates
Rule.PlayerLogTradeSkillEvents
Rule.PlayerLogTrades
Rule.PlayerLogZone
Rule.PlayerTradingLoreFeedback
Rule.PointBlankAOEMaxTargets
Rule.PreNerfBardAEDoT
Rule.PreferNoManaCommandSpells
Rule.PreventFactionWarOnCharmBreak
Rule.PreventMountsFromZoning
Rule.PriceBonusPct
Rule.PricePenaltyPct
Rule.PrintFileFunctionAndLine
Rule.ProcDexDivideBy
Rule.ProcPerMinDexContrib
Rule.ProcessFearedProximity
Rule.ProjectileDmgOnImpact
Rule.QuestDialogueUsesDialogueWindow
Rule.QuestableSpawnLimit
Rule.QuestsAutoReloadGlobalScripts
Rule.QuestsRepopWhenPlayersNotInCombat
Rule.QuestsRepopWithReload
Rule.QuestsResetTimersWithReload
Rule.QuiverHasteCap
Rule.RadiantCrystalItemID
Rule.RaidExpMultiplier
Rule.RampageHitsTarget
Rule.RangerTrackingDistanceMultiplier
Rule.RecordBuyFromMerchant
Rule.RecordCompletedOptionalActivities
Rule.RecordCompletedTasks
Rule.RecordSellToMerchant
Rule.RecycleInstanceIds
Rule.RedModifier
Rule.ReflectMessagesClose
Rule.ReflectType
Rule.ReportingSystemActive
Rule.RequestCooldownTimerSeconds
Rule.RequireKeyOnCursor
Rule.RequireMnemonicRetention
Rule.RequireTomeHandin
Rule.RequiredStatusAdmin
Rule.RequiredStatusListAll
Rule.ResendDelayBaseMS
Rule.ResendDelayFactor
Rule.ResendDelayMaxMS
Rule.ResendDelayMinMS
Rule.ReservedInstances
Rule.ResistFalloff
Rule.RespawnFromHover
Rule.RespawnFromHoverTimer
Rule.RestRegenEnabled
Rule.RestRegenRaidTimeToActivate
Rule.RestRegenTimeToActivate
Rule.RestrictApplyPotionToRogue
Rule.RestrictSpellScribing
Rule.ResurrectRadius
Rule.ResurrectionEffectBlock
Rule.ResurrectionSickness
Rule.ResurrectionSicknessSpell
Rule.ResurrectionSicknessSpellID
Rule.ReturnNonQuestNoDropItems
Rule.ReturnQuestItemsFromNonQuestNPCs
Rule.RogueBackstabHasteCorrection
Rule.RogueTrackingDistanceMultiplier
Rule.RootBreakCheckChance
Rule.RootBreakFromSpells
Rule.RoundKickBaseDamage
Rule.Rules
Rule.SHDProcIDOffByOne
Rule.SacrificeItemID
Rule.SacrificeMaxLevel
Rule.SacrificeMinLevel
Rule.Say
Rule.SayPauseTimeInSec
Rule.ScaleRate
Rule.SelfLanguageLearning
Rule.SellCostMod
Rule.SenseHeadingStartValue
Rule.ServerWideAuction
Rule.ServerWideOOC
Rule.SessionTimeOut
Rule.ShadowKnightTrackingDistanceMultiplier
Rule.ShamanTrackingDistanceMultiplier
Rule.SharedBankPlat
Rule.SharedTasksTerminateTimerMS
Rule.SharedTasksWorldProcessRate
Rule.ShortMovementUpdateRange
Rule.ShowExpValues
Rule.SittingAggroMod
Rule.SkillCapMaxLevel
Rule.SkillUpFromItems
Rule.SkillUpMaximumChancePercentage
Rule.SkillUpMinimumChancePercentage
Rule.SkillUpModifier
Rule.SlayDamageMultiplier
Rule.SlayRateMultiplier
Rule.SmartAggroList
Rule.SmartLastFightingDelayMoving
Rule.SnareOverridesSpeedBonuses
Rule.SneakAlwaysSucceedOver100
Rule.SneakPullAssistRange
Rule.SoDClientUseSoDHPManaEnd
Rule.SoFStartZoneID
Rule.SoftDeletes
Rule.SongMessages
Rule.SoundForAAEarned
Rule.SpawnEventMin
Rule.SpawnLimit
Rule.SpellAggroMod
Rule.SpellMessages
Rule.SpellParticles
Rule.SpellResistSoftCap
Rule.StartEnrageValue
Rule.StartZoneSameAsBindOnCreation
Rule.StatCap
Rule.StunChance
Rule.StunDuration
Rule.StunMessages
Rule.SuccorFailChance
Rule.SummonItemAllowInvisibleAugments
Rule.SummonMeleeRange
Rule.SupportedClients
Rule.SuppressCommandErrors
Rule.SuspendIntervalMS
Rule.SuspendIntervalS
Rule.SwarmPetTargetLock
Rule.SwimmingStartValue
Rule.TargetedAOEMaxTargets
Rule.TargetsTargetRequiresCombatRange
Rule.TauntChanceBonus
Rule.TauntOverAggro
Rule.TauntOverLevel
Rule.TauntSkillFalloff
Rule.TellQueueSize
Rule.ThreateninglyFactionMinimum
Rule.ThrowingBaseDamage
Rule.ThrowingConsumesAmmo
Rule.ThrowingCritDifficulty
Rule.TigerClawBaseDamage
Rule.TitaniumStartZoneID
Rule.TrackingAutoRefreshSkillUps
Rule.TradeSkillClamp
Rule.TradeskillUpAlchemy
Rule.TradeskillUpBaking
Rule.TradeskillUpBlacksmithing
Rule.TradeskillUpBrewing
Rule.TradeskillUpFletching
Rule.TradeskillUpJewelcrafting
Rule.TradeskillUpMakePoison
Rule.TradeskillUpPottery
Rule.TradeskillUpResearch
Rule.TradeskillUpTailoring
Rule.TradeskillUpTinkering
Rule.TrainSenseHeading
Rule.TransformSummonedBags
Rule.TranslocateTimeLimit
Rule.TributePlatConversionRate
Rule.TributeTime
Rule.TributeTimeRefreshInterval
Rule.TrivialTradeskillCombinesNoFail
Rule.TrollCommonTongue
Rule.TunnelVisionAggroMod
Rule.TutorialZoneID
Rule.UnTargetableSwarmPet
Rule.UndeadAlwaysAggro
Rule.UnmemSpellsOnDeath
Rule.UnusedAAPointCap
Rule.UpdateOneElementPerTask
Rule.UpkeepIntervalMS
Rule.UseAdditiveFocusFromWornSlot
Rule.UseAdditiveFocusFromWornSlotWithLimits
Rule.UseAltSinisterStrikeFormula
Rule.UseBaneDamage
Rule.UseBannedIPsTable
Rule.UseCHAScribeHack
Rule.UseCharacterMaxLevelForGuildTributes
Rule.UseClassAsLastName
Rule.UseClassicHarmTouchDamage
Rule.UseClassicPriceMod
Rule.UseClassicSpellFocus
Rule.UseClientBasedExpansionSettings
Rule.UseCurrentExpansionAAOnly
Rule.UseDeathExpLossMult
Rule.UseEnhancedMobStaticWeaponSkill
Rule.UseExtendedPoisonProcs
Rule.UseFadingMemoriesMaxLevel
Rule.UseForageCommonFood
Rule.UseIntervalAC
Rule.UseItemBonusesForNonPets
Rule.UseItemCastMessage
Rule.UseItemLinksForKeyRing
Rule.UseLegacyFizzleCode
Rule.UseLevelAggro
Rule.UseLimitTradeskillSearchSkillDiff
Rule.UseLiveBlockedMessage
Rule.UseLiveCombatRounds
Rule.UseLiveFactionMessage
Rule.UseLiveRiposteMechanics
Rule.UseLiveSpellProjectileGFX
Rule.UseMeditateBasedManaRegen
Rule.UseMobStaticOffenseSkill
Rule.UseNPCDamageClassLevelMods
Rule.UseNewStatsWindow
Rule.UseNoJunkFishing
Rule.UseOldBindWound
Rule.UseOldClassExpPenalties
Rule.UseOldConSystem
Rule.UseOldRaceExpPenalties
Rule.UseOldRaceRezEffects
Rule.UseOldShadowKnightClassExport
Rule.UsePEQZoneDebuffs
Rule.UsePriceMod
Rule.UseRaceClassExpBonuses
Rule.UseResurrectionSickness
Rule.UseRevampHandToHand
Rule.UseSpellFileSongCap
Rule.UseSpellImpliedTargeting
Rule.UseStackablePickPocketing
Rule.UseXPConScaling
Rule.UseZoneController
Rule.VoucherDeliveryCost
Rule.WarmlyFactionMinimum
Rule.WarriorTrackingDistanceMultiplier
Rule.WaterMatchRequiredForAutoFireLoS
Rule.WaterMatchRequiredForLoS
Rule.WeatherTimer
Rule.WhiteModifier
Rule.WizCritChance
Rule.WizCritLevel
Rule.WizCritRatio
Rule.WizardCritMaximumRandomRatio
Rule.WizardCritMinimumRandomRatio
Rule.WizardTrackingDistanceMultiplier
Rule.WorldGMSayLogging
Rule.WorldProcessRate
Rule.YellowModifier
Rule.ZoneAutobootTimeoutMS
Rule._BoolRuleCount
Rule._IntRuleCount
Rule._RealRuleCount
Rule._StringRuleCount
`
```

---

## Lua [Skill]

*Source: quest-api/constants/lua-skill/index.html*

# Lua [Skill]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Skill.1HBlunt
Skill.1HPiercing
Skill.1HSlashing
Skill.2HBlunt
Skill.2HPiercing
Skill.2HSlashing
Skill.Abjuration
Skill.Alchemy
Skill.AlcoholTolerance
Skill.Alteration
Skill.ApplyPoison
Skill.Archery
Skill.Backstab
Skill.Baking
Skill.Bash
Skill.Begging
Skill.Berserking
Skill.BindWound
Skill.Blacksmithing
Skill.Block
Skill.Blunt1H
Skill.Blunt2H
Skill.BrassInstruments
Skill.Brewing
Skill.Channeling
Skill.Conjuration
Skill.Defense
Skill.Disarm
Skill.DisarmTraps
Skill.Divination
Skill.Dodge
Skill.DoubleAttack
Skill.DragonPunch
Skill.DualWield
Skill.EagleStrike
Skill.Evocation
Skill.FeignDeath
Skill.Fishing
Skill.Fletching
Skill.FlyingKick
Skill.Forage
Skill.Frenzy
Skill.HIGHEST_SKILL
Skill.HandtoHand
Skill.Hide
Skill.Intimidation
Skill.JewelryMaking
Skill.Kick
Skill.MakePoison
Skill.Meditate
Skill.Mend
Skill.Offense
Skill.Parry
Skill.PercussionInstruments
Skill.PickLock
Skill.PickPockets
Skill.Piercing1H
Skill.Piercing2H
Skill.Pottery
Skill.RemoveTraps
Skill.Research
Skill.Riposte
Skill.RoundKick
Skill.SafeFall
Skill.SenseHeading
Skill.SenseTraps
Skill.Singing
Skill.Slashing1H
Skill.Slashing2H
Skill.Sneak
Skill.SpecializeAbjure
Skill.SpecializeAlteration
Skill.SpecializeConjuration
Skill.SpecializeDivination
Skill.SpecializeEvocation
Skill.StringedInstruments
Skill.Swimming
Skill.TailRake
Skill.Tailoring
Skill.Taunt
Skill.Throwing
Skill.TigerClaw
Skill.Tinkering
Skill.Tracking
Skill.TripleAttack
Skill.WindInstruments
`
```

---

## Lua [Slot]

*Source: quest-api/constants/lua-slot/index.html*

# Lua [Slot]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Slot.Ammo
Slot.Arms
Slot.AugSocketBegin
Slot.AugSocketEnd
Slot.Augment
Slot.Back
Slot.BagSlotBegin
Slot.BagSlotEnd
Slot.BankBagsBegin
Slot.BankBagsEnd
Slot.BankBegin
Slot.BankEnd
Slot.Bracer1
Slot.Bracer2
Slot.Charm
Slot.Chest
Slot.Cursor
Slot.CursorBagBegin
Slot.CursorBagEnd
Slot.CursorEnd
Slot.Ear1
Slot.Ear2
Slot.EquipmentBegin
Slot.EquipmentEnd
Slot.Face
Slot.Feet
Slot.Finger1
Slot.Finger2
Slot.General1
Slot.General10
Slot.General10BagBegin
Slot.General10BagEnd
Slot.General1BagBegin
Slot.General1BagEnd
Slot.General2
Slot.General2BagBegin
Slot.General2BagEnd
Slot.General3
Slot.General3BagBegin
Slot.General3BagEnd
Slot.General4
Slot.General4BagBegin
Slot.General4BagEnd
Slot.General5
Slot.General5BagBegin
Slot.General5BagEnd
Slot.General6
Slot.General6BagBegin
Slot.General6BagEnd
Slot.General7
Slot.General7BagBegin
Slot.General7BagEnd
Slot.General8
Slot.General8BagBegin
Slot.General8BagEnd
Slot.General9
Slot.General9BagBegin
Slot.General9BagEnd
Slot.GeneralBagsBegin
Slot.GeneralBagsEnd
Slot.GeneralBegin
Slot.GeneralEnd
Slot.Hands
Slot.Head
Slot.Invalid
Slot.Legs
Slot.Neck
Slot.PersonalBegin
Slot.PersonalEnd
Slot.PossessionsBagsBegin
Slot.PossessionsBagsEnd
Slot.PossessionsBegin
Slot.PossessionsEnd
Slot.PowerSource
Slot.Primary
Slot.Range
Slot.Ring1
Slot.Ring2
Slot.Secondary
Slot.SharedBankBagsBegin
Slot.SharedBankBagsEnd
Slot.SharedBankBegin
Slot.SharedBankEnd
Slot.Shoulder
Slot.Shoulders
Slot.Tradeskill
Slot.Waist
Slot.Wrist1
Slot.Wrist2
`
```

---

## Lua [SpeakMode]

*Source: quest-api/constants/lua-speakmode/index.html*

# Lua [SpeakMode]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`SpeakMode.Emote
SpeakMode.EmoteAlt
SpeakMode.Group
SpeakMode.Raw
SpeakMode.Say
SpeakMode.Shout
`
```

---

## Lua [SpecialAbility]

*Source: quest-api/constants/lua-specialability/index.html*

# Lua [SpecialAbility]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`SpecialAbility.allow_beneficial
SpecialAbility.allow_to_tank
SpecialAbility.always_flee
SpecialAbility.area_rampage
SpecialAbility.bane_attack
SpecialAbility.casting_resist_diff
SpecialAbility.counter_avoid_damage
SpecialAbility.destructible_object
SpecialAbility.disable_melee
SpecialAbility.dont_buff_friends
SpecialAbility.enrage
SpecialAbility.flee_percent
SpecialAbility.flurry
SpecialAbility.ignore_root_aggro_rules
SpecialAbility.immune_aggro
SpecialAbility.immune_aggro_bot
SpecialAbility.immune_aggro_client
SpecialAbility.immune_aggro_npc
SpecialAbility.immune_aggro_on
SpecialAbility.immune_assassinate
SpecialAbility.immune_casting_from_range
SpecialAbility.immune_damage_bot
SpecialAbility.immune_damage_client
SpecialAbility.immune_damage_npc
SpecialAbility.immune_feign_death
SpecialAbility.immune_fleeing
SpecialAbility.immune_headshot
SpecialAbility.immune_magic
SpecialAbility.immune_melee
SpecialAbility.immune_melee_except_bane
SpecialAbility.immune_melee_except_magical
SpecialAbility.immune_open
SpecialAbility.immune_pacify
SpecialAbility.immune_ranged_attacks
SpecialAbility.immune_taunt
SpecialAbility.innate_dual_wield
SpecialAbility.leash
SpecialAbility.magical_attack
SpecialAbility.modify_avoid_damage
SpecialAbility.no_harm_from_client
SpecialAbility.npc_chase_distance
SpecialAbility.quad_attack
SpecialAbility.rampage
SpecialAbility.ranged_attack
SpecialAbility.summon
SpecialAbility.tether
SpecialAbility.triple_attack
SpecialAbility.tunnelvision
SpecialAbility.uncharmable
SpecialAbility.undispellable
SpecialAbility.unfearable
SpecialAbility.unmezable
SpecialAbility.unslowable
SpecialAbility.unsnareable
SpecialAbility.unstunable
`
```

---

## Lua [Zone]

*Source: quest-api/constants/lua-zone/index.html*

# Lua [Zone]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`Zone.abysmal
Zone.acrylia
Zone.airplane
Zone.akanon
Zone.akheva
Zone.alkabormare
Zone.anguish
Zone.apprentice
Zone.arcstone
Zone.arelis
Zone.arena
Zone.arena2
Zone.argath
Zone.arthicrex
Zone.arttest
Zone.ashengate
Zone.atiiki
Zone.aviak
Zone.barindu
Zone.barren
Zone.barter
Zone.bazaar
Zone.beastdomain
Zone.befallen
Zone.befallenb
Zone.beholder
Zone.bertoxtemple
Zone.blackburrow
Zone.blacksail
Zone.bloodfields
Zone.bloodmoon
Zone.bothunder
Zone.breedinggrounds
Zone.brellsarena
Zone.brellsrest
Zone.brellstemple
Zone.broodlands
Zone.buriedsea
Zone.burningwood
Zone.butcher
Zone.cabeast
Zone.cabwest
Zone.cauldron
Zone.causeway
Zone.cazicthule
Zone.chambersa
Zone.chambersb
Zone.chambersc
Zone.chambersd
Zone.chamberse
Zone.chambersf
Zone.chapterhouse
Zone.charasis
Zone.chardok
Zone.chardokb
Zone.citymist
Zone.cityofbronze
Zone.clz
Zone.cobaltscar
Zone.codecay
Zone.commonlands
Zone.commons
Zone.convorteum
Zone.coolingchamber
Zone.corathus
Zone.corathusa
Zone.corathusb
Zone.crescent
Zone.crushbone
Zone.cryptofshade
Zone.crystal
Zone.crystallos
Zone.crystalshard
Zone.cshome
Zone.dalnir
Zone.dawnshroud
Zone.deadbone
Zone.delvea
Zone.delveb
Zone.devastation
Zone.devastationa
Zone.direwind
Zone.discord
Zone.discordtower
Zone.drachnidhive
Zone.drachnidhivea
Zone.drachnidhiveb
Zone.drachnidhivec
Zone.dragoncrypt
Zone.dragonscale
Zone.dragonscaleb
Zone.dranik
Zone.dranikcatacombsa
Zone.dranikcatacombsb
Zone.dranikcatacombsc
Zone.dranikhollowsa
Zone.dranikhollowsb
Zone.dranikhollowsc
Zone.draniksewersa
Zone.draniksewersb
Zone.draniksewersc
Zone.draniksscar
Zone.dreadlands
Zone.dreadspire
Zone.droga
Zone.dulak
Zone.eastkarana
Zone.eastkorlach
Zone.eastkorlacha
Zone.eastsepulcher
Zone.eastwastes
Zone.eastwastesshard
Zone.echo_
Zone.ecommons
Zone.elddar
Zone.elddara
Zone.emeraldjungle
Zone.erudnext
Zone.erudnint
Zone.erudsxing
Zone.erudsxing2
Zone.everfrost
Zone.eviltree
Zone.fallen
Zone.fearplane
Zone.feerrott
Zone.feerrott2
Zone.felwithea
Zone.felwitheb
Zone.ferubi
Zone.fhalls
Zone.fieldofbone
Zone.firiona
Zone.foundation
Zone.freeportacademy
Zone.freeportarena
Zone.freeportcityhall
Zone.freeporteast
Zone.freeporthall
Zone.freeportmilitia
Zone.freeportsewers
Zone.freeporttemple
Zone.freeporttheater
Zone.freeportwest
Zone.freporte
Zone.freportn
Zone.freportw
Zone.frontiermtns
Zone.frostcrypt
Zone.frozenshadow
Zone.fungalforest
Zone.fungusgrove
Zone.gfaydark
Zone.greatdivide
Zone.grelleth
Zone.griegsend
Zone.grimling
Zone.grobb
Zone.growthplane
Zone.guardian
Zone.guildhall
Zone.guildlobby
Zone.guka
Zone.gukb
Zone.gukbottom
Zone.gukc
Zone.gukd
Zone.guke
Zone.gukf
Zone.gukg
Zone.gukh
Zone.guktop
Zone.gunthak
Zone.gyrospireb
Zone.gyrospirez
Zone.halas
Zone.harbingers
Zone.hateplane
Zone.hateplaneb
Zone.hatesfury
Zone.highkeep
Zone.highpass
Zone.highpasshold
Zone.highpasskeep
Zone.hillsofshade
Zone.hohonora
Zone.hohonorb
Zone.hole
Zone.hollowshade
Zone.housegarden
Zone.iceclad
Zone.icefall
Zone.ikkinz
Zone.illsalin
Zone.illsalina
Zone.illsalinb
Zone.illsalinc
Zone.inktuta
Zone.innothule
Zone.innothuleb
Zone.jaggedpine
Zone.jardelshook
Zone.kael
Zone.kaelshard
Zone.kaesora
Zone.kaladima
Zone.kaladimb
Zone.karnor
Zone.katta
Zone.kattacastrum
Zone.kedge
Zone.kerraridge
Zone.kithforest
Zone.kithicor
Zone.kodtaz
Zone.korascian
Zone.kurn
Zone.lakeofillomen
Zone.lakerathe
Zone.lavastorm
Zone.letalis
Zone.lfaydark
Zone.lichencreep
Zone.load
Zone.load2
Zone.lopingplains
Zone.maiden
Zone.maidensgrave
Zone.mansion
Zone.mechanotus
Zone.mesa
Zone.mira
Zone.miragulmare
Zone.mirb
Zone.mirc
Zone.mird
Zone.mire
Zone.mirf
Zone.mirg
Zone.mirh
Zone.miri
Zone.mirj
Zone.mischiefplane
Zone.mistmoore
Zone.misty
Zone.mistythicket
Zone.mmca
Zone.mmcb
Zone.mmcc
Zone.mmcd
Zone.mmce
Zone.mmcf
Zone.mmcg
Zone.mmch
Zone.mmci
Zone.mmcj
Zone.monkeyrock
Zone.moors
Zone.morellcastle
Zone.mseru
Zone.nadox
Zone.najena
Zone.natimbi
Zone.necropolis
Zone.nedaria
Zone.neighborhood
Zone.nektropos
Zone.nektulos
Zone.nektulosa
Zone.neriaka
Zone.neriakb
Zone.neriakc
Zone.neriakd
Zone.netherbian
Zone.nexus
Zone.nightmareb
Zone.northkarana
Zone.northro
Zone.nro
Zone.nurga
Zone.oasis
Zone.oceangreenhills
Zone.oceangreenvillage
Zone.oceanoftears
Zone.oggok
Zone.oldblackburrow
Zone.oldbloodfield
Zone.oldcommons
Zone.olddranik
Zone.oldfieldofbone
Zone.oldhighpass
Zone.oldkaesoraa
Zone.oldkaesorab
Zone.oldkithicor
Zone.oldkurn
Zone.oot
Zone.overthere
Zone.paineel
Zone.paludal
Zone.paw
Zone.pellucid
Zone.permafrost
Zone.pillarsalra
Zone.poair
Zone.podisease
Zone.poeartha
Zone.poearthb
Zone.pofire
Zone.poinnovation
Zone.pojustice
Zone.poknowledge
Zone.ponightmare
Zone.postorms
Zone.potactics
Zone.potimea
Zone.potimeb
Zone.potorment
Zone.potranquility
Zone.povalor
Zone.powar
Zone.powater
Zone.precipiceofwar
Zone.provinggrounds
Zone.qcat
Zone.qey2hh1
Zone.qeynos
Zone.qeynos2
Zone.qeytoqrg
Zone.qinimi
Zone.qrg
Zone.qvic
Zone.qvicb
Zone.rage
Zone.ragea
Zone.rathechamber
Zone.rathemtn
Zone.redfeather
Zone.relic
Zone.resplendent
Zone.riftseekers
Zone.rivervale
Zone.riwwi
Zone.roost
Zone.rubak
Zone.ruja
Zone.rujb
Zone.rujc
Zone.rujd
Zone.ruje
Zone.rujf
Zone.rujg
Zone.rujh
Zone.ruji
Zone.rujj
Zone.runnyeye
Zone.sarithcity
Zone.scarlet
Zone.sebilis
Zone.sepulcher
Zone.shadeweaver
Zone.shadowhaven
Zone.shadowrest
Zone.shadowspine
Zone.shardslanding
Zone.sharvahl
Zone.shiningcity
Zone.shipmvm
Zone.shipmvp
Zone.shipmvu
Zone.shippvu
Zone.shipuvu
Zone.shipworkshop
Zone.silyssar
Zone.sirens
Zone.skyfire
Zone.skylance
Zone.skyshrine
Zone.sleeper
Zone.sncrematory
Zone.snlair
Zone.snplant
Zone.snpool
Zone.soldunga
Zone.soldungb
Zone.soldungc
Zone.solrotower
Zone.soltemple
Zone.solteris
Zone.somnium
Zone.southkarana
Zone.southro
Zone.sro
Zone.sseru
Zone.ssratemple
Zone.steamfactory
Zone.steamfont
Zone.steamfontmts
Zone.steppes
Zone.stillmoona
Zone.stillmoonb
Zone.stonebrunt
Zone.stonehive
Zone.stonesnake
Zone.suncrest
Zone.sunderock
Zone.swampofnohope
Zone.tacvi
Zone.taka
Zone.takb
Zone.takc
Zone.takd
Zone.take
Zone.takf
Zone.takg
Zone.takh
Zone.taki
Zone.takishruins
Zone.takishruinsa
Zone.takj
Zone.templeveeshan
Zone.tenebrous
Zone.thalassius
Zone.theater
Zone.theatera
Zone.thedeep
Zone.thegrey
Zone.thenest
Zone.thevoida
Zone.thevoidb
Zone.thevoidc
Zone.thevoidd
Zone.thevoide
Zone.thevoidf
Zone.thevoidg
Zone.thuledream
Zone.thulehouse1
Zone.thulehouse2
Zone.thulelibrary
Zone.thundercrest
Zone.thurgadina
Zone.thurgadinb
Zone.timorous
Zone.tipt
Zone.torgiran
Zone.toskirakk
Zone.tox
Zone.toxxulia
Zone.trakanon
Zone.tutorial
Zone.tutoriala
Zone.tutorialb
Zone.twilight
Zone.txevu
Zone.umbral
Zone.underquarry
Zone.unrest
Zone.uqua
Zone.valdeholm
Zone.veeshan
Zone.veksar
Zone.velketor
Zone.vergalid
Zone.vexthal
Zone.vxed
Zone.wakening
Zone.wallofslaughter
Zone.warrens
Zone.warslikswood
Zone.weddingchapel
Zone.weddingchapeldark
Zone.well
Zone.westkorlach
Zone.westkorlacha
Zone.westkorlachb
Zone.westkorlachc
Zone.westsepulcher
Zone.westwastes
Zone.windsong
Zone.xorbb
Zone.yxtta
Zone.zhisza
`
```

---

## Perl [Mob]

*Source: quest-api/constants/perl-mob/index.html*

# Perl [Mob]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$bot_id
$bot_owner_char_id
$class
$faction
$h
$hpratio
$mlevel
$mname
$mobid
$name
$race
$status
$targetid
$targetname
$uguild_id
$uguildrank
$ulevel
$userid
$x
$y
$z
`
```

---

## Perl [Zone]

*Source: quest-api/constants/perl-zone/index.html*

# Perl [Zone]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$instanceid
$instanceversion
$zonehour
$zoneid
$zoneln
$zonemin
$zonesn
$zonetime
$zoneuptime
$zoneweather
`
```

---

## Database API

*Source: quest-api/database/index.html*

# Database API

The database quest API allows scripts to connect to a MySQL/MariaDB database and perform queries without the need to install LuaSQL or use perl DBI.

## Database Resources

Ownership of handles that wrap database resources are adopted by the scripting language. The internal resource will be freed when the handle is destroyed or its `close()` method is called.

Lua is garbage collected so these handles should be closed explicitly when no longer needed. If not closed then Lua will hold database resources open for an indeterminate time until its GC runs. Since errors will halt script execution this can prevent handles from being closed. See the errors section for a workaround.

Perl is reference counted so handles will be closed when its last reference is destroyed by going out of scope (even on errors).

## Database Connections

Connections can be made manually or by using exported constants to connect to the server databases specified in `eqemu_config`.

The API uses the current zone connections by default when using a server database constant. An overload is available to create `Database` objects that make new connections.

Making new database connections avoids possible concurrency issues since the zone database connections might be used in other threads. The connection is synchronized for some prepared statement operations but safety isn't guaranteed. See the developer thread safety section for more info.

New connections also allow the use of unbuffered results with prepared statements. If a prepared statement is executed with buffering disabled, then all results must be fetched or freed before any other queries on that connection can occur. Failure to consume all results before the next query will cause a "Commands out of sync" error. If zone connections were used this would cause all zone queries on that connection to start failing if a script error occured before results could be fetched, or the server tried to perform a query in another thread before the script finished fetching results.

LuaPerl

```
`local db = Database() -- connects to default database using eqemu config credentials
local db = Database(Database.Default)
local db = Database(Database.Content)
local db = Database(Database.Default, false) -- uses zone's database connection
local db = Database("127.0.0.1", "user", "pass", "db", 3306)
`
```

```
`my $db = Database::new(); # connects to default database using eqemu config credentials
my $db = Database::new(Database::Default);
my $db = Database::new(Database::Content);
my $db = Database::new(Database::Content, 0); # uses zone's content_db connection
my $db = Database::new("127.0.0.1", "user", "pass", "db", 3306);
`
```

## Errors

Errors in prepared statements will propagate the `std::runtime_error` exception as a quest error and automatically halt the script. This is similar to the behavior of using `assert()` in Lua or `die` in perl to error out of the script.

This means db resources cannot be freed automatically on errors since the script gets halted and will never reach any calls to `close()` resources. Perl will destroy objects in scope via reference counting so it has less risk of holding resources open. In Lua this is a problem because the GC may not run immediately (if ever). To work around this in Lua, scripts can wrap API calls with `pcall()` to manually catch db errors and free resources.

#### Catching Lua Errors

```
`local query = "select * from badtable where id = ?"
local db = Database()

local ok, stmt = pcall(function() return db:prepare(query) end)
if not ok then
 db:close()
 if stmt then error("error: " .. stmt) end
end

local ok, err = pcall(function() return stmt:execute({1}) end)
if not ok then
 stmt:close()
 db:close()
 if err then error("error: " .. err) end
end

-- do stuff

stmt:close()
db:close()
`
```

Manually catching errors like this should generally not be necessary except for custom handling.

## Example

Warning

Query strings formed by concatenating the values can be vulnerable to SQL injection. It's recommended to always use value placeholders with prepared statements.

LuaPerl

```
`local db = Database(Database.Content)
local stmt = db:prepare("select * from items where id = ? or name = ?")
stmt:execute({ 1001, "Soul's Eye" })
local row = stmt:fetch_hash()
while row do
 eq.debug(string.format("id %d, name %s", row.id, row.Name))
 row = stmt:fetch_hash() -- next
end
stmt:close()
db:close()
`
```

```
`my $db = Database::new(Database::Content);
my $stmt = $db->prepare("select * from items where id = ? or name = ?");
$stmt->execute(1001, "Soul's Eye");
while (my $row = $stmt->fetch_hashref())
{
 quest::debug("id: " . $row->{"id"} . " name: " . $row->{"Name"});
}
$stmt->close();
$db->close();
`
```

## Lua Iterator

It may be convenient to use custom iterators to fetch rows in Lua:

```
`local function array_iter(stmt)
 return function() return stmt:fetch_array() end
end

local function hash_iter(stmt)
 return function() return stmt:fetch_hash() end
end

local stmt = db:prepare("select * from items where id = ? or name = ?")
stmt:execute({ 1001, "Soul's Eye" })
for row in hash_iter(stmt) do
 eq.debug(string.format("id %d, name %s", row["id"], row["Name"]))
end
`
```

## Passing NULL

Lua tables cannot have `nil` values. Using `nil` in calls to `execute()` will not work and result in the wrong number of expected arguments. Passing `NULL` in `execute()` requires passing a table instead. Perl can use `undef`.

LuaPerl

```
`local null = {} -- re-usable
local stmt = db:prepare("INSERT INTO some_table (id, nullable, str) VALUES (?, ?, ?)")
stmt:execute({ 1, null, "value" })
eq.debug("affected: " .. stmt:rows_affected())
`
```

```
`my $stmt = $db->prepare("INSERT INTO some_table (id, nullable, str) VALUES (?, ?, ?)");
$stmt->execute(1, undef, "value");
quest::debug("affected: " . $stmt->rows_affected());
`
```

## BigInt Columns

Lua prior to version 5.3 only has 53-bit integer precision because all numbers are stored as `double`. 64-bit `BIGINT` column values are pushed as strings when prepared statement rows are fetched to avoid loss of precision. This leaves scripts responsible for either converting the value to a number and losing precision, using a big number library, or using LuaJIT FFI. Big integers larger than 253 should also be passed as strings when executing prepared statements from scripts.

Note

Lua 5.3 and later support a separate integer type stored as signed 64-bit integer by default. Large unsigned 64-bit integers will overflow into negative signed values in those versions.

In perl 64-bit integers are supported when building for 64-bit targets so no special handling is done when pushing from the quest API.

## API

### Constants

---

`Connection` constants are used to identify zone database connections.

LuaPerl

| 

Constant 
| Value 
| Description 

| Database.Default 
| 0 
| Reference the default database connection 

| Database.Content 
| 1 
| Reference the content database connection 

| 

Constant 
| Value 
| Description 

| Database::Default 
| 0 
| Reference the default database connection 

| Database::Content 
| 1 
| Reference the content database connection 

### Database

---

Constructors

LuaPerl

`Database()`
Returns a `Database` object that connects to the server's default database connection. If the connection fails then a `std::runtime_error` exception is thrown and script execution halts.
`Database(Connection type, bool connect = false)`
Returns a `Database` object for the specified server database type specified in the eqemu_config. If `connect` is `true` a new connection is made to the database. If `connect` is `false` the `Database` object uses the zone's current active server connection. If the connection fails or the connection type is invalid a `std::runtime_error` exception is thrown and script execution halts.
`Database(string host, string user, string pass, string dbname, int port)`
Returns a `Database` object that connects to the specified database. If the connection fails then a `std::runtime_error` exception is thrown and script execution halts.

`Database::new()`
Returns a `Database` object that connects to the server's default database connection. If the connection fails then a `std::runtime_error` exception is thrown and script execution halts.
`Database::new(Connection type, bool connect = false)`
Returns a `Database` object for the specified server database type specified in the eqemu_config. If `connect` is `true` a new connection is made to the database. If `connect` is `false` the `Database` object uses the zone's current active server connection. If the connection fails or the connection type is invalid a `std::runtime_error` exception is thrown and script execution halts.
`Database::new(string host, string user, string pass, string dbname, int port)`
Returns a `Database` object that connects to the specified database. If the connection fails then a `std::runtime_error` exception is thrown and script execution halts.

Functions

`close()`
Closes the database connection. The quest object is invalidated and should not be used after this is called.
`prepare(string query)`
Prepares a statement and returns a `MySQLPreparedStmt` object. Throws `std::runtime_error` on error which halts the script with a quest error message.

### MySQLPreparedStmt

---

`close()`
Deletes the underlying `mysql::StmtResult` and `mysql::PreparedStmt` resources. Closes the prepared statement by calling `mysql_stmt_close()` which will free any active result set. The quest object is invalidated and should not be used after this is called.
`execute()`
`execute(array values)`

Executes the prepared statement with specified input arguments. Results are accessible from the current object. Invalidates any previous result set.

Example

LuaPerl

```
`local stmt = db:prepare("select * from items where id = ? or name = ?")
stmt:execute({ 1001, "Soul's Eye" })
eq.debug("result row count: " .. stmt:num_rows())
`
```

```
`my $stmt = $db->prepare("select * from items where id = ? or name = ?");
$stmt->execute(1001, "Soul's Eye");
quest::debug("result row count: " . $stmt->num_rows());
`
```

`fetch()`
Alias for `fetch_array`.
`fetch_array()`

Fetches the next row and returns an array of column values. Value types will be either numbers or strings to match field types unless `NULL`.

LuaPerl

`NULL` column values will not exist in the returned table. This can leave gaps in table indexes which means `ipairs` should not be used to iterate it. Returns `nil` if no more rows to fetch.

`NULL` column values will have `undef` values in the array. Returns an empty value if no more rows to fetch.

`fetch_arrayref()` Perl only
Fetches the next row and returns a reference to an array of column values. `NULL` column values will have `undef` values in the array. Other value types will be either numbers or strings to match field types. Returns an empty value if no more rows to fetch.
`fetch_hash()` Lua only
Fetches the next row and returns a hash table of column values with field name keys. `NULL` column values will not exist in the returned table. Other value types will be either numbers or strings to match field types. Returns `nil` if no more rows to fetch.
`fetch_hashref()` Perl only
Fetches the next row and returns a reference to a hash of column values with field name keys. `NULL` column values will have `undef` values in the hash. Other value types will be either numbers or strings to match field types. Returns an empty value if no more rows to fetch.
`insert_id()`
Returns the last insert id of an `AUTO_INCREMENT` column generated by an `INSERT` query.
`num_fields()`
Returns the number of fields in a result set for a `SELECT` query.
`num_rows()`
Returns the number of rows in a result set for a `SELECT` query. If buffering is disabled for the prepared statement then this will return 0.
`rows_affected()`
Returns the number of rows affected by an `UPDATE`, `DELETE`, or `INSERT` query.
`set_options(hash options)`

Sets prepared statement options using a hash table with option name as key. Preserves current value of unspecified options.

| 

Option 
| Default 
| Description 

| `buffer_results` 
| true 
| Enable buffering the entire result set of an executed prepared statement 

| `use_max_length` 
| true 
| Enable the `max_length` of fields to be calculated on execution (requires buffering) 

Example

LuaPerl

```
`local stmt = db:prepare("select * from table")
stmt:set_options({ ["buffer_results"] = false })
`
```

```
`my $stmt = $db->prepare("select * from table");
$stmt->set_options(("buffer_results" => 0));
`
```

---

## Dialogue Window (DiaWind)

*Source: quest-api/diawind/index.html*

# DiaWind (Dialogue Window)

Dialogue Window used to be a plugin that is now source-native that provides a simple way to deliver a dialogue experience to players through a popup window instead of through the chat window.

## Note

- Using newlines may cause the dialogue window to not function properly. Example below.

### No Newlines

```
`sub EVENT_SAY {
 if ($text=~/#a/i) {
 my $dialogMessage = "{title: Title} {button_one: Button One} {button_two: Button Two} wintype:1 Message";
 quest::crosszonedialoguewindowbycharid($client->CharacterID(), $dialogMessage);
 }
}
`
```

### Newlines

```
`sub EVENT_SAY {
 if ($text=~/#a/i) {
 my $dialogMessage = "{title: Title}
 {button_one: Button One}
 {button_two: Button Two}
 wintype:1
 Message";
 quest::crosszonedialoguewindowbycharid($client->CharacterID(), $dialogMessage);
 }
}
`
```

## Features

- Simple custom markdown with features to change window behavior

- Simple html color code support

- NPC animation support

- Window timer support

- Saylink / Bracket support response through buttons

- If there are quest saylinks in the quest::say code, the dialogue window render will strip them out so they display normally in the window.

- If there are multiple saylink responses, they are rendered in the chat window per normal window implementation. Single responses are at the click of a button

- If there is no animation code set in the dialogue window the NPC will animate socially with a handful of different "greet" animations. This can also be shut off behind rule mentioned above

## Enabling

You can enable this feature globally and have it intercept all normal quest dialogue through middleware functionality by enabling **rules**

```
`RULE_BOOL(Chat, QuestDialogueUsesDialogueWindow, false, "Pipes all quest dialogue to dialogue window")
`
```

**QuestDialogueUsesDialogueWindow** will need to be set to true

## Examples

Below is when **QuestDialogueUsesDialogueWindow** is turned on, normal `quest::say` dialogue gets piped to a window.

### Multiple Buttons

```
`sub EVENT_SAY {
 $client->DiaWind("
 {title: This is my amazing window title!}
 {button_one: This is one!}
 {button_two: This is two!}
 wintype:1
 Hello!
 ");
}
`
```

**Quest API Methods**

```
`$client->DialogueWindow("markdown");
$client->DiaWind("markdown"); // alias
`
```

```
`e.other:DialogueWindow("markdown");
e.other:DiaWind("markdown"); // alias
`
```

## Markdown

- **{lb}** = Light Blue Color

- **{y}** = Yellow Color

- **{gold}** = Gold Color

- **{g}** = Green Color

- **{r}** = Red Color

- **{gray}** = Gray Color

- **~** = End Color Tag ()

- **[>** = Response Text (Not Visible) - This is what the player responds with, for example: [What else do we need to do?>

- **[]** = Response Text (Visible) - If a NPC has multiple brackets, it will give the player multiple saylinks to click, if there is just one [bracket] inline with the text, the player will respond by clicking 'Yes' on the window

- **+66+** = Animation number - As long as there is a number between two plus signs together, the NPC will perform that animation

- **+salute+** = Animation phrase - This references

- **{bullet}** - Equivalent to a bullet such as the one in this list

- **{in}** - Will indent the text

- **{linebreak}** - Will create a linebreak

- **mysterious** - If the text 'mysterious' is anywhere in the text, it will not show up in the player window, but it will format the window as 'Mysterious Voice tells you'

- **wintype:0/1** - If this is 1 the window will be Yes/No

- **popupid:ID** - If this option is present, it will give the popup window an ID response on "Yes" or button one

- **secondresponseid:id** - If this option is present, it will give the popup window an ID response on "No" or button two

- **noquotes** - This tells the window to not use any quotes for special formatting at times

- **nosound** - No sound affect will play with the window

- **=Timer=** - If a number is specified between the two ==, it will countdown a timer on the popup window

---

## Events

*Source: quest-api/events/index.html*

# Events

Info

If you're new to programming or scripting, many applications use event-driven architectural patterns. 

The EverQuest Emulator scripting engine is almost exclusively event driven and events are triggered through various player-triggered or environment-triggered mechanisms. 

Note

For the most up to date set of events see the **events** section in the left navigation pane

### Default Exports

- These exports are the default event objects exported along with these event types.

#### Bot

`e.self`

#### Encounter

`e.name`

#### Item

`e.self` and `e.owner`

#### NPC

`e.self`

#### Player

`e.self`

#### Spell

`e.self`

### EVENT_AGGRO

#### Trigger

- When a mob aggros a client.

Often used for flavor text--just remember that every NPC_Type has an EmoteID that can often handle this behavior.

#### Example

- In this example, the NPC will say "Time to die PlayerName." when the NPC is aggro'd by the player.

PerlLua

```
`sub EVENT_AGGRO {
 quest::say("Time to die!");
}
`
```

```
`function event_aggro(e)
 e.self:Say("Time to die!");
end
`
```

### EVENT_AGGRO_SAY

#### Trigger

- When a mob is targeted, the player types something, and NPC is in combat.

#### Exports

| 

Name 
| Type 
| Usage 

| data 
| int 
| `quest::say($data); # returns int` 

| text 
| int 
| `quest::say($text); # returns int` 

| langid 
| int 
| `quest::say($langid); # returns int` 

#### Example

- In this example, the NPC, if in combat, would say the names of everyone on its hate list, and include both the amount of damage the entity has done, as well as the amount of hate the entity has generated.

PerlLua

```
`sub EVENT_AGGRO_SAY {
 #:: Match "fight", case insensitive, if the NPC aggro
 if ($text=~/fight/i) {
 quest::say("I am fighting!");
 }
}
`
```

```
`function event_aggro_say(e)
 if (e.message:findi("fight")) then
 e.self:Say("I am fighting!");
 end
end
`
```

### EVENT_ATTACK

#### Trigger

- When the NPC is attacked.

Note the subtle difference from EVENT_AGGRO, which is triggered when the NPC is aggro'd (which could occur through bad faction, for instance).

#### Example

- In this example, the NPC will say "Time to die PlayerName." when the NPC is attacked by the player.

PerlLua

```
`sub EVENT_ATTACK {
 quest::say("Time to die $name.");
}
`
```

```
`function event_attack(e)
 e.self:Say("Time to die!");
end
`
```

### EVENT_AUGMENT_ITEM

#### Trigger

- When a client augments an item.

You would likely use this event in your global player.pl file.

#### Example

- In this example, a message in yellow text is displayed to the client when the player adds an augment to an item.

PerlLua

```
`sub EVENT_AUGMENT_ITEM{
 $client->Message(15, "Yay, it fit!");
}
`
```

```
`function event_augment_item(e)
 e.owner:Message(15, "Yay, it fit!");
end
`
```

### EVENT_AUGMENT_INSERT

#### Trigger

- When a client inserts an augment into an item.

You would likely use this event in your global player.pl file.

#### Example

- In this example, a message in yellow text is displayed to the client when the player puts the augment into the augment slot of an item.

PerlLua

```
`sub EVENT_AUGMENT_INSERT {
 $client->Message(15, "Yay, it fit!");
}
`
```

```
`function event_augment_insert(e)
 e.owner:Message(15, "Yay, it fit!");
end
`
```

### EVENT_AUGMENT_REMOVE

#### Trigger

- When a client removes an augment from an item. You would likely use this event in your global player.pl file.

#### Example

- In this example, a message in yellow text is displayed to the client when the player removes an augment from an item.

PerlLua

```
`sub EVENT_AUGMENT_REMOVE {
 $client->Message(15, "Yay, you pulled it out!");
}
`
```

```
`function event_augment_remove(e)
 e.owner:Message(15, "Yay, you pulled it out!");
end
`
```

### EVENT_BOT_COMMAND

#### Trigger

- When a player says anything with the **^** command token preceding it that isn't handled by a system bot command.

- Exception: `^help` will invoke a special call so that scripted bot commands may be included in search listing.

Used in player files to handle script-based bot command processing.

#### Exports

| 

Name 
| Type 
| Details 

| bot_command 
| string 
| A single, de-tokenized bot command name 

| args (perl) 
| string 
| An unseparated text line of additional parameters 

| args (lua) 
| string array 
| An array of single-word text parameters 

#### Example

- These examples are a working template for adding your own bot commands.

Note: The scripting apis do not fully support the Bot object and scripting options will be limited.

PerlLua

```
`sub EVENT_BOT_COMMAND {

 my %bot_command_data = (
 "scriptbotcommand1" => [0, "perl script-based supplementation test bot command 1"],
 "scriptbotcommand2" => [100, "perl script-based supplementation test bot command 2"],
 "scriptbotcommand3" => [250, "perl script-based supplementation test bot command 3"]
 );

 if ($bot_command eq "help" || $bot_command eq "?") { # always a supplemental call from within the system bot_command_help handler
 my $available_bot_commands = 0;

 foreach my $bot_command_name (sort {$a cmp $b} keys %bot_command_data) {
 if ($status >= $bot_command_data{$bot_command_name}[0] && ($args eq "0" || $bot_command_name=~/$args/i)) {
 $client->Message(15, "^$bot_command_name - $bot_command_data{$bot_command_name}[1]");
 $available_bot_commands = $available_bot_commands + 1;
 }
 }

 return $available_bot_commands;
 }
 elsif (exists($bot_command_data{$bot_command}) && $status >= $bot_command_data{$bot_command}[0]) {
 if ($bot_command eq "scriptbotcommand1") {
 $client->Message(14, "doing '$bot_command'...");
 return 1;
 }
 elsif ($bot_command eq "scriptbotcommand2") {
 $client->Message(14, "doing '$bot_command'...");
 return 1;
 }
 elsif ($bot_command eq "scriptbotcommand3") {
 $client->Message(14, "doing '$bot_command'...");
 return 1;
 }
 }

 return 0;
}
`
```

```
`function event_bot_command(e)

 local bot_command_data = {
 ["scriptbotcommand1"] = {0, "lua script-based supplementation test bot command 1"},
 ["scriptbotcommand2"] = {100, "lua script-based supplementation test bot command 2"},
 ["scriptbotcommand3"] = {250, "lua script-based supplementation test bot command 3"}
 }

 if (e.bot_command == "help" or e.bot_command == "?") then -- always a supplemental call from within the system bot_command_help handler
 local available_bot_commands = 0;

 local key_sort = {}
 for key in pairs(bot_command_data) do
 table.insert(key_sort, key);
 end
 table.sort(key_sort);

 for index, key in ipairs(key_sort) do
 if (e.self:Admin() >= bot_command_data[key][1] and (e.args[1] == nil or key:findi(e.args[1]))) then
 e.self:Message(15, "^" .. key .. " - " .. bot_command_data[key][2]);
 available_bot_commands = available_bot_commands + 1;
 end
 end

 return available_bot_commands;
 elseif (bot_command_data[e.bot_command] ~= nil and e.self:Admin() >= bot_command_data[e.bot_command][1]) then
 if (e.bot_command == "scriptbotcommand1") then
 e.self:Message(14, "doing '" .. e.bot_command .. "'...");
 return 1;
 elseif (e.bot_command == "scriptbotcommand2") then
 e.self:Message(14, "doing '" .. e.bot_command .. "'...");
 return 1;
 elseif (e.bot_command == "scriptbotcommand3") then
 e.self:Message(14, "doing '" .. e.bot_command .. "'...");
 return 1;
 end
 end

 return 0;
end
`
```

### EVENT_CAST

#### Trigger

- When a client casts a spell.

#### Exports

| 

Name 
| Type 
| Usage 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

#### Example

- In this example, the player would emote upon a successful cast.

PerlLua

```
`sub EVENT_CAST {
 quest::me("regains his concentration and casts his spell.");
}
`
```

```
`function event_cast(e)
 e.self:Emote("regains his concentration and casts his spell.");
end
`
```

### EVENT_CAST_BEGIN

#### Trigger

- When a client begins to cast a spell.

#### Exports

| 

Name 
| Type 
| Usage 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

#### Example

- In this example, the player would emote if they begin casting the gate spell. You would likely place this particular snippet into your global player.pl file.

PerlLua

```
`sub EVENT_CAST_BEGIN {
 #:: Match if $spell_id is 36 - Gate
 if ($spell_id == 36) {
 quest::me("begins casting the Gate spell.");
 }
}
`
```

```
`function event_cast_begin(e)
 --:: Match if spell_id is 36 - Hate
 local spell_id = e.spell:GetID();
 if (spell_id == 36) then
 e.self:Emote("begins casting the Gate spell.");
 end
end
`
```

### EVENT_CAST_ON

#### Trigger

- When a player casts a spell on a player or NPC.

#### Exports

| 

Name 
| Type 
| Usage 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

#### Example

- In this example, if the player casts Banish Summoned on an NPC with a Summoned body type, the NPC will be killed. If you were placing this snippet in an NPC's quest script, you likely wouldn't bother matching body type.

PerlLua

```
`sub EVENT_CAST_ON {
 #:: Match if $spell_id is 116 - Banish Summoned
 if ($spell_id == 116) {
 #:: Match if the NPC's body type is 28 - Summoned Creature
 if ($mob->GetBodyType() == 28) {
 $npc->Kill();
 } 
 else {
 $client->Message(13, "This spell only effects summoned creatures");
 }
 }
}
`
```

```
`function event_cast_on(e)
 --:: Match if spell_id is 116 - Banish Summoned
 local spell_id = e.spell:GetID();
 if (spell_id == 116) then
 --:: Match if the NPC's body type is 28 - Summoned Creature
 local body_type = e.self:GetBodyType();
 if (body_type == 28) then
 e.self:Kill();
 else
 if (e.self:IsClient()) then
 e.self:Message(13, "This spell only effects summoned creatures.");
 end
 end
 end
end
`
```

### EVENT_CLICKDOOR

#### Trigger

- When the client clicks on a door object.

Note that you would likely use this event in the zone player.pl file. Since doors have open types and destination fields stored in the database, most "simple" doors do not require a separate quest script. An example of a "simple" door would be any door that requires a single keyitem (by Item ID) to open, like the door to the basement in Befallen.

#### Exports

| 

Name 
| Type 
| Usage 

| doorid 
| int 
| `quest::say($doorid); # returns int` 

| version 
| int 
| `quest::say($version); # returns int` 

#### Example

- In this example, a player who is part of a Deepest Guk Adventure would be teleported to Deepest Guk when they click the doorway found in the Hollow Log.

PerlLua

```
`sub EVENT_CLICKDOOR {
 #:: Match if doorID is 1 - the door found in the Hollow Log that leads to Deepest Guk Adventures
 if ($doorid == 1) {
 #:: Create a variable to store the player's adventure zone instance ID
 $GukAInstance = quest::GetInstanceID("guka",50);
 #:: Match if the player has an instance
 if ($GukAInstance > 0) {
 #:: Teleport the player to their instance in Deepest Guk at the safe spot
 quest::MovePCInstance(229, $GukAInstance, 101, -841, 2.38);
 } 
 else {
 $client->Message(13, "You are not a part of a Deepest Guk adventure instance!");
 }
 }
}
`
```

```
`function event_click_door(e) 
 --:: Match if doorID is 1 - the door found in the Hollow Log that leads to Deepest Guk Adventures
 local door_id = e.door:GetDoorID();
 if (door_id == 1) then
 --:: Create a variable to store the player's adventure zone instance ID
 local guka_instance = eq.get_instance_id("guka", 50);
 --:: Match if the player has an instance
 if (guka_instance > 0) then
 --:: Teleport the player to their instance in Deepest Guk at the safe spot
 e.self:MovePCInstance(229, guka_instance, 101, -841, 2.38);
 else
 e.self:Message(13, "You are not a part of a Deepest Guk adventure instance!");
 end
 end
end
`
```

### EVENT_CLICK_OBJECT

#### Trigger

- When the client clicks on an object.

Note the similarity between this event and Perl EVENT_CLICKDOOR, since it is easy to confuse a door object (like a Plane of Knowledge Book) with Objects (IE Pottery wheels, Brew Barrels, etc.). You would likely use this event in the zone player.pl (or global_player.pl) files.

#### Exports

| 

Name 
| Type 
| Usage 

| objectid 
| int 
| `quest::say($objectid); # returns int` 

| clicker_id 
| int 
| `quest::say($clicker_id); # returns int` 

#### Example

- In this example, a message is displayed to a player when they open the Ogre Cultural Forge in Oggok.

PerlLua

```
`sub EVENT_CLICK_OBJECT {
 #:: Match to the ogre cultural forge in Oggok by object ID
 if ($objectid == 1075) {
 #:: Check to see if the player who clicked is a race other than Ogre
 if ($race ne "Ogre") {
 #:: Send the client a message in color 1 (gray)
 $client->Message(1,"The foul stench of Ogre overwhelms you as you open the forge.");
 } else {
 $client->Message(1,"Mmmm--dis smells just like home.");
 }
 }
}
`
```

```
`function event_click_object(e) 
 --:: Match to the ogre cultural forge in Oggok by object ID
 local object_id = e.object:GetID();
 if (object_id == 1075) then
 --:: Check to see if the player who clicked is a race other than Ogre
 local race_id = e.self:GetRace();
 if (race_id != 10) then
 --:: Send the client a message in color 1 (gray)
 e.self:Message(1,"The foul stench of Ogre overwhelms you as you open the forge.");
 else
 e.self:Message(1,"Mmmm--dis smells just like home.");
 end
 end
end
`
```

### EVENT_COMBAT

#### Trigger

- When an NPC enters or leaves combat.

#### Exports

| 

Name 
| Type 
| Usage 

| combat_state 
| int 
| `quest::say($combat_state); # returns int` 

#### Example

- In this example, the NPC will say some flavor text when entering combat.

PerlLua

```
`sub EVENT_COMBAT {
 #:: combat state 0 = False, 1 = True
 if ($combat_state == 1) {
 quest::say("Time to die!");
 }
}
`
```

```
`function event_combat(e)
 --:: e.joined is true/false
 if (e.joined) then
 e.self:Say("Time to die!");
 end
end
`
```

### EVENT_COMBINE_FAILURE

#### Trigger

- When a combine is unsuccessful. You would likely use this event in your global / player.pl file.

#### Exports

| 

Name 
| Type 
| Usage 

| recipe_id 
| int 
| `quest::say($recipe_id); # returns int` 

| recipe_name 
| int 
| `quest::say($recipe_name); # returns int` 

#### Example

- In this example, we watch for a player failing the combine for a Hand Made Backpack and then tease them.

PerlLua

```
`sub EVENT_COMBINE_FAILURE {
 #:: Match Recipe 2686: "Hand Made Backpack" by ID
 if ($recipe_id == 2686) {
 #:: Send the client a message in color 15 (yellow)
 $client->Message(15,"Awww...now where are you going to put all of your stuff?");
 }
}
`
```

```
`function event_combine_failure(e)
 --:: Match Recipe 2686: "Hand Made Backpack" by ID
 if (e.recipe_id == 2686) then
 --:: Send the client a message in color 15 (yellow)
 e.self:Message(15, "Awww...now where are you going to put all of your stuff?");
 end
end
`
```

### EVENT_COMBINE_SUCCESS

#### Trigger

- When a combine is successful.

#### Exports

| 

Name 
| Type 
| Usage 

| recipe_id 
| int 
| `quest::say($recipe_id); # returns int` 

| recipe_name 
| int 
| `quest::say($recipe_name); # returns int` 

#### Example

- In this example, we send the client a message when they successfully combine a Hand Made Backpack

PerlLua

```
`sub EVENT_COMBINE_SUCCESS {
 #:: Match Recipe 2686: "Hand Made Backpack" by ID
 if ($recipe_id == 2686) {
 #:: Send the client a message in color 15 (yellow)
 $client->Message(15,"Yay, now you have a place to put all of your stuff!");
 }
}
`
```

```
`function event_combine_success(e)
 --:: Match Recipe 2686: "Hand Made Backpack" by ID
 if (e.recipe_id == 2686) then
 --:: Send the client a message in color 15 (yellow)
 e.self:Message(15, "Yay, now you have a place to put all of your stuff!");
 end
end
`
```

### EVENT_COMMAND

#### Trigger

- When a player says anything with the **#** command token preceding it that isn't handled by a system command.

- Exception: `#help` will invoke a special call so that scripted commands may be included in search listing.

Used in player files to handle script-based command processing.

#### Exports

| 

Name 
| Type 
| Details 

| command 
| string 
| A single, de-tokenized command name 

| args (perl) 
| string 
| An unseparated text line of additional parameters 

| args (lua) 
| string array 
| An array of single-word text parameters 

#### Example

- These examples are a working template for adding your own commands.

PerlLua

```
`sub EVENT_COMMAND {

 my %command_data = (
 "scriptcommand1" => [0, "perl script-based supplementation test command 1"],
 "scriptcommand2" => [100, "perl script-based supplementation test command 2"],
 "scriptcommand3" => [250, "perl script-based supplementation test command 3"]
 );

 if ($command eq "help") { # always a supplemental call from within the system command_help handler
 my $available_commands = 0;

 foreach my $command_name (sort {$a cmp $b} keys %command_data) {
 if ($status >= $command_data{$command_name}[0] && ($args eq "0" || $command_name=~/$args/i)) {
 $client->Message(15, "#$command_name - $command_data{$command_name}[1]");
 $available_commands = $available_commands + 1;
 }
 }

 return $available_commands;
 }
 elsif (exists($command_data{$command}) && $status >= $command_data{$command}[0]) {
 if ($command eq "scriptcommand1") {
 $client->Message(14, "doing '$command'...");
 return 1;
 }
 elsif ($command eq "scriptcommand2") {
 $client->Message(14, "doing '$command'...");
 return 1;
 }
 elsif ($command eq "scriptcommand3") {
 $client->Message(14, "doing '$command'...");
 return 1;
 }
 }

 return 0;
}
`
```

```
`function event_command(e)

 local command_data = {
 ["scriptcommand1"] = {0, "lua script-based supplementation test command 1"},
 ["scriptcommand2"] = {100, "lua script-based supplementation test command 2"},
 ["scriptcommand3"] = {250, "lua script-based supplementation test command 3"}
 }

 if (e.command == "help") then -- always a supplemental call from within the system command_help handler
 local available_commands = 0;

 local key_sort = {}
 for key in pairs(command_data) do
 table.insert(key_sort, key);
 end
 table.sort(key_sort);

 for index, key in ipairs(key_sort) do
 if (e.self:Admin() >= command_data[key][1] and (e.args[1] == nil or key:findi(e.args[1]))) then
 e.self:Message(15, "#" .. key .. " - " .. command_data[key][2]);
 available_commands = available_commands + 1;
 end
 end

 return available_commands;
 elseif (command_data[e.command] ~= nil and e.self:Admin() >= command_data[e.command][1]) then
 if (e.command == "scriptcommand1") then
 e.self:Message(14, "doing '" .. e.command .. "'...");
 return 1;
 elseif (e.command == "scriptcommand2") then
 e.self:Message(14, "doing '" .. e.command .. "'...");
 return 1;
 elseif (e.command == "scriptcommand3") then
 e.self:Message(14, "doing '" .. e.command .. "'...");
 return 1;
 end
 end

 return eq.DispatchCommands(e); -- needed to invoke lua-based command system
end
`
```

### EVENT_CONNECT

#### Trigger

- when a player connects to the world.

You would likely be using this event in your global_player.pl.

#### Example

- In this example, veteran AAs are awarded based on accumulated play time.

PerlLua

```
`sub EVENT_CONNECT {
 my %vet_aa = (481 => [31536000, 1, 1],
 482 => [63072000, 1, 1],
 483 => [94608000, 1, 1],
 484 => [126144000, 1, 1],
 485 => [157680000, 1, 1],
 486 => [189216000, 1, 1],
 487 => [220752000, 1, 1],
 511 => [252288000, 1, 1],
 2000 => [283824000, 1, 1],
 8081 => [315360000, 1, 1],
 8130 => [346896000, 1, 1],
 453 => [378432000, 1, 1],
 182 => [409968000, 1, 1],
 600 => [441504000, 1, 1]);
 foreach my $key (keys %vet_aa) {
 if ($vet_aa{$key}[2] && ($vet_aa{$key}[2] || $client->GetAccountAge() >= $vet_aa{$key}[0])) {
 $client->GrantAlternateAdvancementAbility($key, 1);
 }
 }
}
`
```

```
`--[[ the main key is the ID of the AA
-- the first set is the age required in seconds
-- the second is if to ignore the age and grant anyways live test server style
-- the third is enabled
--]]
vet_aa = {
 [481] = { 31536000, true, true}, -- Lesson of the Devote 1 yr
 [482] = { 63072000, true, true}, -- Infusion of the Faithful 2 yr
 [483] = { 94608000, true, true}, -- Chaotic Jester 3 yr
 [484] = {126144000, true, true}, -- Expedient Recovery 4 yr
 [485] = {157680000, true, true}, -- Steadfast Servant 5 yr
 [486] = {189216000, true, true}, -- Staunch Recovery 6 yr
 [487] = {220752000, true, true}, -- Intensity of the Resolute 7 yr
 [511] = {252288000, true, true}, -- Throne of Heroes 8 yr
 [2000] = {283824000, true, true}, -- Armor of Experience 9 yr
 [8081] = {315360000, true, true}, -- Summon Resupply Agent 10 yr
 [8130] = {346896000, true, true}, -- Summon Clockwork Banker 11 yr
 [453] = {378432000, true, true}, -- Summon Permutation Peddler 12 yr
 [182] = {409968000, true, true}, -- Summon Personal Tribute Master 13 yr
 [600] = {441504000, true, true}, -- Blessing of the Devoted 14 yr
}

function event_connect(e)
 local age = e.self:GetAccountAge();
 for aa, v in pairs(vet_aa) do
 if v[3] and (v[2] or age >= v[1]) then
 e.self:GrantAlternateAdvancementAbility(aa, 1)
 end
 end
end
`
```

### EVENT_DEATH

#### Trigger

- When the NPC dies. Fires before death finishes.

#### Exports

| 

Name 
| Type 
| Details 

| client 
| client 
| client who killed mob 

| npc 
| npc 
| npc that was killed 

| killer_id 
| int 
| client ID of killer. (Does not seem castable to mob) 

| killer_damage 
| int 
| How much damage was dealt on killing blow 

| killer_spell 
| int 
| Spell ID used to kill mob 

| killer_skill 
| int 
| Skill ID used to kill mob 

| charid 
| int 
| Character ID who killed mob 

| class 
| string 
| Class Name who killed mob 

| faction 
| int 
| Faction comparison of killed mob vs killer 

| h 
| float 
| heading of mob during death 

| hpratio 
| float 
| percent health of mob after death (negative value) 

| mlevel 
| int 
| level of mob killed 

| mname 
| string 
| name of mob killed 

| mobid 
| int 
| id of mob killed 

| name 
| string 
| name of killer 

| race 
| string 
| race of killer 

| status 
| int 
| account status of killer 

| uguild_id 
| int 
| uguild of killer 

| ulevel 
| int 
| level of killer 

| userid 
| int 
| user id of killer 

| x 
| float 
| x position of killed mob 

| y 
| float 
| y position of killed mob 

| z 
| float 
| z position of killed mob 

| zonehour 
| int 
| hour of zone when mob died 

| zoneid 
| int 
| zone id where mob died 

| zoneln 
| string 
| long name of zone where mob died 

| zonemin 
| int 
| minimum level to enter zone where mob died 

| zonesn 
| string 
| short name of zone where mob died 

| zonetime 
| int 
| time of zone where mob died 

| zoneweather 
| int 
| 

### EVENT_DEATH_COMPLETE

#### Trigger

- When the NPC dies.

Often used to spawn adds or send signals upon the death of an NPC.

#### Exports

| 

Name 
| Type 
| Usage 

| killer_id 
| int 
| `quest::say($killer_id); # returns int` 

| killer_damage 
| int 
| `quest::say($killer_damage); # returns int` 

| killer_spell 
| int 
| `quest::say($killer_spell); # returns int` 

| killer_skill 
| int 
| `quest::say($killer_skill); # returns int` 

#### Example

- In this example, we spawn a fire beetle after the death of our NPC at the NPC's location.

PerlLua

```
`sub EVENT_DEATH_COMPLETE {
 #:: Spawn a 2024 - a_fire_beetle by NPC Type ID, grid 0, guildwarset 0, current X, Y, Z, and heading
 quest::spawn2(2024,0,0,$x,$y,$z,$h);
}
`
```

```
`function event_death_complete(e)
 --:: Spawn a 2024 - a_fire_beetle by NPC Type ID, grid 0, guildwarset 0, current X, Y, Z, and heading
 eq.spawn2(2024, 0, 0, e.self:GetX(), e.self:GetY(), e.self:GetZ(), e.self:GetHeading());
end
`
```

### EVENT_DEATH_ZONE

#### Trigger

- When the NPC dies.

**Used by the zone controller.**

#### Exports

| 

Name 
| Type 
| Usage 

| killer_id 
| int 
| `quest::say($killer_id); # returns int` 

| killer_damage 
| int 
| `quest::say($killer_damage); # returns int` 

| killer_spell 
| int 
| `quest::say($killer_spell); # returns int` 

| killer_skill 
| int 
| `quest::say($killer_skill); # returns int` 

| killer_npc_id 
| int 
| `quest::say($killer_npc_id); # returns int` 

### EVENT_DESTROY_ITEM

#### Trigger

- When a client destroys an item.

Used mainly for logging purposes.

### EVENT_DISCONNECT

#### Trigger

- When a player disconnects from the world.

Used mainly for logging purposes.

### EVENT_DISCOVER_ITEM

#### Trigger

- When an item is discovered.

Used in conjunction with World Rule EnableDiscoveredItems.

#### Exports

| 

Name 
| Type 
| Usage 

| itemid 
| int 
| `quest::say($itemid); # returns int` 

#### Example

PerlLua

```
`sub EVENT_DISCOVER_ITEM {
 #:: Create a scalar variable to store the item link
 $discovereditem = quest::varlink($itemid);
 #:: Shout the discovery to all zones
 quest::shout2("$name has discovered $discovereditem! Yay!");
}
`
```

```
`function event_discover_item(e) 
 --:: Create a scalar variable to store the item link
 local item_link = eq.item_link(e.item:GetID());
 --:: Emote the discovery to all zones
 eq.world_emote(335, "$name has discovered " .. item_link .. "! Yay!");
end
`
```

### EVENT_DROP_ITEM

#### Trigger

- When a client drops an item.

Mainly used for logging purposes.

#### Exports

| 

Name 
| Type 
| Usage 

| quantity 
| int 
| `quest::say($quantity); # returns int` 

| itemname 
| int 
| `quest::say($itemname); # returns int` 

| itemid 
| int 
| `quest::say($itemid); # returns int` 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

| slotid 
| int 
| `quest::say($slotid); # returns int` 

### EVENT_DUEL_LOSE

#### Trigger

- When a client loses a duel.

You would use this event in the global global_player.pl file.

#### Example

- In this example, we set a data bucket to keep track of a player's dueling failures.

PerlLua

```
`sub EVENT_DUEL_LOSE {
 my $bucket_name = $client->CharacterID() . "-losses";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
}
`
```

```
`function event_duel_lose(e)
 local bucket_name = e.self:CharacterID() .. "-losses";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
end
`
```

### EVENT_DUEL_WIN

#### Trigger

- when a client wins a duel.

You would use this event in the global global_player.pl file.

#### Example

- In this example, we set a data bucket to keep track of a player's dueling wins.

PerlLua

```
`sub EVENT_DUEL_WIN {
 my $bucket_name = $client->CharacterID() . "-wins";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
}
`
```

```
`function event_duel_win(e)
 local bucket_name = e.self:CharacterID() .. "-wins";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
end
`
```

### EVENT_ENTER

#### Trigger

- When a client enters a mob's proximity (as defined by quest::set_proximity(min_x, max_x, min_y, max_y, min_z, max_z)).

#### Example

- In this example, we first set the NPC's proximity; when a player enters the proximity, they become PVP (red).

PerlLua

```
`sub EVENT_SPAWN {
 #:: Create a proximity, 100 units across, 100 units tall, without proximity say
 quest::set_proximity($x - 50, $x + 50, $y - 50, $y + 50, $z - 50, $z + 50, 0);
}

sub EVENT_ENTER {
 #:: Turn pvp on
 quest::pvp("on");
}
`
```

```
`function event_spawn(e)
 --:: Create a proximity, 100 units across, 100 units tall, without proximity say
 local x = e.self:GetX();
 local y = e.self:GetY();
 local z = e.self:GetZ();
 eq.set_proximity((x - 50), (x + 50), (y - 50), (y + 50), (z - 50), (z + 50), 0); 
end

function event_enter(e)
 --:: Turn pvp on
 e.other:SetPVP("on");
end
`
```

### EVENT_ENTER_AREA

#### Trigger

- when a client enters the area of a mob.

### EVENT_ENTERZONE

#### Trigger

- When a player enters the zone. Likely you will add to the zone player.pl file.

#### Example

- In this example we remove the LDON compass mark.

PerlLua

```
`sub EVENT_ENTERZONE {
 #:: Clear the LDON Compass mark
 $client->ClearCompassMark();
}
`
```

```
`function event_enterzone(e)
 --:: Clear the LDON Compass mark
 e.self:ClearCompassMark();
end
`
```

- In this example we create a LDON compass mark

PerlLua

```
`sub EVENT_ENTERZONE {
 #:: Create a scalar for storing the instance ID
 $RujDInstance = quest::GetInstanceID("rujd",50);
 #:: If the instance ID exists, it should be greater than 0--mark the player's compass if it is
 if ($RujDInstance > 0) {
 #:: Create a line on the compass leading the player to X,Y,Z
 $client->MarkCompassLoc(-157.09, 19.31, 100);
 }
}
`
```

```
`function event_enterzone(e)
 --:: Create a variable for storing the instance ID
 local rujd_instance = eq.get_instance_id("rujd", 50);
 --:: If the instance ID exists, it should be greater than 0--mark the player's compass if it is
 if (rujd_instance > 0) then
 --:: Create a line on the compass leading the player to X,Y,Z
 e.self:MarkCompassLoc(-157.09, 19.31, 100);
 end 
end
`
```

### EVENT_ENVIRONMENTAL_DAMAGE

#### Trigger

- When taking any sort of environmental damage.

#### Exports

| 

Name 
| Type 
| Usage 

| env_damage 
| int 
| `quest::say($env_damage); # returns int` 

| env_damage_type 
| int 
| `quest::say($env_damage_type); # returns int` 

| env_final_damage 
| int 
| `quest::say($env_final_damage); # returns int` 

### EVENT_EQUIP_ITEM

#### Trigger

- When a player equips an item.

### EVENT_EXIT

#### Trigger

- When a client leaves a mob's proximity (as defined by quest::set_proximity).

#### Example

- In this example, we first set the NPC's proximity; when a player exits the proximity, they are no longer PVP (blue).

#### Example

PerlLua

```
`sub EVENT_SPAWN {
 #:: Create a proximity, 100 units across, 100 units tall, without proximity say
 quest::set_proximity($x - 50, $x + 50, $y - 50, $y + 50, $z - 50, $z + 50, 0);
}

sub EVENT_EXIT {
 #:: Turn pvp off
 quest::pvp("off");
}
`
```

```
`function event_spawn(e)
 --:: Create a proximity, 100 units across, 100 units tall, without proximity say
 local x = e.self:GetX();
 local y = e.self:GetY();
 local z = e.self:GetZ();
 eq.set_proximity((x - 50), (x + 50), (y - 50), (y + 50), (z - 50), (z + 50), 0); 
end

function event_exit(e)
 --:: Turn pvp off
 e.other:SetPVP("off");
end
`
```

### EVENT_FEIGN_DEATH

#### Trigger

- When a client feigns death.

#### Example

PerlLua

```
`sub EVENT_FEIGN_DEATH {
 #:: See if the player has a pet
 if ($client->GetPetID()) {
 #:: Identify the pet by ID and kill it
 $pet_entity = $entity_list->GetMobByID($client->GetPetID());
 $pet_entity->Kill();
 }
}
`
```

```
`function event_feign_death(e)
 --:: See if the player has a pet
 local pet_id = e.other:GetPet():GetID();
 if (pet_id > 0) then
 --:: Identify the pet by ID and kill it
 local pet_entity = entity_list:GetMob(pet_id);
 pet_entity:Kill();
 end
end
`
```

### EVENT_FISH_FAILURE

#### Trigger

- When a client fails at fishing.

You would use this event in the zone player.pl file.

#### Example

- In this example, we set a data bucket to keep track of a player's fishing failures.

- You would use this event in the global global_player.pl file.

PerlLua

```
`sub EVENT_FISH_FAILURE {
 my $bucket_name = $client->CharacterID() . "-fish-fail";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
 $client->Message(1, "Maybe you're using the wrong bait!")
}
`
```

```
`function event_fish_failure(e)
 local bucket_name = e.self:CharacterID() .. "-fish-fail";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
 e.self:Message(1, "Maybe you're using the wrong bait!");
end
`
```

### EVENT_FISH_START

#### Trigger

- when a client starts fishing.

You would use this event in the zone player.pl file.

#### Example

- In this example, a message is displayed by the client if they start fishing.

PerlLua

```
`sub EVENT_FISH_START {
 $client->Message(1, "You crack a beer and toss your line in.");
}
`
```

```
`function event_fish_start(e)
 e.self:Message(1, "You crack a beer and toss your line in.");
end
`
```

### EVENT_FISH_SUCCESS

#### Trigger

- when a client succeeds at fishing.

You would use this event in the zone player.pl file or the global global_player.pl file.

#### Exports

| 

Name 
| Type 
| Usage 

| fished_item 
| int 
| `quest::say($fished_item); # returns int` 

#### Example

- In this example, we set a data bucket to keep track of a player's fishing successes.

- You would use this event in the global global_player.pl file.

PerlLua

```
`sub EVENT_FISH_SUCCESS {
 my $bucket_name = $client->CharacterID() . "-fish-success";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
}
`
```

```
`function event_fish_success(e)
 local bucket_name = e.self:CharacterID() .. "-fish-success";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
 e.self:Message(1, "You caught something!");
end
`
```

### EVENT_FORAGE_FAILURE

#### Trigger

- When a client fails at foraging.

You would use this event in the zone player.pl or global global_player.pl file.

#### Example

- In this example, we set a data bucket to keep track of a player's foraging failures.

PerlLua

```
`sub EVENT_FORAGE_FAILURE {
 my $bucket_name = $client->CharacterID() . "-forage-fail";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
 $client->Message(1, "You didn't find anything!")
}
`
```

```
`function event_forage_failure(e)
 local bucket_name = e.self:CharacterID() .. "-forage-fail";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
 e.self:Message(1, "You didn't find anything!");
end
`
```

### EVENT_FORAGE_SUCCESS

#### Trigger

- when a client succeeds at foraging.

You would use this event in the zone player.pl file or the global global_player.pl file.

#### Exports

| 

Name 
| Type 
| Usage 

| foraged_item 
| int 
| `quest::say($foraged_item); # returns int` 

#### Example

- In this example, we set a data bucket to keep track of a player's foraging successes.

PerlLua

```
`sub EVENT_FORAGE_SUCCESS {
 my $bucket_name = $client->CharacterID() . "-forage-success";
 my $bucket_value = (quest::get_data($bucket_name) + 1);
 quest::set_data($bucket_name, $bucket_value);
 $client->Message(1, "You found something!")
}
`
```

```
`function event_forage_success(e)
 local bucket_name = e.self:CharacterID() .. "-forage-success";
 local bucket_value = (eq.get_data(bucket_name) + 1);
 eq.set_data(bucket_name, bucket_value);
 e.self:Message(1, "You found something!");
end
`
```

### EVENT_GROUP_CHANGE

#### Trigger

- when a group change occurs.

### EVENT_HATE_LIST

#### Trigger

- When a mob's hate list is changed.

#### Exports

| 

Name 
| Type 
| Usage 

| hate_state 
| int 
| `quest::say($hate_state); # returns int` 

#### Example

In this example, some flavor text is added as a player is added and removed from the NPC's hate list.

PerlLua

```
`sub EVENT_HATE_LIST {
 if ($hate_state == 1) {
 quest::say("You're gonna die!");
 } else {
 quest::say("You're no match for my might!");
 }
}
`
```

```
`function event_hate_list(e)
 if (e.joined) then
 e.self:Say("You're gonna die!");
 else
 e.self:Say("You're no match for my might!");
 end
end
`
```

### EVENT_HP

#### Trigger

- When a mob's HP dropping below a threshold (as defined by quest::setnexthpevent()).

#### Exports

| 

Name 
| Type 
| Usage 

| hpevent 
| int 
| `quest::say($hpevent); # returns int` 

| inchpevent 
| int 
| `quest::say($inchpevent); # returns int--incoming HP event` 

#### Example

- In this example, we set the HP event threshold, and then depop the mob when the threshold is reached.

PerlLua

```
`sub EVENT_SPAWN {
 #:: Set the HP event threshold for 50 percent health
 quest::setnexthpevent(50);
}

sub EVENT_HP {
 #:: Match when the threshold is met
 if ($hpevent == 50) {
 quest::depop();
 }
}
`
```

```
`function event_spawn(e)
 --:: Set the HP event threshold for 50 percent health
 eq.set_next_hp_event(50);
end

function event_hp(e)
 --:: Match when the threshold is met
 if (e.hp_event == 50) then
 e.self:Depop();
 end
end
`
```

### EVENT_ITEM

#### Trigger

- When an item or money is turned into the mob.

#### Example

- In this example, we turn in 325 Platinum, a Ring of the Ancients, and a Shadowed Rapier in exchange for our Journeyman's Boots

PerlLua

```
`sub EVENT_ITEM {
 #:: Try to take 325 Platinum from the client
 if ($client->TakeMoneyFromPP(325000, 1)) {
 #:: Match turn for 12268 - Ring of the Ancients and 7100 - Shadowed Rapier
 if (plugin::check_handin(%itemcount, 12268 => 1, 7100 => 1)) {
 quest::say("The time to trade has come!! I am now rich and you are now fast. Take the Journeyman Boots and run like the wind.");
 #:: Give a 2300 - Journeyman's Boots
 quest::summonitem(2300);
 #:: Grant a small amount of experience
 quest::exp(1250);
 }
 }
 #:: Return unused items
 plugin::return_items(%itemcount);
}
`
```

```
`function event_trade(e)
 --:: Require items library.
 local item_lib = require("items");
 --:: Try to take 325 Platinum from the client
 if (e.other:TakeMoneyFromPP(325000, 1)) then
 --:: Match turn for 12268 - Ring of the Ancients and 7100 - Shadowed Rapier
 if (item_lib.check_turn_in(e.self, e.trade, {item1 = 12268, item2 = 7100})) then
 e.self:Say("The time to trade has come!! I am now rich and you are now fast. Take the Journeyman Boots and run like the wind.");
 --:: Give a 2300 - Journeyman's Boots
 e.other:SummonItem(2300);
 --:: Grant a small amount of experience
 e.other:AddEXP(1250);
 end
 end
 --:: Return unused items
 item_lib.return_items(e.self, e.other, e.trade);
end
`
```

### EVENT_ITEM_CLICK

#### Trigger

- When an item is clicked.

This is a useful script to put in the Global quest scripts directory, so that you can make an item click work anywhere in the world.

#### Exports

| 

Name 
| Type 
| Usage 

| itemid 
| int 
| `quest::say($itemid); # returns int` 

| itemname 
| int 
| `quest::say($itemname); # returns int` 

| slotid 
| int 
| `quest::say($slotid); # returns int` 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

#### Example

- This example is taken from the Evil Eye Costume Kit, which is part of the Halloween Costume illusion items.

- Note that the scriptfileid field for the item is set to 30073 in the database.

- Note that a corresponding quest file exists at global/items/script_30073.pl.

PerlLua

```
`sub EVENT_ITEM_CLICK {
 #:: Use == for numeric comparison to Item ID 54711 - Evil Eye Costume Kit
 if ($itemid == 54711) {
 #:: Change the player's race to 469 - Evil Eye
 quest::playerrace(469);
 } 
}
`
```

```
`function event_item_click(e)
 --:: Use == for numeric comparison to Item ID 54711 - Evil Eye Costume Kit
 local item_id = e.self:GetID();
 if (item_id == 54711) then
 --:: Change the player's race to 469 - Evil Eye
 e.owner:ChangeRace(469);
 end
end
`
```

### EVENT_ITEM_CLICK_CAST

#### Trigger

- When a client casts the click effect on an item.

#### Exports

| 

Name 
| Type 
| Usage 

| itemid 
| int 
| `quest::say($itemid); # returns int` 

| itemname 
| int 
| `quest::say($itemname); # returns int` 

| slotid 
| int 
| `quest::say($slotid); # returns int` 

| spell_id 
| int 
| `quest::say($spell_id); # returns int` 

### EVENT_ITEM_ENTER_ZONE

Called when an item that would trigger EVENT_SCALE_CALC is in the inventory when a player zones in.

### EVENT_ITEM_TICK

#### Trigger

- when the click effect of an item ticks.

### EVENT_KILLED_MERIT

#### Trigger

On NPC death and applies to the group that did the most damage to the NPC (IE the group that got XP for the kill, assuming there was XP; or the group that gets loot rights to the NPC, assuming that there was loot). Although not often used, this event gives you the opportunity to assign quest globals or data buckets (IE for character flags), or update tasks.

#### Example

PerlLua

```
`sub EVENT_KILLED_MERIT {
 #:: Get the name of the mob to use in the data bucket
 my $slain = $npc->GetCleanName();
 #:: Set the quest data bucket--this would apply to all group members
 my $bucket_name = $client->CharacterID() . "-Slain";
 quest::set_data($bucket_name, 1);
 #:: Display an emote message to each client in yellow to notify them that they received credit
 $client->Message(15, "You have received credit for killing $slain.");
}
`
```

```
`function event_killed_merit(e)
 --:: Get the name of the mob to use in the quest global
 local slain = e.self:GetCleanName();
 --:: Set the quest global--this would apply to all group members
 local bucket_name = e.other:CharacterID() .. "-Slain";
 eq.set_data(bucket_name, 1);
 --:: Display an emote message to each client in yellow to notify them that they received credit
 e.other:Message(15, "You have received credit for killing " .. slain .. "."); 
end
`
```

### EVENT_LEAVE_AREA

#### Trigger

- when a client leaves a mob's area.

### EVENT_LEVEL_UP

#### Trigger

- When the player gains a level.

PerlLua

```
`sub EVENT_LEVEL_UP {
 #:: Congratulate the player
 $client->Message(15, "Congratulations on level $ulevel!");
}
`
```

```
`function event_level_up(e)
 --:: Congratulate the player
 e.self:Message(15, "Congratulations on level " .. e.self:GetLevel() .. "!");
end
`
```

### EVENT_LOOT

#### Trigger

- when player successfully loots an item from a corpse.

#### Exports

| 

Name 
| Type 
| Usage 

| looted_id 
| int 
| `quest::say($looted_id); # returns int` 

| looted_charges 
| int 
| `quest::say($looted_charges); # returns int` 

| corpse 
| int 
| `quest::say($corpse); # returns int` 

#### Example

- This example uses the loot event to match a particular item and corpse.

Note that we use the NPC's name (Fippy_Darkpaw) and not the numeric corpse ID (IE 249) or full corpse name (IE Fippy_Darkpaw`s_corpse249).

PerlLua

```
`sub EVENT_LOOT {
 #:: Use == for numeric comparison to Item ID 60396 - Fippy's Paw
 #:: Use eq for string comparison to Fippy_Darkpaw's corpse
 if ($looted_id == 60396 && $corpse eq "Fippy_Darkpaw") {
 $client->Message(15, "The bloody stump of Fippy's paw--it's a lot smaller than you thought it would be.");
 }
}
`
```

```
`function event_loot(e)
 --:: Use == for numeric comparison to Item ID 60396 - Fippy's Paw
 local looted_id = e.self:GetID();
 local corpse_name = e.corpse:GetCleanName()
 if (looted_id == 60396 and corpse_name:findi("Fippy")) then
 e.owner:Message(15, "The bloody stump of Fippy's paw--it's a lot smaller than you thought it would be.");
 end
end
`
```

### EVENT_NPC_SLAY

#### Trigger

- When an NPC slays another NPC.

#### Exports

| 

Name 
| Type 
| Usage 

| killed 
| int 
| `quest::say($killed); # returns int NPCTypeID` 

#### Example

- In this example, we add some flavor text when the Exterminator kills the rats.

PerlLua

```
`sub EVENT_NPC_SLAY {
 quest::say("Another unworthy opponent. Never cross Mining Guild 628!!");
}
`
```

```
`function event_slay(e)
 e.self:Say("Another unworthy opponent. Never cross Mining Guild 628!!");
end
`
```

### EVENT_PLAYER_PICKUP

#### Trigger

- When a player picks up an object from the ground. You would likely use this event in your zone player.pl file.

#### Exports

| 

Name 
| Type 
| Usage 

| picked_up_id 
| int 
| `quest::say($picked_up_id); # returns int` 

| picked_up_entity_id 
| int 
| `quest::say($picked_up_entity_id); # returns int` 

#### Example

-- In this example, when the player picks up a Chalice of Conquest, a signal is sent to another NPC

PerlLua

```
`#:: Chalice of Conquest quest
sub EVENT_PLAYER_PICKUP {
 #:: Match 12274 - Chalice of Conquest, ground spawn created by #Captain_Klunga.pl
 if ($picked_up_id == 12274) {
 #:: Send a signal to Dagnor's Cauldron >> #Captain_Klunga (70072)
 quest::signalwith(70072, 1);
 }
}
`
```

```
`--:: Chalice of Conquest quest
function event_player_pickup(e)
 --:: Match 12274 - Chalice of Conquest, ground spawn created by #Captain_Klunga.pl
 local picked_up_id = e.item:GetID()
 if (picked_up_id == 12274) then
 --:: Send a signal to Dagnor's Cauldron >> #Captain_Klunga (70072)
 eq.signal(70072, 1);
 end
end
`
```

### EVENT_POPUPRESPONSE

#### Trigger

- When a player clicks a button on a popup.

Used with quest::popup.

#### Exports

| 

Name 
| Type 
| Usage 

| popupid 
| int 
| `quest::say($popupid); # returns int` 

#### Example

- a well-known example from the Guild Lobby portal pool.

PerlLua

```
`sub EVENT_POPUPRESPONSE {
 #:: Triggered by sub EVENT_ENTER: quest::popup('Teleport', 'Teleport to The Plane of Hate?', 666, 1, 0);
 if ($popupid == 666) {
 #:: Teleport the player to hateplaneb
 quest::movepc(186,-393,656,3);
 }
}
`
```

```
`function event_popup_response(e) 
 --:: Triggered by function event_enter: eq.popup('Teleport', 'Teleport to The Plane of Hate?', 666, 1, 0);
 if (e.popup_id == 666) then
 --:: Teleport the player to hateplaneb
 e.self:MovePC(186, -393, 656, 3);
 end
end
`
```

### EVENT_PROXIMITY_SAY

#### Trigger

- When the client enters a mob's proximity and uses the appropriate text trigger supplied beneath this event.

Note that you must enable quest::set_proximity().

#### Example

- In this example, we establish a proximity around the NPC and enable the NPC to listen for say messages in the proximity (IE without having the mob targeted, necessarily); we then match for a "hail" message and attack anyone foolish enough to say hello.

PerlLua

```
`sub EVENT_SPAWN {
 #:: Create a proximity, 100 units across, 100 units tall, enable proximity say
 quest::set_proximity($x - 50, $x + 50, $y - 50, $y + 50, $z - 50, $z + 50, 1);
 #:: Also, enable proximity say
 quest::enable_proximity_say();
}

sub EVENT_PROXIMITY_SAY {
 #:: Match say message for "hail", /i for case insensitive
 if ($text=~/hail/i) {
 quest::say("Hello, $name!");
 }
}
`
```

```
`function event_spawn(e)
 --:: Create a proximity, 100 units across, 100 units tall, enable proximity say
 local x = e.self:GetX();
 local y = e.self:GetY();
 local z = e.self:GetZ();
 eq.set_proximity((x - 50), (x + 50), (y - 50), (y + 50), (z - 50), (z + 50), 1); 
end

function event_proximity_say(e)
 --:: Match say message for "hail", case-insensitive
 if (e.message:findi("hail")) then
 e.self:Say("Hello, " .. e.other:GetCleanName() .. "!");
 end
end
`
```

### EVENT_RESPAWN

#### Trigger

- on respawn

#### Exports

| 

Name 
| Type 
| Usage 

| option 
| int 
| `quest::say($option); # returns int` 

| resurrect 
| int 
| `quest::say($resurrect); # returns int` 

### EVENT_SAY

#### Trigger

- when a mob is targeted and the player types something.

#### Exports

| 

Name 
| Type 
| Details 

| client 
| client 
| Client who did say event 

| npc 
| npc 
| Npc who is handling say event 

| charid 
| int 
| character id of who did say event 

| class 
| string 
| class of who did say event 

| data 
| int 
| unknown? 124078 

| faction 
| int 
| faction comparison of who did say and npc 

| h 
| float 
| heading position of npc 

| hpratio 
| float 
| hp ratio e.g. 100 

| instanceid 
| int 
| instance id of zone, typically 0 

| instanceversion 
| int 
| instance version of zone, typically 0 

| langid 
| int 
| language id, common is 0 

| mlevel 
| int 
| mob level of npc 

| mname 
| string 
| mob name of npc 

| mobid 
| int 
| mob entity id of npc 

| name 
| string 
| name of who did say event 

| race 
| string 
| race of who did say event 

| status 
| int 
| account status of who did say event 

| text 
| string 
| Text of who did say event 

| uguild_id 
| int 
| guild id of who did say event 

| uguildrank 
| int 
| guild rank of who did say event 

| ulevel 
| int 
| level of who did say event 

| userid 
| int 
| user id of who did say event 

| x 
| float 
| x position of npc 

| y 
| float 
| y position of npc 

| z 
| float 
| z position of npc 

| zonehour 
| int 
| hour of zone when mob died 

| zoneid 
| int 
| zone id where mob died 

| zoneln 
| string 
| long name of zone where mob died 

| zonemin 
| int 
| minimum level to enter zone where mob died 

| zonesn 
| string 
| short name of zone where mob died 

| zonetime 
| int 
| time of zone where mob died 

| zoneweather 
| int 
| weather of zone where mob died 

#### Example

- This example is a response to a "hail"

PerlLua

```
`sub EVENT_SAY {
 #:: Checks if the text is like "Hail", the "/i" is for case-insensitive.
 if ($text=~/Hail/i) {
 quest::say("Hello, $name!");
 }
}
`
```

```
`function event_say(e)
 --:: Checks if the text is like "Hail", case-insensitive
 if (e.message:findi("hail")) then
 e.self:Say("Hello, " .. e.other:GetCleanName() .. "!");
 end 
end
`
```

- This example additionally checks the language of the "hail", and will only respond to text in that language.

PerlLua

```
`sub EVENT_SAY {
 #:: Checks to see if the language is Thieves Cant (language ID 10)
 if ($langid == 10) {
 #:: Checks if the text is like "Hail", the "i" is for case-insensitive.
 if ($text=~/Hail/i) {
 # Respond, using the same language
 quest::say("Hello, $name!",10);
 }
 }
}
`
```

```
`function event_say(e)
 --:: Checks to see if the language is Thieves Cant (language ID 10)
 if (e.language == 10) then
 --:: Checks if the text is like "Hail", the "i" is for case-insensitive.
 if (e.message:findi("hail")) then
 --:: Respond, using the same language
 e.self:Say("Hello, $name!", 10);
 end
 end
end
`
```

### EVENT_SCALE_CALC

#### Trigger

- When an item is equipped to scale the item--probably should zone.

#### Exports

| 

Name 
| Type 
| Usage 

| itemid 
| int 
| `quest::say($itemid); # returns int` 

| itemname 
| int 
| `quest::say($itemname); # returns int` 

#### Example

- In this example, we scale a charm item: 40342 - Charm of Exotic Speech. We have a script global / items / 40342.pl

- The item has a charmfile and charmfileID assigned

PerlLua

```
`sub EVENT_SCALE_CALC {
 #:: Used for charms that scale with number of rare languages learned
 my $languages_mastered = 0;
 my $scale = 0;
 #:: Check each rare language: Old Erudian through Elder Dragon
 for (my $i = 11; $i <= 22; $i++) {
 #:: Check if the client has mastered the language
 if ($client->GetLanguageSkill($i) == 100) {
 $languages_mastered++;
 }
 }
 $scale = ($languages_mastered / 12);
 $questitem->SetScale($scale);
}
`
```

```
`function event_scale_calc(e)
 --:: Used for charms that scale with number of rare languages learned
 local languages_mastered = 0;
 local scale = 0;
 --:: Check each rare language: Old Erudian through Elder Dragon
 for i = 11, 22, 1 do
 --:: Check if the client has mastered the language
 if (e.owner:GetLanguageSkill(i) == 100) then
 languages_mastered = (languages_mastered + 1);
 end
 end
 scale = (languages_mastered / 12);
 e.self:SetScale(scale);
end
`
```

### EVENT_SIGNAL

#### Trigger

- Triggered using quest::signal(NPC_ID, wait_time) or quest::signalwith(NPC_ID,signal_ID,wait_time).

Generally a way to have one NPC cause another NPC to do something. Often used with "controller" NPCs that coordinate events.

#### Exports

| 

Name 
| Type 
| Usage 

| signal 
| int 
| `quest::say($signal); # returns int` 

#### Example

- This example increments a counter each time a signal with the appropriate ID is received.

PerlLua

```
`my $count = 0;

sub EVENT_SIGNAL {
 #:: Signal 1 is from the clockwork spiders being killed.
 if ($signal == 1) {
 $count++;
 if ($count == 1) {
 #:: Start a three minute timer to spawn targetable Manaetic Behemoth
 quest::settimer("wake", 180);
 }
 }
 #:: Signal 2 is from the clockwork spiders reaching Manaetic Behemoth.
 elsif ($signal == 2) {
 #:: Reset the count and make them start over.
 $count = 0;
 quest::stoptimer("wake");
 }
}

sub EVENT_TIMER {
 #:: This uses eq for a string comparison to match the timer "wake".
 #:: Check the count to make sure the clockwork spiders were killed and not just kited. 
 if ($timer eq "wake" && $count >= 12) {
 quest::stoptimer("wake");
 #:: Spawn the targetable version of Manaetic Behemoth in place
 quest::spawn2(206074,0,0,$x,$y,$z,0);
 #:: Depop the untargetable version of Manaetic Behemoth with respawn timer active.
 quest::depop_withtimer();
 }
}
`
```

```
`count = 0;

function event_signal(e)
 --:: Signal 1 is from the clockwork spiders being killed.
 if (e.signal == 1) then
 count = (count + 1);
 if (count == 1) then
 --:: Start a three minute timer to spawn targetable Manaetic Behemoth
 quest::set_timer("wake", 180);
 end
 --:: Signal 2 is from the clockwork spiders reaching Manaetic Behemoth.
 else if (e.signal == 2) then
 --:: Reset the count and make them start over.
 count = 0;
 eq.stop_timer("wake");
 end
end

function event_timer(e)
 --:: Check the count to make sure the clockwork spiders were killed and not just kited. 
 if (e.timer == "wake" && count >= 12) then
 eq.stop_timer("wake");
 --:: Spawn the targetable version of Manaetic Behemoth in place
 eq.spawn2(206074, 0, 0, e.self:GetX(), e.self:GetY(), e.self:GetZ(), 0);
 --:: Depop the untargetable version of Manaetic Behemoth with respawn timer active.
 eq.depop_with_timer();
 end
end
`
```

### EVENT_SLAY

#### Trigger

- whenever an NPC kills a player.

Often this event is used for some flavor messages, or to spawn adds. Do not confuse this event with EVENT_DEATH_COMPLETE or EVENT_DEATH, which are used when a player kills an NPC.

#### Example

- This is a well-known example from Emperor Ssraeshza, who mocks any player that he kills

PerlLua

```
`sub EVENT_SLAY {
 quest::say("Your god has found you lacking.");
}
`
```

```
`function event_slay(e)
 e.self:Say("Your god has found you lacking.");
end
`
```

### EVENT_SPAWN

#### Trigger

- When the NPC spawns.

This event is often used to start timers, attack player targets, establish NPC HP events or proximities, start dialogues, and more.

#### Example

- In this example, when the mob spawn, we make it run and attack a nearby player while it shouts a war cry.

PerlLua

```
`sub EVENT_SPAWN {
 #:: Set the NPC to run
 quest::SetRunning(1);
 #:: Shout out a war cray
 quest::shout("For Jotenheimr!!!");
 #:: Try to find a random client within 200 units of the NPC
 my $rClient = $entity_list->GetRandomClient($x,$y,$z, 200);
 #:: If there's a random sucker nearby, attack them
 if ($rClient) {
 quest::attack($rClient->GetName());
 }
}
`
```

```
`function event_spawn(e)
 --:: Set the NPC to run
 e.self:SetRunning(1);
 --:: Shout out a war cray
 e.self:Shout("For Jotenheimr!!!");
 --:: Try to find a random client within 200 units of the NPC
 local random_client = entity_list:GetRandomClient(e.self:GetX(), e.self:GetY(), e.self:GetZ(), 200);
 --:: If there's a random sucker nearby, attack them
 if (random_client ~= nil) then
 e.self:Attack(random_client);
 end
end
`
```

### EVENT_SPAWN_ZONE

#### Trigger

- When an NPC spawns.

**Used by the zone controller.**

#### Exports

| 

Name 
| Type 
| Usage 

| spawned_entity_id 
| int 
| `quest::say($spawned_entity_id); # returns int` 

| spawned_npc_id 
| int 
| `quest::say($spawned_npc_id); # returns int` 

### EVENT_SPELL_EFFECT_CLIENT

#### Trigger

- When the spell lands on a client.

#### Exports

| 

Name 
| Type 
| Usage 

| caster_id 
| int 
| `quest::say($caster_id); # returns int` 

### EVENT_SPELL_EFFECT_NPC

#### Trigger

- When the spell lands on an NPC.

#### Exports

| 

Name 
| Type 
| Usage 

| caster_id 
| int 
| `quest::say($caster_id); # returns int` 

### EVENT_SPELL_EFFECT_BUFF_TIC_CLIENT

#### Trigger

- When the spell ticks on a client.

#### Exports

| 

Name 
| Type 
| Usage 

| caster_id 
| int 
| `quest::say($caster_id); # returns int` 

### EVENT_SPELL_EFFECT_BUFF_TIC_NPC

#### Trigger

- When the spell ticks on an NPC.

#### Exports

| 

Name 
| Type 
| Usage 

| caster_id 
| int 
| `quest::say($caster_id); # returns int` 

### EVENT_SPELL_EFFECT_TRANSLOCATE_COMPLETE

#### Trigger

- when translocation is complete.

### EVENT_SPELL_FADE

#### Trigger

- when a spell fades.

### EVENT_TARGET_CHANGE

#### Trigger

- when a mob changes their current target or clears it.

### EVENT_TASKACCEPTED

#### Trigger

- when a player accepts a task from the task selector window.

Typically you would handle this functionality using the task system.

### EVENT_TASK_COMPLETE

#### Trigger

- when a player completes a task.

Typically you would handle this functionality using the task system.

#### Exports

| 

Name 
| Type 
| Usage 

| donecount 
| int 
| `quest::say($donecount); # returns int` 

| activity_id 
| int 
| `quest::say($activity_id); # returns int` 

| task_id 
| int 
| `quest::say($task_id); # returns int` 

### EVENT_TASK_FAIL

#### Trigger

- When a player fails a task.

#### Exports

| 

Name 
| Type 
| Usage 

| task_id 
| int 
| `quest::say($task_id); # returns int` 

Typically you would handle this functionality using the task system.

### EVENT_TASK_STAGE_COMPLETE

#### Trigger

- When a task stage is completed.

Typically you would handle this functionality using the task system.

#### Exports

| 

Name 
| Type 
| Usage 

| activity_id 
| int 
| `quest::say($activity_id); # returns int` 

| task_id 
| int 
| `quest::say($task_id); # returns int` 

#### Example

- In this example, when a player completes a task, it triggers the event and tries to match with task ID 212; if it matches, a yellow message is displayed to the client.

PerlLua

```
`sub EVENT_TASK_STAGE_COMPLETE {
 #:: Match task id 212
 if ($task_id == 212) {
 $client->Message(15,"The zombie presence seems somewhat lessened, and perhaps they have been quelled...for the time being.");
 }
}
`
```

```
`function event_task_stage_complete(e)
 --:: Match task id 212
 if (e.task_id == 212) then
 e.self:Message(15, "The zombie presence seems somewhat lessened, and perhaps they have been quelled...for the time being.");
 end
end
`
```

### EVENT_TASK_UPDATE

#### Trigger

- when a player's task is updated.

#### Exports

| 

Name 
| Type 
| Usage 

| donecount 
| int 
| `quest::say($donecount); # returns int` 

| activity_id 
| int 
| `quest::say($activity_id); # returns int` 

| task_id 
| int 
| `quest::say($task_id); # returns int` 

### EVENT_TIMER

#### Trigger

- by a quest::settimer(timer_name,duration_in_seconds) or quest::settimerMS(timer_name,duration_in_milliseconds)

The timer will loop until it is stopped, and EVENT_TIMER will trigger each time that the duration of the timer elapses. Timers can be stopped using the quest::stopalltimers() or quest::stoptimer(timer_name) functions.

#### Exports

| 

Name 
| Type 
| Usage 

| timer 
| int 
| `quest::say($timer); # returns int` 

#### Example

- This is an example of using a timer with a string name to cause an NPC to depop 30 minutes after it spawns

PerlLua

```
`sub EVENT_SPAWN {
 #:: Start a timer that is named "depop", the duration is 1,800 seconds (30 minutes)
 quest::settimer("depop",1800); 
}

sub EVENT_TIMER {
 #:: Use eq for string comparison to match timer "depop"
 if ($timer eq "depop") {
 # Stop timer "depop" from looping
 quest::stoptimer("depop"); 
 quest::depop(); 
 }
}
`
```

```
`function event_spawn(e) {
 --:: Start a timer that is named "depop", the duration is 1,800 seconds (30 minutes)
 eq.set_timer("depop", 1800); 
end

function event_timer(e) {
 if (e.timer == "depop") then
 --:: Stop timer "depop" from looping
 eq.stop_timer("depop"); 
 eq.depop(); 
 end
end
`
```

### EVENT_TRADE

#### Trigger

- When a client begins a trade.

### EVENT_UNAUGMENT_ITEM

#### Trigger

- When a client removes an augment from an item.

### EVENT_UNEQUIP_ITEM

#### Trigger

- When a client unequips an item.

### EVENT_USE_SKILL

#### Trigger

- When a player uses a skill

#### Exports

| 

Name 
| Type 
| Description 

| skill_id 
| int 
| `quest::say($skill_id); # returns int` 

| skill_level 
| int 
| `quest::say($skill_level); # returns int` 

#### Example

This example would display a message to the client who uses kick and has a high enough skill level.

PerlLua

```
`sub EVENT_USE_SKILL {
 #:: Match if skill is Kick (30) and Skill Level is greater than or equal to 100.
 if ($skill_id == 30 && $skill_level >= 100) {
 $client->Message(315, "You have used Kick. Your skill level is $skill_level");
 }
}
`
```

```
`function event_use_skill(e)
 --:: Match if skill is Kick (30) and Skill Level is greater than or equal to 100.
 if (e.skill_id == 30 && e.skill_level >= 100) then
 e.self:Message(315, "You have used Kick. Your skill level is " .. skill_level .. ".");
 end
end
`
```

### EVENT_WAYPOINT_ARRIVE

#### Trigger

- When an NPC arrives at a grid waypoint entry.

#### Exports

| 

Name 
| Type 
| Description 

| wp 
| int 
| `quest::say($wp); # returns int` 

#### Example

- This example would cause your NPC to speak as it arrives at a particular waypoint.

- Don't forget to count waypoint 0 (the spawn point) when using waypoint events.

PerlLua

```
`sub EVENT_WAYPOINT_ARRIVE {
 #:: If we have arrived at waypoint 10
 if ($wp == 10) {
 quest::say("We're finally here!");
 }
}
`
```

```
`function event_waypoint_arrive(e)
 --:: If we have arrived at waypoint 10
 if (e.wp == 10) then
 e.self:Say("We're finally here!");
 end
end
`
```

### EVENT_WAYPOINT_DEPART

#### Trigger

- When an NPC leaves its current grid waypoint entry.

#### Exports

| 

Name 
| Type 
| Description 

| wp 
| int 
| `quest::say($wp); # returns int` 

#### Example

- This example would cause your NPC to speak as it departs a particular waypoint.

- Don't forget to count waypoint 0 (the spawn point) when using waypoint events.

PerlLua

```
`sub EVENT_WAYPOINT_DEPART {
 # If we departed waypoint 0
 if ($wp == 0) {
 quest::say("And we're off!");
 }
}
`
```

```
`function event_waypoint_depart(e)
 --:: If we departed waypoint 0
 if (e.wp == 0) then
 e.self:Say("And we're off!");
 end
end
`
```

### EVENT_WEAPON_PROC

#### Trigger

- When a weapon procs.

### EVENT_ZONE

#### Trigger

- When a player leaves a zone.

#### Exports

| 

Name 
| Type 
| Description 

| target_zone_id 
| int 
| `quest::say($target_zone_id); # returns int` 

#### Example

- In this example, we blow up pets when a player with a pet zones.

PerlLua

```
`sub EVENT_ZONE {
 #:: Match if a player has a pet
 if ($client->GetPetID()) {
 #:: Get the pet's ID and kill it
 $PetID = $entity_list->GetMobByID($client->GetPetID());
 $PetID->Kill();
 }
}
`
```

```
`function event_zone(e)
 --:: See if the player has a pet
 local pet_id = e.other:GetPet():GetID();
 if (pet_id > 0) then
 --:: Identify the pet by ID and kill it
 local pet_entity = entity_list:GetMob(pet_id);
 pet_entity:Kill();
 end
end
`
```

---

## Lua [Bot]

*Source: quest-api/events/lua-bot/index.html*

# Lua [Bot]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO_SAY

```
`function EVENT_AGGRO_SAY(e) {
}
`
```

## EVENT_CAST

```
`function EVENT_CAST(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_BEGIN

```
`function EVENT_CAST_BEGIN(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_ON

```
`function EVENT_CAST_ON(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_COMBAT

```
`function EVENT_COMBAT(e) {
 eq.debug("other " .. e.other);
 eq.debug("joined " .. e.joined);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`function EVENT_DAMAGE_GIVEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`function EVENT_DAMAGE_TAKEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DEATH

```
`function EVENT_DEATH(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill " .. e.skill);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
}
`
```

## EVENT_DEATH_COMPLETE

```
`function EVENT_DEATH_COMPLETE(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill " .. e.skill);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
}
`
```

## EVENT_DESPAWN

```
`function EVENT_DESPAWN(e) {
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`function EVENT_ENTITY_VARIABLE_DELETE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`function EVENT_ENTITY_VARIABLE_SET(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`function EVENT_ENTITY_VARIABLE_UPDATE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_EQUIP_ITEM_BOT

```
`function EVENT_EQUIP_ITEM_BOT(e) {
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_LEVEL_DOWN

```
`function EVENT_LEVEL_DOWN(e) {
 eq.debug("levels_lost " .. e.levels_lost);
}
`
```

## EVENT_LEVEL_UP

```
`function EVENT_LEVEL_UP(e) {
 eq.debug("levels_gained " .. e.levels_gained);
}
`
```

## EVENT_PAYLOAD

```
`function EVENT_PAYLOAD(e) {
 eq.debug("payload_id " .. e.payload_id);
 eq.debug("payload_value " .. e.payload_value);
}
`
```

## EVENT_POPUP_RESPONSE

```
`function EVENT_POPUP_RESPONSE(e) {
 eq.debug("other " .. e.other);
 eq.debug("popup_id " .. e.popup_id);
}
`
```

## EVENT_SAY

```
`function EVENT_SAY(e) {
 eq.debug("other " .. e.other);
 eq.debug("message " .. e.message);
 eq.debug("language " .. e.language);
}
`
```

## EVENT_SIGNAL

```
`function EVENT_SIGNAL(e) {
 eq.debug("signal " .. e.signal);
}
`
```

## EVENT_SLAY

```
`function EVENT_SLAY(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_SPAWN

```
`function EVENT_SPAWN(e) {
}
`
```

## EVENT_SPELL_BLOCKED

```
`function EVENT_SPELL_BLOCKED(e) {
}
`
```

## EVENT_TARGET_CHANGE

```
`function EVENT_TARGET_CHANGE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`function EVENT_TIMER_PAUSE(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_RESUME

```
`function EVENT_TIMER_RESUME(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_START

```
`function EVENT_TIMER_START(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_STOP

```
`function EVENT_TIMER_STOP(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TRADE

```
`function EVENT_TRADE(e) {
 eq.debug("other " .. e.other);
 eq.debug("platinum " .. e.platinum);
 eq.debug("gold " .. e.gold);
 eq.debug("silver " .. e.silver);
 eq.debug("copper " .. e.copper);
 eq.debug("trade " .. e.trade);
}
`
```

## EVENT_UNEQUIP_ITEM_BOT

```
`function EVENT_UNEQUIP_ITEM_BOT(e) {
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_USE_SKILL

```
`function EVENT_USE_SKILL(e) {
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("skill_level " .. e.skill_level);
}
`
```

---

## Lua [Encounter]

*Source: quest-api/events/lua-encounter/index.html*

# Lua [Encounter]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_ENCOUNTER_LOAD

```
`function EVENT_ENCOUNTER_LOAD(e) {
 eq.debug("encounter " .. e.encounter);
 eq.debug("data " .. e.data);
}
`
```

## EVENT_ENCOUNTER_UNLOAD

```
`function EVENT_ENCOUNTER_UNLOAD(e) {
 eq.debug("data " .. e.data);
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
 eq.debug("timer " .. e.timer);
}
`
```

---

## Lua [Item]

*Source: quest-api/events/lua-item/index.html*

# Lua [Item]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AUGMENT_INSERT

```
`function EVENT_AUGMENT_INSERT(e) {
 eq.debug("item " .. e.item);
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_AUGMENT_ITEM

```
`function EVENT_AUGMENT_ITEM(e) {
 eq.debug("aug " .. e.aug);
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_AUGMENT_REMOVE

```
`function EVENT_AUGMENT_REMOVE(e) {
 eq.debug("item " .. e.item);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("destroyed " .. e.destroyed);
}
`
```

## EVENT_DESTROY_ITEM

```
`function EVENT_DESTROY_ITEM(e) {
}
`
```

## EVENT_DROP_ITEM

```
`function EVENT_DROP_ITEM(e) {
}
`
```

## EVENT_EQUIP_ITEM

```
`function EVENT_EQUIP_ITEM(e) {
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_ITEM_CLICK

```
`function EVENT_ITEM_CLICK(e) {
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_ITEM_CLICK_CAST

```
`function EVENT_ITEM_CLICK_CAST(e) {
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_ITEM_ENTER_ZONE

```
`function EVENT_ITEM_ENTER_ZONE(e) {
}
`
```

## EVENT_LOOT

```
`function EVENT_LOOT(e) {
 eq.debug("corpse " .. e.corpse);
}
`
```

## EVENT_SCALE_CALC

```
`function EVENT_SCALE_CALC(e) {
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`function EVENT_TIMER_PAUSE(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_RESUME

```
`function EVENT_TIMER_RESUME(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_START

```
`function EVENT_TIMER_START(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_STOP

```
`function EVENT_TIMER_STOP(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_UNAUGMENT_ITEM

```
`function EVENT_UNAUGMENT_ITEM(e) {
 eq.debug("aug " .. e.aug);
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_UNEQUIP_ITEM

```
`function EVENT_UNEQUIP_ITEM(e) {
 eq.debug("slot_id " .. e.slot_id);
}
`
```

## EVENT_WEAPON_PROC

```
`function EVENT_WEAPON_PROC(e) {
 eq.debug("target " .. e.target);
 eq.debug("spell " .. e.spell);
}
`
```

---

## Lua [Merc]

*Source: quest-api/events/lua-merc/index.html*

# Lua [Merc]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO_SAY

```
`function EVENT_AGGRO_SAY(e) {
}
`
```

## EVENT_CAST

```
`function EVENT_CAST(e) {
}
`
```

## EVENT_CAST_BEGIN

```
`function EVENT_CAST_BEGIN(e) {
}
`
```

## EVENT_CAST_ON

```
`function EVENT_CAST_ON(e) {
}
`
```

## EVENT_COMBAT

```
`function EVENT_COMBAT(e) {
}
`
```

## EVENT_DAMAGE_GIVEN

```
`function EVENT_DAMAGE_GIVEN(e) {
}
`
```

## EVENT_DAMAGE_TAKEN

```
`function EVENT_DAMAGE_TAKEN(e) {
}
`
```

## EVENT_DEATH

```
`function EVENT_DEATH(e) {
}
`
```

## EVENT_DEATH_COMPLETE

```
`function EVENT_DEATH_COMPLETE(e) {
}
`
```

## EVENT_DESPAWN

```
`function EVENT_DESPAWN(e) {
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`function EVENT_ENTITY_VARIABLE_DELETE(e) {
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`function EVENT_ENTITY_VARIABLE_SET(e) {
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`function EVENT_ENTITY_VARIABLE_UPDATE(e) {
}
`
```

## EVENT_PAYLOAD

```
`function EVENT_PAYLOAD(e) {
}
`
```

## EVENT_POPUP_RESPONSE

```
`function EVENT_POPUP_RESPONSE(e) {
}
`
```

## EVENT_SAY

```
`function EVENT_SAY(e) {
}
`
```

## EVENT_SIGNAL

```
`function EVENT_SIGNAL(e) {
}
`
```

## EVENT_SLAY

```
`function EVENT_SLAY(e) {
}
`
```

## EVENT_SPAWN

```
`function EVENT_SPAWN(e) {
}
`
```

## EVENT_TARGET_CHANGE

```
`function EVENT_TARGET_CHANGE(e) {
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
}
`
```

## EVENT_TIMER_PAUSE

```
`function EVENT_TIMER_PAUSE(e) {
}
`
```

## EVENT_TIMER_RESUME

```
`function EVENT_TIMER_RESUME(e) {
}
`
```

## EVENT_TIMER_START

```
`function EVENT_TIMER_START(e) {
}
`
```

## EVENT_TIMER_STOP

```
`function EVENT_TIMER_STOP(e) {
}
`
```

## EVENT_USE_SKILL

```
`function EVENT_USE_SKILL(e) {
}
`
```

---

## Lua [NPC]

*Source: quest-api/events/lua-npc/index.html*

# Lua [NPC]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO_SAY

```
`function EVENT_AGGRO_SAY(e) {
 eq.debug("other " .. e.other);
 eq.debug("message " .. e.message);
 eq.debug("language " .. e.language);
}
`
```

## EVENT_CAST

```
`function EVENT_CAST(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_BEGIN

```
`function EVENT_CAST_BEGIN(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_ON

```
`function EVENT_CAST_ON(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_COMBAT

```
`function EVENT_COMBAT(e) {
 eq.debug("other " .. e.other);
 eq.debug("joined " .. e.joined);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`function EVENT_DAMAGE_GIVEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`function EVENT_DAMAGE_TAKEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DEATH

```
`function EVENT_DEATH(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
 eq.debug("combat_start_time " .. e.combat_start_time);
 eq.debug("combat_end_time " .. e.combat_end_time);
 eq.debug("damage_received " .. e.damage_received);
 eq.debug("healing_received " .. e.healing_received);
 eq.debug("corpse " .. e.corpse);
 eq.debug("killed " .. e.killed);
}
`
```

## EVENT_DEATH_COMPLETE

```
`function EVENT_DEATH_COMPLETE(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
 eq.debug("combat_start_time " .. e.combat_start_time);
 eq.debug("combat_end_time " .. e.combat_end_time);
 eq.debug("damage_received " .. e.damage_received);
 eq.debug("healing_received " .. e.healing_received);
 eq.debug("corpse " .. e.corpse);
 eq.debug("killed " .. e.killed);
}
`
```

## EVENT_DEATH_ZONE

```
`function EVENT_DEATH_ZONE(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
 eq.debug("combat_start_time " .. e.combat_start_time);
 eq.debug("combat_end_time " .. e.combat_end_time);
 eq.debug("damage_received " .. e.damage_received);
 eq.debug("healing_received " .. e.healing_received);
 eq.debug("corpse " .. e.corpse);
 eq.debug("killed " .. e.killed);
}
`
```

## EVENT_DESPAWN

```
`function EVENT_DESPAWN(e) {
}
`
```

## EVENT_DESPAWN_ZONE

```
`function EVENT_DESPAWN_ZONE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_ENTER

```
`function EVENT_ENTER(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_ENTER_AREA

```
`function EVENT_ENTER_AREA(e) {
 eq.debug("area_id " .. e.area_id);
 eq.debug("area_type " .. e.area_type);
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`function EVENT_ENTITY_VARIABLE_DELETE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`function EVENT_ENTITY_VARIABLE_SET(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`function EVENT_ENTITY_VARIABLE_UPDATE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_EXIT

```
`function EVENT_EXIT(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_FEIGN_DEATH

```
`function EVENT_FEIGN_DEATH(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_HATE_LIST

```
`function EVENT_HATE_LIST(e) {
 eq.debug("other " .. e.other);
 eq.debug("joined " .. e.joined);
}
`
```

## EVENT_HP

```
`function EVENT_HP(e) {
 eq.debug("hp_event " .. e.hp_event);
 eq.debug("inc_hp_event " .. e.inc_hp_event);
}
`
```

## EVENT_KILLED_MERIT

```
`function EVENT_KILLED_MERIT(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_LEAVE_AREA

```
`function EVENT_LEAVE_AREA(e) {
 eq.debug("area_id " .. e.area_id);
 eq.debug("area_type " .. e.area_type);
}
`
```

## EVENT_LOOT_ADDED

```
`function EVENT_LOOT_ADDED(e) {
 eq.debug("item " .. e.item);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_name " .. e.item_name);
 eq.debug("item_charges " .. e.item_charges);
 eq.debug("augment_one " .. e.augment_one);
 eq.debug("augment_two " .. e.augment_two);
 eq.debug("augment_three " .. e.augment_three);
 eq.debug("augment_four " .. e.augment_four);
 eq.debug("augment_five " .. e.augment_five);
 eq.debug("augment_six " .. e.augment_six);
}
`
```

## EVENT_LOOT_ZONE

```
`function EVENT_LOOT_ZONE(e) {
 eq.debug("other " .. e.other);
 eq.debug("item " .. e.item);
 eq.debug("corpse " .. e.corpse);
}
`
```

## EVENT_PAYLOAD

```
`function EVENT_PAYLOAD(e) {
 eq.debug("payload_id " .. e.payload_id);
 eq.debug("payload_value " .. e.payload_value);
}
`
```

## EVENT_POPUP_RESPONSE

```
`function EVENT_POPUP_RESPONSE(e) {
 eq.debug("other " .. e.other);
 eq.debug("popup_id " .. e.popup_id);
}
`
```

## EVENT_PROXIMITY_SAY

```
`function EVENT_PROXIMITY_SAY(e) {
 eq.debug("other " .. e.other);
 eq.debug("message " .. e.message);
 eq.debug("language " .. e.language);
}
`
```

## EVENT_SAY

```
`function EVENT_SAY(e) {
 eq.debug("other " .. e.other);
 eq.debug("message " .. e.message);
 eq.debug("language " .. e.language);
}
`
```

## EVENT_SIGNAL

```
`function EVENT_SIGNAL(e) {
 eq.debug("signal " .. e.signal);
}
`
```

## EVENT_SLAY

```
`function EVENT_SLAY(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_SPAWN

```
`function EVENT_SPAWN(e) {
}
`
```

## EVENT_SPAWN_ZONE

```
`function EVENT_SPAWN_ZONE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_SPELL_BLOCKED

```
`function EVENT_SPELL_BLOCKED(e) {
 eq.debug("blocking_spell_id " .. e.blocking_spell_id);
 eq.debug("cast_spell_id " .. e.cast_spell_id);
 eq.debug("blocking_spell " .. e.blocking_spell);
 eq.debug("cast_spell " .. e.cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`function EVENT_TARGET_CHANGE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_TASK_ACCEPTED

```
`function EVENT_TASK_ACCEPTED(e) {
 eq.debug("other " .. e.other);
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TICK

```
`function EVENT_TICK(e) {
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`function EVENT_TIMER_PAUSE(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_RESUME

```
`function EVENT_TIMER_RESUME(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_START

```
`function EVENT_TIMER_START(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_STOP

```
`function EVENT_TIMER_STOP(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TRADE

```
`function EVENT_TRADE(e) {
 eq.debug("other " .. e.other);
 eq.debug("platinum " .. e.platinum);
 eq.debug("gold " .. e.gold);
 eq.debug("silver " .. e.silver);
 eq.debug("copper " .. e.copper);
 eq.debug("trade " .. e.trade);
}
`
```

## EVENT_WAYPOINT_ARRIVE

```
`function EVENT_WAYPOINT_ARRIVE(e) {
 eq.debug("other " .. e.other);
 eq.debug("wp " .. e.wp);
}
`
```

## EVENT_WAYPOINT_DEPART

```
`function EVENT_WAYPOINT_DEPART(e) {
 eq.debug("other " .. e.other);
 eq.debug("wp " .. e.wp);
}
`
```

---

## Lua [Player]

*Source: quest-api/events/lua-player/index.html*

# Lua [Player]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AA_BUY

```
`function EVENT_AA_BUY(e) {
 eq.debug("aa_cost " .. e.aa_cost);
 eq.debug("aa_id " .. e.aa_id);
 eq.debug("aa_previous_id " .. e.aa_previous_id);
 eq.debug("aa_next_id " .. e.aa_next_id);
}
`
```

## EVENT_AA_EXP_GAIN

```
`function EVENT_AA_EXP_GAIN(e) {
 eq.debug("aa_exp_gained " .. e.aa_exp_gained);
}
`
```

## EVENT_AA_GAIN

```
`function EVENT_AA_GAIN(e) {
 eq.debug("aa_gained " .. e.aa_gained);
}
`
```

## EVENT_AA_LOSS

```
`function EVENT_AA_LOSS(e) {
 eq.debug("aa_lost " .. e.aa_lost);
}
`
```

## EVENT_ALT_CURRENCY_GAIN

```
`function EVENT_ALT_CURRENCY_GAIN(e) {
 eq.debug("currency_id " .. e.currency_id);
 eq.debug("amount " .. e.amount);
 eq.debug("total " .. e.total);
}
`
```

## EVENT_ALT_CURRENCY_LOSS

```
`function EVENT_ALT_CURRENCY_LOSS(e) {
 eq.debug("currency_id " .. e.currency_id);
 eq.debug("amount " .. e.amount);
 eq.debug("total " .. e.total);
}
`
```

## EVENT_ALT_CURRENCY_MERCHANT_BUY

```
`function EVENT_ALT_CURRENCY_MERCHANT_BUY(e) {
 eq.debug("currency_id " .. e.currency_id);
 eq.debug("npc_id " .. e.npc_id);
 eq.debug("merchant_id " .. e.merchant_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_cost " .. e.item_cost);
}
`
```

## EVENT_ALT_CURRENCY_MERCHANT_SELL

```
`function EVENT_ALT_CURRENCY_MERCHANT_SELL(e) {
 eq.debug("currency_id " .. e.currency_id);
 eq.debug("npc_id " .. e.npc_id);
 eq.debug("merchant_id " .. e.merchant_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_cost " .. e.item_cost);
}
`
```

## EVENT_AUGMENT_INSERT_CLIENT

```
`function EVENT_AUGMENT_INSERT_CLIENT(e) {
 eq.debug("item " .. e.item);
 eq.debug("augment " .. e.augment);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_slot " .. e.item_slot);
 eq.debug("augment_id " .. e.augment_id);
 eq.debug("augment_slot " .. e.augment_slot);
}
`
```

## EVENT_AUGMENT_REMOVE_CLIENT

```
`function EVENT_AUGMENT_REMOVE_CLIENT(e) {
 eq.debug("item " .. e.item);
 eq.debug("augment " .. e.augment);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_slot " .. e.item_slot);
 eq.debug("augment_id " .. e.augment_id);
 eq.debug("augment_slot " .. e.augment_slot);
 eq.debug("destroyed " .. e.destroyed);
}
`
```

## EVENT_BOT_COMMAND

```
`function EVENT_BOT_COMMAND(e) {
 eq.debug("bot_command " .. e.bot_command);
 eq.debug("args " .. e.args);
}
`
```

## EVENT_BOT_CREATE

```
`function EVENT_BOT_CREATE(e) {
 eq.debug("bot_name " .. e.bot_name);
 eq.debug("bot_id " .. e.bot_id);
 eq.debug("bot_race " .. e.bot_race);
 eq.debug("bot_class " .. e.bot_class);
 eq.debug("bot_gender " .. e.bot_gender);
}
`
```

## EVENT_CAST

```
`function EVENT_CAST(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_BEGIN

```
`function EVENT_CAST_BEGIN(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CAST_ON

```
`function EVENT_CAST_ON(e) {
 eq.debug("spell " .. e.spell);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("target_id " .. e.target_id);
 eq.debug("target " .. e.target);
}
`
```

## EVENT_CLICK_DOOR

```
`function EVENT_CLICK_DOOR(e) {
 eq.debug("door " .. e.door);
}
`
```

## EVENT_CLICK_OBJECT

```
`function EVENT_CLICK_OBJECT(e) {
 eq.debug("object " .. e.object);
}
`
```

## EVENT_COMBINE

```
`function EVENT_COMBINE(e) {
 eq.debug("container_slot " .. e.container_slot);
}
`
```

## EVENT_COMBINE_FAILURE

```
`function EVENT_COMBINE_FAILURE(e) {
 eq.debug("recipe_id " .. e.recipe_id);
 eq.debug("recipe_name " .. e.recipe_name);
}
`
```

## EVENT_COMBINE_SUCCESS

```
`function EVENT_COMBINE_SUCCESS(e) {
 eq.debug("recipe_id " .. e.recipe_id);
 eq.debug("recipe_name " .. e.recipe_name);
}
`
```

## EVENT_COMBINE_VALIDATE

```
`function EVENT_COMBINE_VALIDATE(e) {
 eq.debug("recipe_id " .. e.recipe_id);
 eq.debug("validate_type " .. e.validate_type);
 eq.debug("zone_id " .. e.zone_id);
 eq.debug("tradeskill_id " .. e.tradeskill_id);
}
`
```

## EVENT_COMMAND

```
`function EVENT_COMMAND(e) {
 eq.debug("command " .. e.command);
 eq.debug("args " .. e.args);
}
`
```

## EVENT_CONNECT

```
`function EVENT_CONNECT(e) {
}
`
```

## EVENT_CONSIDER

```
`function EVENT_CONSIDER(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_CONSIDER_CORPSE

```
`function EVENT_CONSIDER_CORPSE(e) {
 eq.debug("corpse_entity_id " .. e.corpse_entity_id);
 eq.debug("corpse " .. e.corpse);
}
`
```

## EVENT_CRYSTAL_GAIN

```
`function EVENT_CRYSTAL_GAIN(e) {
 eq.debug("ebon_amount " .. e.ebon_amount);
 eq.debug("radiant_amount " .. e.radiant_amount);
 eq.debug("is_reclaim " .. e.is_reclaim);
}
`
```

## EVENT_CRYSTAL_LOSS

```
`function EVENT_CRYSTAL_LOSS(e) {
 eq.debug("ebon_amount " .. e.ebon_amount);
 eq.debug("radiant_amount " .. e.radiant_amount);
 eq.debug("is_reclaim " .. e.is_reclaim);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`function EVENT_DAMAGE_GIVEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`function EVENT_DAMAGE_TAKEN(e) {
 eq.debug("entity_id " .. e.entity_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("is_damage_shield " .. e.is_damage_shield);
 eq.debug("is_avoidable " .. e.is_avoidable);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("is_buff_tic " .. e.is_buff_tic);
 eq.debug("special_attack " .. e.special_attack);
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DEATH

```
`function EVENT_DEATH(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill " .. e.skill);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
 eq.debug("combat_start_time " .. e.combat_start_time);
 eq.debug("combat_end_time " .. e.combat_end_time);
 eq.debug("damage_received " .. e.damage_received);
 eq.debug("healing_received " .. e.healing_received);
}
`
```

## EVENT_DEATH_COMPLETE

```
`function EVENT_DEATH_COMPLETE(e) {
 eq.debug("other " .. e.other);
 eq.debug("killer_id " .. e.killer_id);
 eq.debug("damage " .. e.damage);
 eq.debug("spell " .. e.spell);
 eq.debug("skill " .. e.skill);
 eq.debug("killed_entity_id " .. e.killed_entity_id);
 eq.debug("combat_start_time " .. e.combat_start_time);
 eq.debug("combat_end_time " .. e.combat_end_time);
 eq.debug("damage_received " .. e.damage_received);
 eq.debug("healing_received " .. e.healing_received);
}
`
```

## EVENT_DESTROY_ITEM_CLIENT

```
`function EVENT_DESTROY_ITEM_CLIENT(e) {
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_name " .. e.item_name);
 eq.debug("quantity " .. e.quantity);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_DISCONNECT

```
`function EVENT_DISCONNECT(e) {
}
`
```

## EVENT_DISCOVER_ITEM

```
`function EVENT_DISCOVER_ITEM(e) {
 eq.debug("item " .. e.item);
}
`
```

## EVENT_DROP_ITEM_CLIENT

```
`function EVENT_DROP_ITEM_CLIENT(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("quantity " .. e.quantity);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_name " .. e.item_name);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_DUEL_LOSE

```
`function EVENT_DUEL_LOSE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_DUEL_WIN

```
`function EVENT_DUEL_WIN(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_ENTER

```
`function EVENT_ENTER(e) {
}
`
```

## EVENT_ENTER_AREA

```
`function EVENT_ENTER_AREA(e) {
 eq.debug("area_id " .. e.area_id);
 eq.debug("area_type " .. e.area_type);
}
`
```

## EVENT_ENTER_ZONE

```
`function EVENT_ENTER_ZONE(e) {
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`function EVENT_ENTITY_VARIABLE_DELETE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`function EVENT_ENTITY_VARIABLE_SET(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`function EVENT_ENTITY_VARIABLE_UPDATE(e) {
 eq.debug("variable_name " .. e.variable_name);
 eq.debug("variable_value " .. e.variable_value);
 eq.debug("old_value " .. e.old_value);
 eq.debug("new_value " .. e.new_value);
}
`
```

## EVENT_ENVIRONMENTAL_DAMAGE

```
`function EVENT_ENVIRONMENTAL_DAMAGE(e) {
 eq.debug("env_damage " .. e.env_damage);
 eq.debug("env_damage_type " .. e.env_damage_type);
 eq.debug("env_final_damage " .. e.env_final_damage);
}
`
```

## EVENT_EQUIP_ITEM_CLIENT

```
`function EVENT_EQUIP_ITEM_CLIENT(e) {
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_EXIT

```
`function EVENT_EXIT(e) {
}
`
```

## EVENT_EXP_GAIN

```
`function EVENT_EXP_GAIN(e) {
 eq.debug("exp_gained " .. e.exp_gained);
}
`
```

## EVENT_FEIGN_DEATH

```
`function EVENT_FEIGN_DEATH(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_FISH_FAILURE

```
`function EVENT_FISH_FAILURE(e) {
}
`
```

## EVENT_FISH_START

```
`function EVENT_FISH_START(e) {
}
`
```

## EVENT_FISH_SUCCESS

```
`function EVENT_FISH_SUCCESS(e) {
 eq.debug("item " .. e.item);
}
`
```

## EVENT_FORAGE_FAILURE

```
`function EVENT_FORAGE_FAILURE(e) {
}
`
```

## EVENT_FORAGE_SUCCESS

```
`function EVENT_FORAGE_SUCCESS(e) {
 eq.debug("item " .. e.item);
}
`
```

## EVENT_GM_COMMAND

```
`function EVENT_GM_COMMAND(e) {
 eq.debug("message " .. e.message);
}
`
```

## EVENT_GROUP_CHANGE

```
`function EVENT_GROUP_CHANGE(e) {
}
`
```

## EVENT_INSPECT

```
`function EVENT_INSPECT(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_ITEM_CLICK_CAST_CLIENT

```
`function EVENT_ITEM_CLICK_CAST_CLIENT(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_name " .. e.item_name);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_ITEM_CLICK_CLIENT

```
`function EVENT_ITEM_CLICK_CLIENT(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_name " .. e.item_name);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_LANGUAGE_SKILL_UP

```
`function EVENT_LANGUAGE_SKILL_UP(e) {
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("skill_value " .. e.skill_value);
 eq.debug("skill_max " .. e.skill_max);
}
`
```

## EVENT_LDON_POINTS_GAIN

```
`function EVENT_LDON_POINTS_GAIN(e) {
 eq.debug("theme_id " .. e.theme_id);
 eq.debug("points " .. e.points);
}
`
```

## EVENT_LDON_POINTS_LOSS

```
`function EVENT_LDON_POINTS_LOSS(e) {
 eq.debug("theme_id " .. e.theme_id);
 eq.debug("points " .. e.points);
}
`
```

## EVENT_LEAVE_AREA

```
`function EVENT_LEAVE_AREA(e) {
 eq.debug("area_id " .. e.area_id);
 eq.debug("area_type " .. e.area_type);
}
`
```

## EVENT_LEVEL_DOWN

```
`function EVENT_LEVEL_DOWN(e) {
 eq.debug("levels_lost " .. e.levels_lost);
}
`
```

## EVENT_LEVEL_UP

```
`function EVENT_LEVEL_UP(e) {
 eq.debug("levels_gained " .. e.levels_gained);
}
`
```

## EVENT_LOOT

```
`function EVENT_LOOT(e) {
 eq.debug("item " .. e.item);
 eq.debug("corpse " .. e.corpse);
}
`
```

## EVENT_MEMORIZE_SPELL

```
`function EVENT_MEMORIZE_SPELL(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_MERCHANT_BUY

```
`function EVENT_MERCHANT_BUY(e) {
 eq.debug("npc_id " .. e.npc_id);
 eq.debug("merchant_id " .. e.merchant_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("item_cost " .. e.item_cost);
}
`
```

## EVENT_MERCHANT_SELL

```
`function EVENT_MERCHANT_SELL(e) {
 eq.debug("npc_id " .. e.npc_id);
 eq.debug("merchant_id " .. e.merchant_id);
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("item_cost " .. e.item_cost);
}
`
```

## EVENT_PAYLOAD

```
`function EVENT_PAYLOAD(e) {
 eq.debug("payload_id " .. e.payload_id);
 eq.debug("payload_value " .. e.payload_value);
}
`
```

## EVENT_PLAYER_PICKUP

```
`function EVENT_PLAYER_PICKUP(e) {
 eq.debug("item " .. e.item);
}
`
```

## EVENT_POPUP_RESPONSE

```
`function EVENT_POPUP_RESPONSE(e) {
 eq.debug("popup_id " .. e.popup_id);
}
`
```

## EVENT_READ_ITEM

```
`function EVENT_READ_ITEM(e) {
 eq.debug("text_file " .. e.text_file);
 eq.debug("item_id " .. e.item_id);
 eq.debug("book_text " .. e.book_text);
 eq.debug("can_cast " .. e.can_cast);
 eq.debug("can_scribe " .. e.can_scribe);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("target_id " .. e.target_id);
 eq.debug("type " .. e.type);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_RESPAWN

```
`function EVENT_RESPAWN(e) {
 eq.debug("option " .. e.option);
 eq.debug("resurrect " .. e.resurrect);
}
`
```

## EVENT_SAY

```
`function EVENT_SAY(e) {
 eq.debug("message " .. e.message);
 eq.debug("language " .. e.language);
}
`
```

## EVENT_SCRIBE_SPELL

```
`function EVENT_SCRIBE_SPELL(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_SIGNAL

```
`function EVENT_SIGNAL(e) {
 eq.debug("signal " .. e.signal);
}
`
```

## EVENT_SKILL_UP

```
`function EVENT_SKILL_UP(e) {
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("skill_value " .. e.skill_value);
 eq.debug("skill_max " .. e.skill_max);
 eq.debug("is_tradeskill " .. e.is_tradeskill);
}
`
```

## EVENT_SPELL_BLOCKED

```
`function EVENT_SPELL_BLOCKED(e) {
 eq.debug("blocking_spell_id " .. e.blocking_spell_id);
 eq.debug("cast_spell_id " .. e.cast_spell_id);
 eq.debug("blocking_spell " .. e.blocking_spell);
 eq.debug("cast_spell " .. e.cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`function EVENT_TARGET_CHANGE(e) {
 eq.debug("other " .. e.other);
}
`
```

## EVENT_TASK_ACCEPTED

```
`function EVENT_TASK_ACCEPTED(e) {
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TASK_BEFORE_UPDATE

```
`function EVENT_TASK_BEFORE_UPDATE(e) {
 eq.debug("count " .. e.count);
 eq.debug("activity_id " .. e.activity_id);
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TASK_COMPLETE

```
`function EVENT_TASK_COMPLETE(e) {
 eq.debug("count " .. e.count);
 eq.debug("activity_id " .. e.activity_id);
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TASK_FAIL

```
`function EVENT_TASK_FAIL(e) {
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TASK_STAGE_COMPLETE

```
`function EVENT_TASK_STAGE_COMPLETE(e) {
 eq.debug("task_id " .. e.task_id);
 eq.debug("activity_id " .. e.activity_id);
}
`
```

## EVENT_TASK_UPDATE

```
`function EVENT_TASK_UPDATE(e) {
 eq.debug("count " .. e.count);
 eq.debug("activity_id " .. e.activity_id);
 eq.debug("task_id " .. e.task_id);
}
`
```

## EVENT_TEST_BUFF

```
`function EVENT_TEST_BUFF(e) {
}
`
```

## EVENT_TIMER

```
`function EVENT_TIMER(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`function EVENT_TIMER_PAUSE(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_RESUME

```
`function EVENT_TIMER_RESUME(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_START

```
`function EVENT_TIMER_START(e) {
 eq.debug("timer " .. e.timer);
 eq.debug("duration " .. e.duration);
}
`
```

## EVENT_TIMER_STOP

```
`function EVENT_TIMER_STOP(e) {
 eq.debug("timer " .. e.timer);
}
`
```

## EVENT_UNEQUIP_ITEM_CLIENT

```
`function EVENT_UNEQUIP_ITEM_CLIENT(e) {
 eq.debug("item_id " .. e.item_id);
 eq.debug("item_quantity " .. e.item_quantity);
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("item " .. e.item);
}
`
```

## EVENT_UNHANDLED_OPCODE

```
`function EVENT_UNHANDLED_OPCODE(e) {
 eq.debug("packet " .. e.packet);
 eq.debug("connecting " .. e.connecting);
}
`
```

## EVENT_UNMEMORIZE_SPELL

```
`function EVENT_UNMEMORIZE_SPELL(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_UNSCRIBE_SPELL

```
`function EVENT_UNSCRIBE_SPELL(e) {
 eq.debug("slot_id " .. e.slot_id);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_USE_SKILL

```
`function EVENT_USE_SKILL(e) {
 eq.debug("skill_id " .. e.skill_id);
 eq.debug("skill_level " .. e.skill_level);
}
`
```

## EVENT_WARP

```
`function EVENT_WARP(e) {
 eq.debug("from_x " .. e.from_x);
 eq.debug("from_y " .. e.from_y);
 eq.debug("from_z " .. e.from_z);
}
`
```

## EVENT_ZONE

```
`function EVENT_ZONE(e) {
 eq.debug("from_zone_id " .. e.from_zone_id);
 eq.debug("from_instance_id " .. e.from_instance_id);
 eq.debug("from_instance_version " .. e.from_instance_version);
 eq.debug("zone_id " .. e.zone_id);
 eq.debug("instance_id " .. e.instance_id);
 eq.debug("instance_version " .. e.instance_version);
}
`
```

---

## Lua [Spell]

*Source: quest-api/events/lua-spell/index.html*

# Lua [Spell]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_SPELL_EFFECT_BUFF_TIC_CLIENT

```
`function EVENT_SPELL_EFFECT_BUFF_TIC_CLIENT(e) {
 eq.debug("target " .. e.target);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("tics_remaining " .. e.tics_remaining);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_SPELL_EFFECT_CLIENT

```
`function EVENT_SPELL_EFFECT_CLIENT(e) {
 eq.debug("target " .. e.target);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("tics_remaining " .. e.tics_remaining);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("spell " .. e.spell);
}
`
```

## EVENT_SPELL_EFFECT_TRANSLOCATE_COMPLETE

```
`function EVENT_SPELL_EFFECT_TRANSLOCATE_COMPLETE(e) {
 eq.debug("target " .. e.target);
}
`
```

## EVENT_SPELL_FADE

```
`function EVENT_SPELL_FADE(e) {
 eq.debug("target " .. e.target);
 eq.debug("spell_id " .. e.spell_id);
 eq.debug("caster_id " .. e.caster_id);
 eq.debug("tics_remaining " .. e.tics_remaining);
 eq.debug("caster_level " .. e.caster_level);
 eq.debug("buff_slot " .. e.buff_slot);
 eq.debug("spell " .. e.spell);
}
`
```

---

## Perl [Bot]

*Source: quest-api/events/perl-bot/index.html*

# Perl [Bot]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO_SAY

```
`sub EVENT_AGGRO_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_ATTACK

```
`sub EVENT_ATTACK {
}
`
```

## EVENT_CAST

```
`sub EVENT_CAST {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_BEGIN

```
`sub EVENT_CAST_BEGIN {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_ON

```
`sub EVENT_CAST_ON {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_COMBAT

```
`sub EVENT_COMBAT {
 quest::debug("combat_state " . $combat_state);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`sub EVENT_DAMAGE_GIVEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`sub EVENT_DAMAGE_TAKEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DEATH

```
`sub EVENT_DEATH {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DEATH_COMPLETE

```
`sub EVENT_DEATH_COMPLETE {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DESPAWN

```
`sub EVENT_DESPAWN {
 quest::debug("despawned_entity_id " . $despawned_entity_id);
 quest::debug("despawned_bot_id " . $despawned_bot_id);
 quest::debug("despawned_merc_id " . $despawned_merc_id);
 quest::debug("despawned_npc_id " . $despawned_npc_id);
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`sub EVENT_ENTITY_VARIABLE_DELETE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`sub EVENT_ENTITY_VARIABLE_SET {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`sub EVENT_ENTITY_VARIABLE_UPDATE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("old_value " . $old_value);
 quest::debug("new_value " . $new_value);
}
`
```

## EVENT_EQUIP_ITEM_BOT

```
`sub EVENT_EQUIP_ITEM_BOT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("slot_id " . $slot_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_ITEM

```
`sub EVENT_ITEM {
 quest::debug("QuestItem " . $QuestItem);
 quest::debug("copper " . $copper);
 quest::debug("silver " . $silver);
 quest::debug("gold " . $gold);
 quest::debug("platinum " . $platinum);
}
`
```

## EVENT_LEVEL_DOWN

```
`sub EVENT_LEVEL_DOWN {
 quest::debug("levels_lost " . $levels_lost);
}
`
```

## EVENT_LEVEL_UP

```
`sub EVENT_LEVEL_UP {
 quest::debug("levels_gained " . $levels_gained);
}
`
```

## EVENT_NPC_SLAY

```
`sub EVENT_NPC_SLAY {
 quest::debug("killed " . $killed);
 quest::debug("killed_npc " . $killed_npc);
}
`
```

## EVENT_PAYLOAD

```
`sub EVENT_PAYLOAD {
 quest::debug("payload_id " . $payload_id);
 quest::debug("payload_value " . $payload_value);
}
`
```

## EVENT_POPUPRESPONSE

```
`sub EVENT_POPUPRESPONSE {
 quest::debug("popupid " . $popupid);
}
`
```

## EVENT_SAY

```
`sub EVENT_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_SIGNAL

```
`sub EVENT_SIGNAL {
 quest::debug("signal " . $signal);
}
`
```

## EVENT_SLAY

```
`sub EVENT_SLAY {
}
`
```

## EVENT_SPAWN

```
`sub EVENT_SPAWN {
}
`
```

## EVENT_SPELL_BLOCKED

```
`sub EVENT_SPELL_BLOCKED {
 quest::debug("blocking_spell_id " . $blocking_spell_id);
 quest::debug("cast_spell_id " . $cast_spell_id);
 quest::debug("blocking_spell " . $blocking_spell);
 quest::debug("cast_spell " . $cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`sub EVENT_TARGET_CHANGE {
 quest::debug("target " . $target);
}
`
```

## EVENT_TIMER

```
`sub EVENT_TIMER {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`sub EVENT_TIMER_PAUSE {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_RESUME

```
`sub EVENT_TIMER_RESUME {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_START

```
`sub EVENT_TIMER_START {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_STOP

```
`sub EVENT_TIMER_STOP {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_UNEQUIP_ITEM_BOT

```
`sub EVENT_UNEQUIP_ITEM_BOT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("slot_id " . $slot_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_USE_SKILL

```
`sub EVENT_USE_SKILL {
 quest::debug("skill_id " . $skill_id);
 quest::debug("skill_level " . $skill_level);
}
`
```

---

## Perl [Item]

*Source: quest-api/events/perl-item/index.html*

# Perl [Item]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AUGMENT_INSERT

```
`sub EVENT_AUGMENT_INSERT {
}
`
```

## EVENT_AUGMENT_ITEM

```
`sub EVENT_AUGMENT_ITEM {
}
`
```

## EVENT_AUGMENT_REMOVE

```
`sub EVENT_AUGMENT_REMOVE {
}
`
```

## EVENT_DESTROY_ITEM

```
`sub EVENT_DESTROY_ITEM {
}
`
```

## EVENT_DROP_ITEM

```
`sub EVENT_DROP_ITEM {
 quest::debug("quantity " . $quantity);
 quest::debug("itemname " . $itemname);
 quest::debug("itemid " . $itemid);
 quest::debug("spell_id " . $spell_id);
 quest::debug("slotid " . $slotid);
}
`
```

## EVENT_EQUIP_ITEM

```
`sub EVENT_EQUIP_ITEM {
}
`
```

## EVENT_ITEM_CLICK

```
`sub EVENT_ITEM_CLICK {
 quest::debug("itemid " . $itemid);
 quest::debug("itemname " . $itemname);
 quest::debug("slotid " . $slotid);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_ITEM_CLICK_CAST

```
`sub EVENT_ITEM_CLICK_CAST {
 quest::debug("itemid " . $itemid);
 quest::debug("itemname " . $itemname);
 quest::debug("slotid " . $slotid);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_ITEM_ENTER_ZONE

```
`sub EVENT_ITEM_ENTER_ZONE {
 quest::debug("itemid " . $itemid);
 quest::debug("itemname " . $itemname);
}
`
```

## EVENT_LOOT

```
`sub EVENT_LOOT {
 quest::debug("looted_id " . $looted_id);
 quest::debug("looted_charges " . $looted_charges);
 quest::debug("corpse_name " . $corpse_name);
 quest::debug("corpse_id " . $corpse_id);
 quest::debug("corpse " . $corpse);
}
`
```

## EVENT_SCALE_CALC

```
`sub EVENT_SCALE_CALC {
 quest::debug("itemid " . $itemid);
 quest::debug("itemname " . $itemname);
}
`
```

## EVENT_TIMER

```
`sub EVENT_TIMER {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_TIMER_START

```
`sub EVENT_TIMER_START {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_STOP

```
`sub EVENT_TIMER_STOP {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_UNAUGMENT_ITEM

```
`sub EVENT_UNAUGMENT_ITEM {
}
`
```

## EVENT_UNEQUIP_ITEM

```
`sub EVENT_UNEQUIP_ITEM {
}
`
```

## EVENT_WEAPON_PROC

```
`sub EVENT_WEAPON_PROC {
}
`
```

---

## Perl [Merc]

*Source: quest-api/events/perl-merc/index.html*

# Perl [Merc]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO_SAY

```
`sub EVENT_AGGRO_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_ATTACK

```
`sub EVENT_ATTACK {
}
`
```

## EVENT_CAST

```
`sub EVENT_CAST {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_BEGIN

```
`sub EVENT_CAST_BEGIN {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_ON

```
`sub EVENT_CAST_ON {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_COMBAT

```
`sub EVENT_COMBAT {
 quest::debug("combat_state " . $combat_state);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`sub EVENT_DAMAGE_GIVEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`sub EVENT_DAMAGE_TAKEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DEATH

```
`sub EVENT_DEATH {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DEATH_COMPLETE

```
`sub EVENT_DEATH_COMPLETE {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DESPAWN

```
`sub EVENT_DESPAWN {
 quest::debug("despawned_entity_id " . $despawned_entity_id);
 quest::debug("despawned_bot_id " . $despawned_bot_id);
 quest::debug("despawned_merc_id " . $despawned_merc_id);
 quest::debug("despawned_npc_id " . $despawned_npc_id);
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`sub EVENT_ENTITY_VARIABLE_DELETE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`sub EVENT_ENTITY_VARIABLE_SET {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`sub EVENT_ENTITY_VARIABLE_UPDATE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("old_value " . $old_value);
 quest::debug("new_value " . $new_value);
}
`
```

## EVENT_NPC_SLAY

```
`sub EVENT_NPC_SLAY {
 quest::debug("killed " . $killed);
 quest::debug("killed_npc " . $killed_npc);
}
`
```

## EVENT_PAYLOAD

```
`sub EVENT_PAYLOAD {
 quest::debug("payload_id " . $payload_id);
 quest::debug("payload_value " . $payload_value);
}
`
```

## EVENT_POPUPRESPONSE

```
`sub EVENT_POPUPRESPONSE {
 quest::debug("popupid " . $popupid);
}
`
```

## EVENT_SAY

```
`sub EVENT_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_SIGNAL

```
`sub EVENT_SIGNAL {
 quest::debug("signal " . $signal);
}
`
```

## EVENT_SLAY

```
`sub EVENT_SLAY {
}
`
```

## EVENT_SPAWN

```
`sub EVENT_SPAWN {
}
`
```

## EVENT_SPELL_BLOCKED

```
`sub EVENT_SPELL_BLOCKED {
 quest::debug("blocking_spell_id " . $blocking_spell_id);
 quest::debug("cast_spell_id " . $cast_spell_id);
 quest::debug("blocking_spell " . $blocking_spell);
 quest::debug("cast_spell " . $cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`sub EVENT_TARGET_CHANGE {
 quest::debug("target " . $target);
}
`
```

## EVENT_TIMER

```
`sub EVENT_TIMER {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`sub EVENT_TIMER_PAUSE {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_RESUME

```
`sub EVENT_TIMER_RESUME {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_START

```
`sub EVENT_TIMER_START {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_STOP

```
`sub EVENT_TIMER_STOP {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_USE_SKILL

```
`sub EVENT_USE_SKILL {
 quest::debug("skill_id " . $skill_id);
 quest::debug("skill_level " . $skill_level);
}
`
```

---

## Perl [NPC]

*Source: quest-api/events/perl-npc/index.html*

# Perl [NPC]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AGGRO

```
`sub EVENT_AGGRO {
}
`
```

## EVENT_AGGRO_SAY

```
`sub EVENT_AGGRO_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_ATTACK

```
`sub EVENT_ATTACK {
}
`
```

## EVENT_CAST

```
`sub EVENT_CAST {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_BEGIN

```
`sub EVENT_CAST_BEGIN {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_ON

```
`sub EVENT_CAST_ON {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_COMBAT

```
`sub EVENT_COMBAT {
 quest::debug("combat_state " . $combat_state);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`sub EVENT_DAMAGE_GIVEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`sub EVENT_DAMAGE_TAKEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DEATH

```
`sub EVENT_DEATH {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DEATH_COMPLETE

```
`sub EVENT_DEATH_COMPLETE {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DESPAWN

```
`sub EVENT_DESPAWN {
 quest::debug("despawned_entity_id " . $despawned_entity_id);
 quest::debug("despawned_bot_id " . $despawned_bot_id);
 quest::debug("despawned_merc_id " . $despawned_merc_id);
 quest::debug("despawned_npc_id " . $despawned_npc_id);
}
`
```

## EVENT_ENTER

```
`sub EVENT_ENTER {
}
`
```

## EVENT_ENTER_AREA

```
`sub EVENT_ENTER_AREA {
 quest::debug("area_id " . $area_id);
 quest::debug("area_type " . $area_type);
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`sub EVENT_ENTITY_VARIABLE_DELETE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`sub EVENT_ENTITY_VARIABLE_SET {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`sub EVENT_ENTITY_VARIABLE_UPDATE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("old_value " . $old_value);
 quest::debug("new_value " . $new_value);
}
`
```

## EVENT_EXIT

```
`sub EVENT_EXIT {
}
`
```

## EVENT_FEIGN_DEATH

```
`sub EVENT_FEIGN_DEATH {
}
`
```

## EVENT_HATE_LIST

```
`sub EVENT_HATE_LIST {
 quest::debug("hate_state " . $hate_state);
 quest::debug("hate_entity " . $hate_entity);
}
`
```

## EVENT_HP

```
`sub EVENT_HP {
 quest::debug("hpevent " . $hpevent);
 quest::debug("inchpevent " . $inchpevent);
}
`
```

## EVENT_ITEM

```
`sub EVENT_ITEM {
 quest::debug("QuestItem " . $QuestItem);
 quest::debug("copper " . $copper);
 quest::debug("silver " . $silver);
 quest::debug("gold " . $gold);
 quest::debug("platinum " . $platinum);
}
`
```

## EVENT_KILLED_MERIT

```
`sub EVENT_KILLED_MERIT {
}
`
```

## EVENT_LEAVE_AREA

```
`sub EVENT_LEAVE_AREA {
 quest::debug("area_id " . $area_id);
 quest::debug("area_type " . $area_type);
}
`
```

## EVENT_LOOT_ADDED

```
`sub EVENT_LOOT_ADDED {
 quest::debug("item " . $item);
 quest::debug("item_id " . $item_id);
 quest::debug("item_name " . $item_name);
 quest::debug("item_charges " . $item_charges);
 quest::debug("augment_one " . $augment_one);
 quest::debug("augment_two " . $augment_two);
 quest::debug("augment_three " . $augment_three);
 quest::debug("augment_four " . $augment_four);
 quest::debug("augment_five " . $augment_five);
 quest::debug("augment_six " . $augment_six);
 quest::debug("theme_id " . $theme_id);
 quest::debug("points " . $points);
}
`
```

## EVENT_LOOT_ZONE

```
`sub EVENT_LOOT_ZONE {
 quest::debug("looted_id " . $looted_id);
 quest::debug("looted_charges " . $looted_charges);
 quest::debug("corpse_name " . $corpse_name);
 quest::debug("corpse_id " . $corpse_id);
 quest::debug("corpse " . $corpse);
}
`
```

## EVENT_NPC_SLAY

```
`sub EVENT_NPC_SLAY {
 quest::debug("killed " . $killed);
 quest::debug("killed_npc " . $killed_npc);
}
`
```

## EVENT_PAYLOAD

```
`sub EVENT_PAYLOAD {
 quest::debug("payload_id " . $payload_id);
 quest::debug("payload_value " . $payload_value);
}
`
```

## EVENT_POPUPRESPONSE

```
`sub EVENT_POPUPRESPONSE {
 quest::debug("popupid " . $popupid);
}
`
```

## EVENT_PROXIMITY_SAY

```
`sub EVENT_PROXIMITY_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_SAY

```
`sub EVENT_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_SIGNAL

```
`sub EVENT_SIGNAL {
 quest::debug("signal " . $signal);
}
`
```

## EVENT_SLAY

```
`sub EVENT_SLAY {
}
`
```

## EVENT_SPAWN

```
`sub EVENT_SPAWN {
}
`
```

## EVENT_SPELL_BLOCKED

```
`sub EVENT_SPELL_BLOCKED {
 quest::debug("blocking_spell_id " . $blocking_spell_id);
 quest::debug("cast_spell_id " . $cast_spell_id);
 quest::debug("blocking_spell " . $blocking_spell);
 quest::debug("cast_spell " . $cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`sub EVENT_TARGET_CHANGE {
 quest::debug("target " . $target);
}
`
```

## EVENT_TASKACCEPTED

```
`sub EVENT_TASKACCEPTED {
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TICK

```
`sub EVENT_TICK {
}
`
```

## EVENT_TIMER

```
`sub EVENT_TIMER {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`sub EVENT_TIMER_PAUSE {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_RESUME

```
`sub EVENT_TIMER_RESUME {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_START

```
`sub EVENT_TIMER_START {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_STOP

```
`sub EVENT_TIMER_STOP {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_WAYPOINT_ARRIVE

```
`sub EVENT_WAYPOINT_ARRIVE {
 quest::debug("wp " . $wp);
}
`
```

## EVENT_WAYPOINT_DEPART

```
`sub EVENT_WAYPOINT_DEPART {
 quest::debug("wp " . $wp);
}
`
```

---

## Perl [Player]

*Source: quest-api/events/perl-player/index.html*

# Perl [Player]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_AA_BUY

```
`sub EVENT_AA_BUY {
 quest::debug("aa_cost " . $aa_cost);
 quest::debug("aa_id " . $aa_id);
 quest::debug("aa_previous_id " . $aa_previous_id);
 quest::debug("aa_next_id " . $aa_next_id);
}
`
```

## EVENT_AA_EXP_GAIN

```
`sub EVENT_AA_EXP_GAIN {
 quest::debug("aa_exp_gained " . $aa_exp_gained);
}
`
```

## EVENT_AA_GAIN

```
`sub EVENT_AA_GAIN {
 quest::debug("aa_gained " . $aa_gained);
}
`
```

## EVENT_AA_LOSS

```
`sub EVENT_AA_LOSS {
 quest::debug("aa_lost " . $aa_lost);
}
`
```

## EVENT_ALT_CURRENCY_LOSS

```
`sub EVENT_ALT_CURRENCY_LOSS {
 quest::debug("currency_id " . $currency_id);
 quest::debug("amount " . $amount);
 quest::debug("total " . $total);
}
`
```

## EVENT_ALT_CURRENCY_MERCHANT_BUY

```
`sub EVENT_ALT_CURRENCY_MERCHANT_BUY {
 quest::debug("currency_id " . $currency_id);
 quest::debug("npc_id " . $npc_id);
 quest::debug("merchant_id " . $merchant_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_cost " . $item_cost);
}
`
```

## EVENT_ALT_CURRENCY_MERCHANT_SELL

```
`sub EVENT_ALT_CURRENCY_MERCHANT_SELL {
 quest::debug("currency_id " . $currency_id);
 quest::debug("npc_id " . $npc_id);
 quest::debug("merchant_id " . $merchant_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_cost " . $item_cost);
}
`
```

## EVENT_AUGMENT_INSERT_CLIENT

```
`sub EVENT_AUGMENT_INSERT_CLIENT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_slot " . $item_slot);
 quest::debug("augment_id " . $augment_id);
 quest::debug("augment_slot " . $augment_slot);
 quest::debug("item " . $item);
 quest::debug("augment " . $augment);
}
`
```

## EVENT_AUGMENT_REMOVE_CLIENT

```
`sub EVENT_AUGMENT_REMOVE_CLIENT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_slot " . $item_slot);
 quest::debug("augment_id " . $augment_id);
 quest::debug("augment_slot " . $augment_slot);
 quest::debug("destroyed " . $destroyed);
 quest::debug("item " . $item);
 quest::debug("augment " . $augment);
}
`
```

## EVENT_BOT_COMMAND

```
`sub EVENT_BOT_COMMAND {
 quest::debug("bot_command " . $bot_command);
 quest::debug("args " . $args);
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_BOT_CREATE

```
`sub EVENT_BOT_CREATE {
 quest::debug("bot_name " . $bot_name);
 quest::debug("bot_id " . $bot_id);
 quest::debug("bot_race " . $bot_race);
 quest::debug("bot_class " . $bot_class);
 quest::debug("bot_gender " . $bot_gender);
}
`
```

## EVENT_CAST

```
`sub EVENT_CAST {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_BEGIN

```
`sub EVENT_CAST_BEGIN {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CAST_ON

```
`sub EVENT_CAST_ON {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("caster_level " . $caster_level);
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_CLICKDOOR

```
`sub EVENT_CLICKDOOR {
 quest::debug("doorid " . $doorid);
 quest::debug("version " . $version);
 quest::debug("door " . $door);
}
`
```

## EVENT_CLICK_OBJECT

```
`sub EVENT_CLICK_OBJECT {
 quest::debug("objectid " . $objectid);
 quest::debug("clicker_id " . $clicker_id);
 quest::debug("object " . $object);
}
`
```

## EVENT_COMBINE

```
`sub EVENT_COMBINE {
 quest::debug("container_slot " . $container_slot);
}
`
```

## EVENT_COMBINE_FAILURE

```
`sub EVENT_COMBINE_FAILURE {
 quest::debug("recipe_id " . $recipe_id);
 quest::debug("recipe_name " . $recipe_name);
}
`
```

## EVENT_COMBINE_SUCCESS

```
`sub EVENT_COMBINE_SUCCESS {
 quest::debug("recipe_id " . $recipe_id);
 quest::debug("recipe_name " . $recipe_name);
}
`
```

## EVENT_COMBINE_VALIDATE

```
`sub EVENT_COMBINE_VALIDATE {
 quest::debug("recipe_id " . $recipe_id);
 quest::debug("validate_type " . $validate_type);
 quest::debug("zone_id " . $zone_id);
 quest::debug("tradeskill_id " . $tradeskill_id);
}
`
```

## EVENT_COMMAND

```
`sub EVENT_COMMAND {
 quest::debug("command " . $command);
 quest::debug("args " . $args);
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_CONNECT

```
`sub EVENT_CONNECT {
}
`
```

## EVENT_CONSIDER

```
`sub EVENT_CONSIDER {
 quest::debug("entity_id " . $entity_id);
 quest::debug("target " . $target);
}
`
```

## EVENT_CONSIDER_CORPSE

```
`sub EVENT_CONSIDER_CORPSE {
 quest::debug("corpse_entity_id " . $corpse_entity_id);
 quest::debug("corpse " . $corpse);
}
`
```

## EVENT_CRYSTAL_GAIN

```
`sub EVENT_CRYSTAL_GAIN {
 quest::debug("ebon_amount " . $ebon_amount);
 quest::debug("radiant_amount " . $radiant_amount);
 quest::debug("is_reclaim " . $is_reclaim);
}
`
```

## EVENT_CRYSTAL_LOSS

```
`sub EVENT_CRYSTAL_LOSS {
 quest::debug("ebon_amount " . $ebon_amount);
 quest::debug("radiant_amount " . $radiant_amount);
 quest::debug("is_reclaim " . $is_reclaim);
}
`
```

## EVENT_DAMAGE_GIVEN

```
`sub EVENT_DAMAGE_GIVEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DAMAGE_TAKEN

```
`sub EVENT_DAMAGE_TAKEN {
 quest::debug("entity_id " . $entity_id);
 quest::debug("damage " . $damage);
 quest::debug("spell_id " . $spell_id);
 quest::debug("skill_id " . $skill_id);
 quest::debug("is_damage_shield " . $is_damage_shield);
 quest::debug("is_avoidable " . $is_avoidable);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("is_buff_tic " . $is_buff_tic);
 quest::debug("special_attack " . $special_attack);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_DEATH

```
`sub EVENT_DEATH {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DEATH_COMPLETE

```
`sub EVENT_DEATH_COMPLETE {
 quest::debug("killer_id " . $killer_id);
 quest::debug("killer_damage " . $killer_damage);
 quest::debug("killer_spell " . $killer_spell);
 quest::debug("killer_skill " . $killer_skill);
 quest::debug("killed_entity_id " . $killed_entity_id);
 quest::debug("combat_start_time " . $combat_start_time);
 quest::debug("combat_end_time " . $combat_end_time);
 quest::debug("damage_received " . $damage_received);
 quest::debug("healing_received " . $healing_received);
 quest::debug("killed_corpse_id " . $killed_corpse_id);
 quest::debug("killed_x " . $killed_x);
 quest::debug("killed_y " . $killed_y);
 quest::debug("killed_z " . $killed_z);
 quest::debug("killed_h " . $killed_h);
 quest::debug("killed_merc_id " . $killed_merc_id);
 quest::debug("killed_npc_id " . $killed_npc_id);
}
`
```

## EVENT_DESTROY_ITEM_CLIENT

```
`sub EVENT_DESTROY_ITEM_CLIENT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_name " . $item_name);
 quest::debug("quantity " . $quantity);
 quest::debug("item " . $item);
}
`
```

## EVENT_DISCONNECT

```
`sub EVENT_DISCONNECT {
}
`
```

## EVENT_DISCOVER_ITEM

```
`sub EVENT_DISCOVER_ITEM {
 quest::debug("itemid " . $itemid);
}
`
```

## EVENT_DROP_ITEM_CLIENT

```
`sub EVENT_DROP_ITEM_CLIENT {
 quest::debug("quantity " . $quantity);
 quest::debug("item_name " . $item_name);
 quest::debug("item_id " . $item_id);
 quest::debug("spell_id " . $spell_id);
 quest::debug("slot_id " . $slot_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_DUEL_LOSE

```
`sub EVENT_DUEL_LOSE {
}
`
```

## EVENT_DUEL_WIN

```
`sub EVENT_DUEL_WIN {
}
`
```

## EVENT_ENTER

```
`sub EVENT_ENTER {
}
`
```

## EVENT_ENTER_AREA

```
`sub EVENT_ENTER_AREA {
 quest::debug("area_id " . $area_id);
 quest::debug("area_type " . $area_type);
}
`
```

## EVENT_ENTER_ZONE

```
`sub EVENT_ENTER_ZONE {
}
`
```

## EVENT_ENTITY_VARIABLE_DELETE

```
`sub EVENT_ENTITY_VARIABLE_DELETE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_SET

```
`sub EVENT_ENTITY_VARIABLE_SET {
 quest::debug("variable_name " . $variable_name);
 quest::debug("variable_value " . $variable_value);
}
`
```

## EVENT_ENTITY_VARIABLE_UPDATE

```
`sub EVENT_ENTITY_VARIABLE_UPDATE {
 quest::debug("variable_name " . $variable_name);
 quest::debug("old_value " . $old_value);
 quest::debug("new_value " . $new_value);
}
`
```

## EVENT_ENVIRONMENTAL_DAMAGE

```
`sub EVENT_ENVIRONMENTAL_DAMAGE {
 quest::debug("env_damage " . $env_damage);
 quest::debug("env_damage_type " . $env_damage_type);
 quest::debug("env_final_damage " . $env_final_damage);
}
`
```

## EVENT_EQUIP_ITEM_CLIENT

```
`sub EVENT_EQUIP_ITEM_CLIENT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("slot_id " . $slot_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_EXIT

```
`sub EVENT_EXIT {
}
`
```

## EVENT_EXP_GAIN

```
`sub EVENT_EXP_GAIN {
 quest::debug("exp_gained " . $exp_gained);
}
`
```

## EVENT_FEIGN_DEATH

```
`sub EVENT_FEIGN_DEATH {
}
`
```

## EVENT_FISH_FAILURE

```
`sub EVENT_FISH_FAILURE {
}
`
```

## EVENT_FISH_START

```
`sub EVENT_FISH_START {
}
`
```

## EVENT_FISH_SUCCESS

```
`sub EVENT_FISH_SUCCESS {
 quest::debug("fished_item " . $fished_item);
}
`
```

## EVENT_FORAGE_FAILURE

```
`sub EVENT_FORAGE_FAILURE {
}
`
```

## EVENT_FORAGE_SUCCESS

```
`sub EVENT_FORAGE_SUCCESS {
 quest::debug("foraged_item " . $foraged_item);
}
`
```

## EVENT_GM_COMMAND

```
`sub EVENT_GM_COMMAND {
 quest::debug("message " . $message);
}
`
```

## EVENT_GROUP_CHANGE

```
`sub EVENT_GROUP_CHANGE {
 quest::debug("grouped " . $grouped);
 quest::debug("raided " . $raided);
}
`
```

## EVENT_INSPECT

```
`sub EVENT_INSPECT {
 quest::debug("target_id " . $target_id);
 quest::debug("target " . $target);
}
`
```

## EVENT_ITEM_CLICK_CAST_CLIENT

```
`sub EVENT_ITEM_CLICK_CAST_CLIENT {
 quest::debug("slot_id " . $slot_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_name " . $item_name);
 quest::debug("spell_id " . $spell_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_ITEM_CLICK_CLIENT

```
`sub EVENT_ITEM_CLICK_CLIENT {
 quest::debug("slot_id " . $slot_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_name " . $item_name);
 quest::debug("spell_id " . $spell_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_LANGUAGE_SKILL_UP

```
`sub EVENT_LANGUAGE_SKILL_UP {
 quest::debug("skill_id " . $skill_id);
 quest::debug("skill_value " . $skill_value);
 quest::debug("skill_max " . $skill_max);
}
`
```

## EVENT_LEAVE_AREA

```
`sub EVENT_LEAVE_AREA {
 quest::debug("area_id " . $area_id);
 quest::debug("area_type " . $area_type);
}
`
```

## EVENT_LEVEL_DOWN

```
`sub EVENT_LEVEL_DOWN {
 quest::debug("levels_lost " . $levels_lost);
}
`
```

## EVENT_LEVEL_UP

```
`sub EVENT_LEVEL_UP {
 quest::debug("levels_gained " . $levels_gained);
}
`
```

## EVENT_LOOT

```
`sub EVENT_LOOT {
 quest::debug("looted_id " . $looted_id);
 quest::debug("looted_charges " . $looted_charges);
 quest::debug("corpse_name " . $corpse_name);
 quest::debug("corpse_id " . $corpse_id);
 quest::debug("corpse " . $corpse);
}
`
```

## EVENT_MEMORIZE_SPELL

```
`sub EVENT_MEMORIZE_SPELL {
 quest::debug("slot_id " . $slot_id);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_MERCHANT_BUY

```
`sub EVENT_MERCHANT_BUY {
 quest::debug("npc_id " . $npc_id);
 quest::debug("merchant_id " . $merchant_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("item_cost " . $item_cost);
}
`
```

## EVENT_MERCHANT_SELL

```
`sub EVENT_MERCHANT_SELL {
 quest::debug("npc_id " . $npc_id);
 quest::debug("merchant_id " . $merchant_id);
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("item_cost " . $item_cost);
}
`
```

## EVENT_PAYLOAD

```
`sub EVENT_PAYLOAD {
 quest::debug("payload_id " . $payload_id);
 quest::debug("payload_value " . $payload_value);
}
`
```

## EVENT_PLAYER_PICKUP

```
`sub EVENT_PLAYER_PICKUP {
 quest::debug("picked_up_id " . $picked_up_id);
 quest::debug("picked_up_entity_id " . $picked_up_entity_id);
}
`
```

## EVENT_POPUPRESPONSE

```
`sub EVENT_POPUPRESPONSE {
 quest::debug("popupid " . $popupid);
}
`
```

## EVENT_READ_ITEM

```
`sub EVENT_READ_ITEM {
}
`
```

## EVENT_RESPAWN

```
`sub EVENT_RESPAWN {
 quest::debug("option " . $option);
 quest::debug("resurrect " . $resurrect);
}
`
```

## EVENT_SAY

```
`sub EVENT_SAY {
 quest::debug("data " . $data);
 quest::debug("text " . $text);
 quest::debug("langid " . $langid);
}
`
```

## EVENT_SCRIBE_SPELL

```
`sub EVENT_SCRIBE_SPELL {
 quest::debug("slot_id " . $slot_id);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SIGNAL

```
`sub EVENT_SIGNAL {
 quest::debug("signal " . $signal);
}
`
```

## EVENT_SKILL_UP

```
`sub EVENT_SKILL_UP {
 quest::debug("skill_id " . $skill_id);
 quest::debug("skill_value " . $skill_value);
 quest::debug("skill_max " . $skill_max);
 quest::debug("is_tradeskill " . $is_tradeskill);
}
`
```

## EVENT_SPELL_BLOCKED

```
`sub EVENT_SPELL_BLOCKED {
 quest::debug("blocking_spell_id " . $blocking_spell_id);
 quest::debug("cast_spell_id " . $cast_spell_id);
 quest::debug("blocking_spell " . $blocking_spell);
 quest::debug("cast_spell " . $cast_spell);
}
`
```

## EVENT_TARGET_CHANGE

```
`sub EVENT_TARGET_CHANGE {
 quest::debug("target " . $target);
}
`
```

## EVENT_TASKACCEPTED

```
`sub EVENT_TASKACCEPTED {
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TASK_BEFORE_UPDATE

```
`sub EVENT_TASK_BEFORE_UPDATE {
 quest::debug("donecount " . $donecount);
 quest::debug("activity_id " . $activity_id);
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TASK_COMPLETE

```
`sub EVENT_TASK_COMPLETE {
 quest::debug("donecount " . $donecount);
 quest::debug("activity_id " . $activity_id);
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TASK_FAIL

```
`sub EVENT_TASK_FAIL {
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TASK_STAGE_COMPLETE

```
`sub EVENT_TASK_STAGE_COMPLETE {
 quest::debug("task_id " . $task_id);
 quest::debug("activity_id " . $activity_id);
}
`
```

## EVENT_TASK_UPDATE

```
`sub EVENT_TASK_UPDATE {
 quest::debug("donecount " . $donecount);
 quest::debug("activity_id " . $activity_id);
 quest::debug("task_id " . $task_id);
}
`
```

## EVENT_TEST_BUFF

```
`sub EVENT_TEST_BUFF {
}
`
```

## EVENT_TIMER

```
`sub EVENT_TIMER {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_TIMER_PAUSE

```
`sub EVENT_TIMER_PAUSE {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_RESUME

```
`sub EVENT_TIMER_RESUME {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_START

```
`sub EVENT_TIMER_START {
 quest::debug("timer " . $timer);
 quest::debug("duration " . $duration);
}
`
```

## EVENT_TIMER_STOP

```
`sub EVENT_TIMER_STOP {
 quest::debug("timer " . $timer);
}
`
```

## EVENT_UNEQUIP_ITEM_CLIENT

```
`sub EVENT_UNEQUIP_ITEM_CLIENT {
 quest::debug("item_id " . $item_id);
 quest::debug("item_quantity " . $item_quantity);
 quest::debug("slot_id " . $slot_id);
 quest::debug("item " . $item);
}
`
```

## EVENT_UNHANDLED_OPCODE

```
`sub EVENT_UNHANDLED_OPCODE {
}
`
```

## EVENT_UNMEMORIZE_SPELL

```
`sub EVENT_UNMEMORIZE_SPELL {
 quest::debug("slot_id " . $slot_id);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_UNSCRIBE_SPELL

```
`sub EVENT_UNSCRIBE_SPELL {
 quest::debug("slot_id " . $slot_id);
 quest::debug("spell_id " . $spell_id);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_USE_SKILL

```
`sub EVENT_USE_SKILL {
 quest::debug("skill_id " . $skill_id);
 quest::debug("skill_level " . $skill_level);
}
`
```

## EVENT_WARP

```
`sub EVENT_WARP {
 quest::debug("from_x " . $from_x);
 quest::debug("from_y " . $from_y);
 quest::debug("from_z " . $from_z);
}
`
```

## EVENT_ZONE

```
`sub EVENT_ZONE {
 quest::debug("from_zone_id " . $from_zone_id);
 quest::debug("from_instance_id " . $from_instance_id);
 quest::debug("from_instance_version " . $from_instance_version);
 quest::debug("target_zone_id " . $target_zone_id);
 quest::debug("target_instance_id " . $target_instance_id);
 quest::debug("target_instance_version " . $target_instance_version);
}
`
```

---

## Perl [Spell]

*Source: quest-api/events/perl-spell/index.html*

# Perl [Spell]

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

## EVENT_SPELL_EFFECT_BOT

```
`sub EVENT_SPELL_EFFECT_BOT {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_BUFF_TIC_BOT

```
`sub EVENT_SPELL_EFFECT_BUFF_TIC_BOT {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_BUFF_TIC_CLIENT

```
`sub EVENT_SPELL_EFFECT_BUFF_TIC_CLIENT {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_BUFF_TIC_NPC

```
`sub EVENT_SPELL_EFFECT_BUFF_TIC_NPC {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_CLIENT

```
`sub EVENT_SPELL_EFFECT_CLIENT {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_NPC

```
`sub EVENT_SPELL_EFFECT_NPC {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

## EVENT_SPELL_EFFECT_TRANSLOCATE_COMPLETE

```
`sub EVENT_SPELL_EFFECT_TRANSLOCATE_COMPLETE {
}
`
```

## EVENT_SPELL_FADE

```
`sub EVENT_SPELL_FADE {
 quest::debug("spell_id " . $spell_id);
 quest::debug("caster_id " . $caster_id);
 quest::debug("tics_remaining " . $tics_remaining);
 quest::debug("caster_level " . $caster_level);
 quest::debug("buff_slot " . $buff_slot);
 quest::debug("spell " . $spell);
}
`
```

---

## Introduction

*Source: quest-api/introduction/index.html*

# Introduction

New to EQEmulator? New to scripting? No worries - many people have started their Quest learning how to program in this community through building scripts.

Scripts can be leveraged to build an endless amount customization. 

Some examples might be custom boss events, NPC dialogue, custom spell behavior, custom tradeskills and so many more.

## Scripting Engines

EverQuest Emulator supports two scripting languages, Perl and Lua.

Perl was introduced in the early 2000's and has been the first language still used by many and is still supported today.

Lua was introduced to EverQuest Emulator in 2013 as a newer language with modern support, easier C++ integration and bindings as well as more features in the Quest API.

## Learning

If you are new to scripting, you might want to learn some basics and primitives. Both languages share many basics such as conditionals, operators, iterators, arrays, loops etc.

Below are some beginner friendly tutorial sites that can get you started if you are new, they may even be helpful if you are already familiar with programming but maybe not familiar with Perl or Lua.

| 

Learning Resource 
| Link 

| Perl Tutorial (Tizag) 
| Tizag 

| Lua Tutorial (tutorialspoint) 
| Tutorialspoint 

## What Language Should I Choose?

What language you use is entirely up to you and your preference.

Lua is more modern with more features and is the chosen language in ProjectEQ Quests Repo however it makes no difference what you choose to use.

Choice comes down to personal preference, however your personal preference may be influenced by some features and capabilities that are unique to each. You will need to figure that for yourself over time.

## Features

If you're new, you might be wondering what are the kinds of things you can do with scripts

- 1,000+ API methods

- 100+ custom events

The short answer is there is almost nothing you can't do. The possibilities are endless, but to give you some ideas. 

- Custom item hand in events

- Custom tradeskills

- Custom dialogue windows

- Custom spells

- Custom boss and encounter events

- Changing weather, environment, time

- NPC dialogue, emotes etc

- Setting and reading character flags

- Task manipulation

- More...

---

## Bot

*Source: quest-api/methods/bot/index.html*

# Bot

Perl (111)Lua (118)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1, uint32 aug2);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1, uint32 aug2, uint32 aug3);
$bot->AddBotItem(uint16 slot_id, uint32 item_id, uint16 charges, bool attuned, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
$bot->AddBotItem(uint16 slot_id, uint32 item_id);
$bot->AddItem(reference table_ref);
$bot->ApplySpell(int spell_id);
$bot->ApplySpell(int spell_id, int duration);
$bot->ApplySpell(int spell_id, int duration, int level);
$bot->ApplySpell(int spell_id, int duration, int level, bool allow_pets);
$bot->ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets);
$bot->ApplySpellGroup(int spell_id);
$bot->ApplySpellGroup(int spell_id, int duration);
$bot->ApplySpellGroup(int spell_id, int duration, int level);
$bot->ApplySpellRaid(int spell_id, int duration, int level);
$bot->ApplySpellRaid(int spell_id);
$bot->ApplySpellRaid(int spell_id, int duration);
$bot->ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets);
$bot->ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
$bot->Camp(bool save_to_database);
$bot->Camp();
$bot->ClearDisciplineReuseTimer();
$bot->ClearDisciplineReuseTimer(uint16 spell_id);
$bot->ClearItemReuseTimer(uint32 item_id);
$bot->ClearItemReuseTimer();
$bot->ClearSpellRecastTimer(uint16 spell_id);
$bot->ClearSpellRecastTimer();
$bot->CountAugmentEquippedByID(uint32 item_id);
$bot->CountBotItem(item_id);
$bot->CountItemEquippedByID(uint32 item_id);
$bot->DeleteBot();
$bot->Escape();
$bot->Fling(float target_x, float target_y, float target_z, bool ignore_los);
$bot->Fling(float value, float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
$bot->Fling(float value, float target_x, float target_y, float target_z, bool ignore_los);
$bot->Fling(float value, float target_x, float target_y, float target_z);
$bot->Fling(float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
$bot->Fling(float target_x, float target_y, float target_z);
$bot->GetAugmentAt(int16 slot_id, uint8 augment_index);
$bot->GetAugmentIDAt(int16 slot_id, uint8 aug_slot);
$bot->GetAugmentIDsBySlotID(int16 slot_id);
$bot->GetBaseAGI();
$bot->GetBaseCHA();
$bot->GetBaseDEX();
$bot->GetBaseINT();
$bot->GetBaseSTA();
$bot->GetBaseSTR();
$bot->GetBaseWIS();
$bot->GetBotID();
$bot->GetBotItem(uint16 slot_id);
$bot->GetBotItemIDBySlot(uint16 slot_id);
$bot->GetClassAbbreviation();
$bot->GetDisciplineReuseTimer(uint16 spell_id);
$bot->GetDisciplineReuseTimer();
$bot->GetExpansionBitmask();
$bot->GetGroup();
$bot->GetHealAmount();
$bot->GetInstrumentMod(uint16 spell_id);
$bot->GetItemAt(int16 slot_id);
$bot->GetItemIDAt(int16 slot_id);
$bot->GetItemReuseTimer();
$bot->GetItemReuseTimer(item_id);
$bot->GetOwner();
$bot->GetRaceAbbreviation();
$bot->GetRawItemAC();
$bot->GetSpellDamage();
$bot->GetSpellRecastTimer();
$bot->GetSpellRecastTimer(uint16 spell_id);
$bot->HasAugmentEquippedByID(uint32 item_id);
$bot->HasBotItem(uint32 item_id);
$bot->HasBotSpellEntry(uint16 spellid);
$bot->IsGrouped();
$bot->IsSitting();
$bot->IsStanding();
$bot->OwnerMessage(string message);
$bot->ReloadBotDataBuckets();
$bot->ReloadBotOwnerDataBuckets();
$bot->ReloadBotSpellSettings();
$bot->ReloadBotSpells();
$bot->RemoveBotItem(uint32 item_id);
$bot->SendPayload(int payload_id, string payload_value);
$bot->SendPayload(int payload_id);
$bot->SendSpellAnim(uint16 target_id, uint16 spell_id);
$bot->SetDisciplineReuseTimer(uint16 spell_id, uint32 recast_delay);
$bot->SetDisciplineReuseTimer(uint16 spell_id);
$bot->SetExpansionBitmask(int expansion_bitmask, bool save);
$bot->SetExpansionBitmask(int expansion_bitmask);
$bot->SetItemReuseTimer(uint32 item_id);
$bot->SetItemReuseTimer(uint32 item_id, uint32 reuse_timer);
$bot->SetSpellDuration(int spell_id, int duration);
$bot->SetSpellDuration(int spell_id);
$bot->SetSpellDuration(int spell_id, int duration, int level);
$bot->SetSpellDuration(int spell_id, int duration, int level, bool allow_pets);
$bot->SetSpellDurationGroup(int spell_id, int duration);
$bot->SetSpellDurationGroup(int spell_id);
$bot->SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets);
$bot->SetSpellDurationGroup(int spell_id, int duration, int level);
$bot->SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets);
$bot->SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
$bot->SetSpellDurationRaid(int spell_id, int duration, int level);
$bot->SetSpellDurationRaid(int spell_id, int duration);
$bot->SetSpellDurationRaid(int spell_id);
$bot->SetSpellRecastTimer(uint16 spell_id, uint32 recast_delay);
$bot->SetSpellRecastTimer(uint16 spell_id);
$bot->Signal(int signal_id);
$bot->Sit();
$bot->Stand();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`bot:AddBotItem(uint16 slot_id, uint32 item_id);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one, uint32 augment_two);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one, uint32 augment_two, uint32 augment_three);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four, uint32 augment_five);
bot:AddBotItem(uint16 slot_id, uint32 item_id, int16 charges, bool attuned, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four, uint32 augment_five, uint32 augment_six);
bot:AddItem(const object& item_table);
bot:ApplySpell(int spell_id, int duration);
bot:ApplySpell(int spell_id, int duration, int level);
bot:ApplySpell(int spell_id);
bot:ApplySpell(int spell_id, int duration, int level, bool allow_pets);
bot:ApplySpellGroup(int spell_id, int duration);
bot:ApplySpellGroup(int spell_id);
bot:ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets);
bot:ApplySpellGroup(int spell_id, int duration, int level);
bot:ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
bot:ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets);
bot:ApplySpellRaid(int spell_id, int duration, int level);
bot:ApplySpellRaid(int spell_id);
bot:ApplySpellRaid(int spell_id, int duration);
bot:Camp();
bot:Camp(bool save_to_database);
bot:ClearDisciplineReuseTimer(uint16 spell_id);
bot:ClearDisciplineReuseTimer();
bot:ClearItemReuseTimer();
bot:ClearItemReuseTimer(uint32 item_id);
bot:ClearSpellRecastTimer();
bot:ClearSpellRecastTimer(uint16 spell_id);
bot:CountAugmentEquippedByID(uint32 item_id);
bot:CountBotItem(item_id);
bot:CountItemEquippedByID(uint32 item_id);
bot:DeleteBot();
bot:DeleteBucket(string bucket_name);
bot:Escape();
bot:Fling(float target_x, float target_y, float target_z, bool ignore_los);
bot:Fling(float value, float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
bot:Fling(float value, float target_x, float target_y, float target_z, bool ignore_los);
bot:Fling(float value, float target_x, float target_y, float target_z);
bot:Fling(float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
bot:Fling(float target_x, float target_y, float target_z);
bot:GetAugmentAt(int16 slot_id, uint8 augment_index);
bot:GetAugmentIDAt(int16 slot_id, uint8 augment_index);
bot:GetAugmentIDsBySlotID(int16 slot_id);
bot:GetBaseAGI();
bot:GetBaseCHA();
bot:GetBaseDEX();
bot:GetBaseINT();
bot:GetBaseSTA();
bot:GetBaseSTR();
bot:GetBaseWIS();
bot:GetBotID();
bot:GetBotItem(uint16 slot_id);
bot:GetBotItemIDBySlot(uint16 slot_id);
bot:GetBucket(bucket_name);
bot:GetBucketExpires(bucket_name);
bot:GetBucketRemaining(bucket_name);
bot:GetClassAbbreviation();
bot:GetDisciplineReuseTimer(uint16 spell_id);
bot:GetDisciplineReuseTimer();
bot:GetExpansionBitmask();
bot:GetGroup();
bot:GetHealAmount();
bot:GetInstrumentMod(spell_id);
bot:GetItemAt(int16 slot_id // @categories Inventory and Items);
bot:GetItemIDAt(int16 slot_id);
bot:GetItemReuseTimer(item_id);
bot:GetItemReuseTimer();
bot:GetOwner();
bot:GetRaceAbbreviation();
bot:GetRawItemAC();
bot:GetSpellDamage();
bot:GetSpellRecastTimer();
bot:GetSpellRecastTimer(uint16 spell_id);
bot:HasAugmentEquippedByID(uint32 item_id);
bot:HasBotItem(uint32 item_id);
bot:HasBotSpellEntry(uint16 spellid);
bot:HasItemEquippedByID(uint32 item_id);
bot:IsGrouped();
bot:IsSitting();
bot:IsStanding();
bot:OwnerMessage(string message);
bot:ReloadBotDataBuckets();
bot:ReloadBotOwnerDataBuckets();
bot:ReloadBotSpellSettings();
bot:ReloadBotSpells();
bot:RemoveBotItem(uint32 item_id);
bot:SendPayload(int payload_id, string payload_value);
bot:SendPayload(int payload_id);
bot:SendSpellAnim(uint16 target_id, uint16 spell_id);
bot:SetBucket(string bucket_name, string bucket_value);
bot:SetBucket(string bucket_name, string bucket_value, string expiration);
bot:SetDisciplineReuseTimer(uint16 spell_id, uint32 reuse_timer);
bot:SetDisciplineReuseTimer(uint16 spell_id);
bot:SetExpansionBitmask(int expansion_bitmask, bool save);
bot:SetExpansionBitmask(int expansion_bitmask);
bot:SetItemReuseTimer(uint32 item_id, uint32 reuse_timer);
bot:SetItemReuseTimer(uint32 item_id);
bot:SetSpellDuration(int spell_id);
bot:SetSpellDuration(int spell_id, int duration, int level, bool allow_pets);
bot:SetSpellDuration(int spell_id, int duration, int level);
bot:SetSpellDuration(int spell_id, int duration);
bot:SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets);
bot:SetSpellDurationGroup(int spell_id);
bot:SetSpellDurationGroup(int spell_id, int duration);
bot:SetSpellDurationGroup(int spell_id, int duration, int level);
bot:SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets);
bot:SetSpellDurationRaid(int spell_id);
bot:SetSpellDurationRaid(int spell_id, int duration);
bot:SetSpellDurationRaid(int spell_id, int duration, int level);
bot:SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
bot:SetSpellRecastTimer(uint16 spell_id, uint32 recast_delay);
bot:SetSpellRecastTimer(uint16 spell_id);
bot:Signal(int signal_id);
bot:Sit();
bot:Stand();
`
```

---

## Buff

*Source: quest-api/methods/buff/index.html*

# Buff

Perl (20)Lua (20)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$buff->GetCastOnX();
$buff->GetCastOnY();
$buff->GetCastOnZ();
$buff->GetCasterID();
$buff->GetCasterLevel();
$buff->GetCasterName();
$buff->GetCounters();
$buff->GetDOTRune();
$buff->GetExtraDIChance();
$buff->GetInstrumentModifier();
$buff->GetMagicRune();
$buff->GetMeleeRune();
$buff->GetNumberOfHits();
$buff->GetRootBreakChance();
$buff->GetSpellID();
$buff->GetTicsRemaining();
$buff->GetVirusSpreadTime();
$buff->IsCasterClient();
$buff->IsPersistentBuff();
$buff->SendsClientUpdate();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`buff:GetCastOnX();
buff:GetCastOnY();
buff:GetCastOnZ();
buff:GetCasterID();
buff:GetCasterLevel();
buff:GetCasterName();
buff:GetCounters();
buff:GetDOTRune();
buff:GetExtraDIChance();
buff:GetInstrumentModifier();
buff:GetMagicRune();
buff:GetMeleeRune();
buff:GetNumberOfHits();
buff:GetRootBreakChance();
buff:GetSpellID();
buff:GetTicsRemaining();
buff:GetVirusSpreadTime();
buff:IsCasterClient();
buff:IsPersistentBuff();
buff:SendsClientUpdate();
`
```

---

## Client

*Source: quest-api/methods/client/index.html*

# Client

Perl (566)Lua (563)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$client->AccountID();
$client->AccountName();
$client->AddAAPoints(uint32 points);
$client->AddAlternateCurrencyValue(uint32 currency_id, int amount);
$client->AddCrystals(uint32 radiant_count, uint32 ebon_count);
$client->AddEXP(uint32 add_exp);
$client->AddEXP(uint32 add_exp, uint8 conlevel, bool resexp);
$client->AddEXP(uint32 add_exp, uint8 conlevel);
$client->AddEbonCrystals(uint32 amount);
$client->AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds);
$client->AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid);
$client->AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds);
$client->AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid);
$client->AddItem(reference table_ref);
$client->AddLDoNLoss(uint32 theme_id);
$client->AddLDoNWin(uint32 theme_id);
$client->AddLevelBasedExp(uint8 exp_percentage, uint8 max_level, bool ignore_mods);
$client->AddLevelBasedExp(uint8 exp_percentage, uint8 max_level);
$client->AddLevelBasedExp(uint8 exp_percentage);
$client->AddMoneyToPP(uint32 copper, uint32 silver, uint32 gold, uint32 platinum, bool update_client);
$client->AddMoneyToPP(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
$client->AddPVPPoints(uint32 points);
$client->AddPlatinum(uint32 platinum, bool update_client);
$client->AddPlatinum(uint32 platinum);
$client->AddRadiantCrystals(uint32 amount);
$client->AddSkill(int skill_id, uint16 value);
$client->Admin();
$client->ApplySpell(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
$client->ApplySpell(int spell_id, int duration, int level, bool allow_pets);
$client->ApplySpell(int spell_id, int duration, int level);
$client->ApplySpell(int spell_id, int duration);
$client->ApplySpell(int spell_id);
$client->ApplySpellGroup(int spell_id);
$client->ApplySpellGroup(int spell_id, int duration);
$client->ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
$client->ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets);
$client->ApplySpellGroup(int spell_id, int duration, int level);
$client->ApplySpellRaid(int spell_id, int duration);
$client->ApplySpellRaid(int spell_id, int duration, int level);
$client->ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets);
$client->ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
$client->ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only, bool allow_bots);
$client->ApplySpellRaid(int spell_id);
$client->AreTasksCompleted(array task_ids);
$client->AreaTaunt();
$client->AreaTaunt(float range);
$client->AreaTaunt(float range, int bonus_hate);
$client->AssignTask(int task_id, int npc_id, bool enforce_level_requirement);
$client->AssignTask(int task_id, int npc_id);
$client->AssignTask(int task_id);
$client->AssignToInstance(uint16 instance_id);
$client->AutoSplitEnabled();
$client->BreakInvis();
$client->CalcEXP(uint8 consider_level, bool ignore_modifiers);
$client->CalcEXP(uint8 consider_level);
$client->CalcPriceMod(Mob* other);
$client->CalcPriceMod(Mob* other, bool reverse);
$client->CalcPriceMod();
$client->CampAllBots(uint8 class_id);
$client->CampAllBots();
$client->CanEnterZone(string zone_short_name);
$client->CanEnterZone(string zone_short_name, int16 instance_version);
$client->CanHaveSkill(int skill_id);
$client->CashReward(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
$client->ChangeLastName(string last_name);
$client->CharacterID();
$client->CheckIncreaseSkill(int skill_id, int chance_modifier);
$client->CheckIncreaseSkill(int skill_id);
$client->CheckSpecializeIncrease(uint16 spell_id);
$client->ClearAccountFlag(string flag);
$client->ClearCompassMark();
$client->ClearPEQZoneFlag(uint32 zone_id);
$client->ClearXTargets();
$client->ClearZoneFlag(uint32 zone_id);
$client->Connected();
$client->CountAugmentEquippedByID(uint32 item_id);
$client->CountItem(uint32 item_id);
$client->CountItemEquippedByID(uint32 item_id);
$client->CreateExpedition(string zone_name, uint32 version, uint32 duration, string expedition_name, uint32 min_players, uint32 max_players);
$client->CreateExpedition(reference table_ref);
$client->CreateExpedition(string zone_name, uint32 version, uint32 duration, string expedition_name, uint32 min_players, uint32 max_players, bool disable_messages);
$client->CreateExpeditionFromTemplate(uint32_t dz_template_id);
$client->CreateTaskDynamicZone(int task_id, reference table_ref);
$client->DecreaseByID(uint32 type, int16 quantity);
$client->DeleteItemInInventory(int16 slot_id, int16 quantity);
$client->DeleteItemInInventory(int16 slot_id);
$client->DeleteItemInInventory(int16 slot_id, int16 quantity, bool client_update);
$client->DescribeSpecialAbilities(NPC* n);
$client->DiaWind(string window_markdown);
$client->DialogueWindow(string window_markdown);
$client->Disconnect();
$client->DropItem(int16 slot_id);
$client->Duck();
$client->DyeArmorBySlot(uint8 slot, uint8 red, uint8 green, uint8 blue, uint8 use_tint);
$client->DyeArmorBySlot(uint8 slot, uint8 red, uint8 green, uint8 blue);
$client->EndSharedTask();
$client->EndSharedTask(bool send_fail);
$client->Escape();
$client->ExpeditionMessage(int expedition_id, string message);
$client->FailTask(int task_id);
$client->FindEmptyMemSlot();
$client->FindMemmedSpellBySlot(slot);
$client->FindMemmedSpellBySpellID(uint16 spell_id);
$client->Fling(float target_x, float target_y, float target_z, bool ignore_los);
$client->Fling(float value, float target_x, float target_y, float target_z);
$client->Fling(float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
$client->Fling(float value, float target_x, float target_y, float target_z, bool ignore_los);
$client->Fling(float value, float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
$client->Fling(float target_x, float target_y, float target_z);
$client->ForageItem();
$client->Freeze();
$client->GMKill();
$client->GetAAEXPModifier();
$client->GetAAEXPModifier(uint32 zone_id);
$client->GetAAEXPModifier(uint32 zone_id, int16 instance_version);
$client->GetAAEXPPercentage();
$client->GetAAExp();
$client->GetAALevel(uint32 aa_skill_id);
$client->GetAAPercent();
$client->GetAAPoints();
$client->GetAFK();
$client->GetAccountAge();
$client->GetAccountFlag(flag);
$client->GetAccountFlags();
$client->GetAggroCount();
$client->GetAllMoney();
$client->GetAlternateCurrencyValue(uint32_t currency_id);
$client->GetAnon();
$client->GetAugmentAt(uint32 slot, uint32 aug_slot);
$client->GetAugmentIDAt(int16 slot_id, uint8 aug_slot);
$client->GetAugmentIDsBySlotID(int16 slot_id);
$client->GetAutoLoginCharacterName();
$client->GetBaseAGI();
$client->GetBaseCHA();
$client->GetBaseDEX();
$client->GetBaseFace();
$client->GetBaseINT();
$client->GetBaseSTA();
$client->GetBaseSTR();
$client->GetBaseWIS();
$client->GetBecomeNPCLevel();
$client->GetBindHeading(int index);
$client->GetBindHeading();
$client->GetBindX();
$client->GetBindX(int index);
$client->GetBindY(int index);
$client->GetBindY();
$client->GetBindZ(int index);
$client->GetBindZ();
$client->GetBindZoneID(int index);
$client->GetBindZoneID();
$client->GetBotCreationLimit(uint8 class_id);
$client->GetBotCreationLimit();
$client->GetBotRequiredLevel(uint8 class_id);
$client->GetBotRequiredLevel();
$client->GetBotSpawnLimit();
$client->GetBotSpawnLimit(uint8 class_id);
$client->GetCarriedMoney();
$client->GetCarriedPlatinum();
$client->GetCharacterFactionLevel(faction_id);
$client->GetClassAbbreviation();
$client->GetClassBitmask();
$client->GetClientMaxLevel();
$client->GetClientVersion();
$client->GetClientVersionBit();
$client->GetCorpseCount();
$client->GetCorpseID(uint8 corpse);
$client->GetCorpseItemAt(uint32 corpse_id, uint16 slot_id);
$client->GetCustomItemData(int16 slot_id, identifier);
$client->GetDeityBitmask();
$client->GetDiscSlotBySpellID(spell_id);
$client->GetDisciplineTimer(uint32 timer_id);
$client->GetDuelTarget();
$client->GetEXP();
$client->GetEXPForLevel(uint16 check_level);
$client->GetEXPModifier();
$client->GetEXPModifier(uint32 zone_id);
$client->GetEXPModifier(uint32 zone_id, int16 instance_version);
$client->GetEXPPercentage();
$client->GetEbonCrystals();
$client->GetEndurance();
$client->GetEnduranceRatio();
$client->GetEnvironmentDamageModifier();
$client->GetExpedition();
$client->GetExpeditionLockouts(string expedition_name);
$client->GetExpeditionLockouts();
$client->GetFace();
$client->GetFactionLevel(uint32 char_id, uint32 npc_id, uint32 race_id, uint32 class_id, uint32 deity_id, uint32 faction_id, Mob* tnpc);
$client->GetFeigned();
$client->GetFreeDisciplineSlot(starting_slot);
$client->GetFreeDisciplineSlot();
$client->GetFreeSpellBookSlot(uint32 start_slot);
$client->GetFreeSpellBookSlot();
$client->GetGM();
$client->GetGMStatus();
$client->GetGroup();
$client->GetGroupPoints();
$client->GetGuildPublicNote();
$client->GetHealAmount();
$client->GetHorseId();
$client->GetHunger();
$client->GetIP();
$client->GetIPExemption();
$client->GetIPString();
$client->GetInstanceID();
$client->GetInstrumentMod(uint16 spell_id);
$client->GetIntoxication();
$client->GetInventory();
$client->GetInvulnerableEnvironmentDamage();
$client->GetItemAt(uint32 slot);
$client->GetItemCooldown(item_id);
$client->GetItemIDAt(int16 slot_id);
$client->GetItemInInventory(int16 slot_id);
$client->GetLDoNLosses();
$client->GetLDoNLossesTheme(theme);
$client->GetLDoNPointsTheme(int theme);
$client->GetLDoNWins();
$client->GetLDoNWinsTheme(theme);
$client->GetLanguageSkill(uint16 lanuage_id);
$client->GetLearnableDisciplines(uint8 min_level);
$client->GetLearnableDisciplines();
$client->GetLearnableDisciplines(uint8 min_level, uint8 max_level);
$client->GetLearnedDisciplines();
$client->GetLockoutExpeditionUUID(expedition_name, event_name);
$client->GetMaxEndurance();
$client->GetMemmedSpells();
$client->GetMerc();
$client->GetModCharacterFactionLevel(faction_id);
$client->GetMoney(int8 type, int8 subtype);
$client->GetPEQZoneFlags();
$client->GetPVP();
$client->GetPVPPoints();
$client->GetRaceAbbreviation();
$client->GetRaceBitmask();
$client->GetRadiantCrystals();
$client->GetRaid();
$client->GetRaidOrGroupOrSelf();
$client->GetRaidOrGroupOrSelf(bool clients_only);
$client->GetRaidPoints();
$client->GetRawItemAC();
$client->GetRawSkill(int skill_id);
$client->GetRecipeMadeCount(uint32 recipe_id);
$client->GetScribeableSpells(uint8 min_level, uint8 max_level);
$client->GetScribeableSpells();
$client->GetScribeableSpells(uint8 min_level);
$client->GetScribedSpells();
$client->GetSkillPoints();
$client->GetSkillTrainLevel(int skill_id);
$client->GetSpellBookSlotBySpellID(uint32 spell_id);
$client->GetSpellDamage();
$client->GetSpellIDByBookSlot(int slot_id);
$client->GetSpentAA();
$client->GetStartZone();
$client->GetTargetRingX();
$client->GetTargetRingY();
$client->GetTargetRingZ();
$client->GetTaskActivityDoneCount(task_id, activity_id);
$client->GetThirst();
$client->GetTotalSecondsPlayed();
$client->GetWeight();
$client->GetZoneFlags();
$client->GoFish();
$client->GrantAllAAPoints();
$client->GrantAllAAPoints(uint8 unlock_level);
$client->GrantAllAAPoints(uint8 unlock_level, bool skip_grant_only);
$client->GrantAlternateAdvancementAbility(int aa_id, int points);
$client->GrantAlternateAdvancementAbility(int aa_id, int points, ignore_cost);
$client->GuildID();
$client->GuildRank();
$client->HasAugmentEquippedByID(uint32 item_id);
$client->HasDisciplineLearned(uint16 spell_id);
$client->HasExpeditionLockout(string expedition_name, string event_name);
$client->HasItemEquippedByID(uint32 item_id);
$client->HasItemOnCorpse(uint32 item_id);
$client->HasPEQZoneFlag(uint32 zone_id);
$client->HasRecipeLearned(uint32 recipe_id);
$client->HasSkill(int skill_id);
$client->HasSpellScribed(int spell_id);
$client->HasZoneFlag(uint32 zone_id);
$client->Hungry();
$client->InZone();
$client->IncStats(uint8 type, uint16 increase_val);
$client->IncreaseLanguageSkill(uint8 language_id);
$client->IncreaseLanguageSkill(uint8 language_id, uint8 increase);
$client->IncreaseSkill(int skill_id, int value);
$client->IncreaseSkill(int skill_id);
$client->IncrementAA(uint32 aa_skill_id);
$client->IsAutoAttackEnabled();
$client->IsAutoFireEnabled();
$client->IsBecomeNPC();
$client->IsCrouching();
$client->IsDueling();
$client->IsEXPEnabled();
$client->IsGrouped();
$client->IsInAGuild();
$client->IsLD();
$client->IsMedding();
$client->IsRaidGrouped();
$client->IsSitting();
$client->IsStanding();
$client->IsTaskActive(int task_id);
$client->IsTaskActivityActive(int task_id, int activity_id);
$client->IsTaskCompleted(int task_id);
$client->KeyRingAdd(uint32 item_id);
$client->KeyRingCheck(uint32 item_id);
$client->Kick();
$client->LearnDisciplines(uint8 min_level, uint8 max_level);
$client->LearnRecipe(uint32 recipe_id);
$client->LeaveGroup();
$client->LoadPEQZoneFlags();
$client->LoadZoneFlags();
$client->LockSharedTask(bool lock);
$client->MarkCompassLoc(float x, float y, float z);
$client->MaxSkill(uint16 skill_id, uint16 class_id);
$client->MaxSkill(uint16 skill_id, uint16 class_id, uint16 level);
$client->MaxSkill(uint16 skill_id);
$client->MaxSkills();
$client->MemSpell(uint16 spell_id, int slot, bool update_client);
$client->MemSpell(uint16 spell_id, int slot);
$client->MemmedCount();
$client->MovePC(uint32 zone_id, float x, float y, float z, float heading);
$client->MovePCDynamicZone(scalar zone, int zone_version, bool msg_if_invalid);
$client->MovePCDynamicZone(scalar zone, int zone_version);
$client->MovePCDynamicZone(scalar zone);
$client->MovePCInstance(uint32 zone_id, uint32 instance_id, float x, float y, float z, float heading);
$client->MoveZone(string zone_short_name, float x, float y, float z, float heading);
$client->MoveZone(string zone_short_name, float x, float y, float z);
$client->MoveZone(string zone_short_name);
$client->MoveZoneGroup(string zone_short_name);
$client->MoveZoneGroup(string zone_short_name, float x, float y, float z);
$client->MoveZoneGroup(string zone_short_name, float x, float y, float z, float heading);
$client->MoveZoneInstance(uint16 instance_id, float x, float y, float z);
$client->MoveZoneInstance(uint16 instance_id);
$client->MoveZoneInstance(uint16 instance_id, float x, float y, float z, float heading);
$client->MoveZoneInstanceGroup(uint16 instance_id);
$client->MoveZoneInstanceGroup(uint16 instance_id, float x, float y, float z);
$client->MoveZoneInstanceGroup(uint16 instance_id, float x, float y, float z, float heading);
$client->MoveZoneInstanceRaid(uint16 instance_id);
$client->MoveZoneInstanceRaid(uint16 instance_id, float x, float y, float z, float heading);
$client->MoveZoneInstanceRaid(uint16 instance_id, float x, float y, float z);
$client->MoveZoneRaid(string zone_short_name, float x, float y, float z);
$client->MoveZoneRaid(string zone_short_name);
$client->MoveZoneRaid(string zone_short_name, float x, float y, float z, float heading);
$client->NPCSpawn(NPC* target_npc, string option);
$client->NPCSpawn(NPC* target_npc, string option, uint32 respawn_time);
$client->NotifyNewTitlesAvailable();
$client->NukeItem(item_id);
$client->NukeItem(item_id, uint8 slot_to_check);
$client->OpenLFGuildWindow();
$client->PlayMP3(string file);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id, uint32 buttons, uint32 duration, string button_name_0);
$client->Popup2(string title, string text);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id, uint32 buttons, uint32 duration, string button_name_0, string button_name_1);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id, uint32 buttons);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id);
$client->Popup2(string title, string text, uint32 popup_id);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id, uint32 buttons, uint32 duration);
$client->Popup2(string title, string text, uint32 popup_id, uint32 negative_id, uint32 buttons, uint32 duration, string button_name_0, string button_name_1, uint32 sound_controls);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 item_id, uint32 exp);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver);
$client->QuestReward(Mob* mob, uint32 copper);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 item_id, uint32 exp, bool faction);
$client->QuestReward(Mob* mob);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 item_id);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
$client->QuestReward(Mob* mob, uint32 copper, uint32 silver, uint32 gold);
$client->ReadBook(string book_text, uint8 type);
$client->ReadBookByName(string book_name, uint8 book_type);
$client->RefundAA();
$client->ReloadDataBuckets();
$client->RemoveAAPoints(uint32 points);
$client->RemoveAllExpeditionLockouts();
$client->RemoveAllExpeditionLockouts(string expedition_name);
$client->RemoveAlternateCurrencyValue(uint32 currency_id, uint32 amount);
$client->RemoveEbonCrystals(uint32 amount);
$client->RemoveExpeditionLockout(string expedition_name, string event_name);
$client->RemoveFromInstance(uint16 instance_id);
$client->RemoveItem(uint32 item_id, uint32 quantity);
$client->RemoveItem(uint32 item_id);
$client->RemoveLDoNLoss(uint32 theme_id);
$client->RemoveLDoNWin(uint32 theme_id);
$client->RemoveNoRent();
$client->RemoveRadiantCrystals(uint32 amount);
$client->ResetAA();
$client->ResetAllCastbarCooldowns();
$client->ResetAllDisciplineTimers();
$client->ResetAlternateAdvancementRank(int aa_id);
$client->ResetCastbarCooldownBySlot(int slot);
$client->ResetCastbarCooldownBySpellID(uint32 spell_id);
$client->ResetDisciplineTimer(uint32_t timer_id);
$client->ResetItemCooldown(uint32 item_id);
$client->ResetLeadershipAA();
$client->ResetTrade();
$client->Save(uint8 commit_now);
$client->ScribeSpell(uint16 spell_id, int slot, bool update_client);
$client->ScribeSpell(uint16 spell_id, int slot);
$client->ScribeSpells(uint8 min_level, uint8 max_level);
$client->SendColoredText(uint32 color, string msg);
$client->SendGMCommand(string message, ignore_status);
$client->SendGMCommand(string message);
$client->SendMarqueeMessage(uint32 type, string message);
$client->SendMarqueeMessage(uint32 type, string message, uint32 duration);
$client->SendMarqueeMessage(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
$client->SendOPTranslocateConfirm(Mob* caster, uint16 spell_id);
$client->SendPEQZoneFlagInfo(Client* to);
$client->SendPath(Mob* target);
$client->SendPayload(int payload_id);
$client->SendPayload(int payload_id, string payload_value);
$client->SendSound();
$client->SendSpellAnim(uint16 targetid, uint16 spell_id);
$client->SendTargetCommand(uint32 entity_id);
$client->SendToGuildHall();
$client->SendToInstance(string instance_type, string zone_short_name, uint32 instance_version, float x, float y, float z, float heading, string instance_identifier, uint32 duration);
$client->SendWebLink(string url);
$client->SendZoneFlagInfo(Client* to);
$client->SetAAEXPModifier(uint32 zone_id, float aa_modifier, int16 instance_version);
$client->SetAAEXPModifier(uint32 zone_id, float aa_modifier);
$client->SetAAEXPModifier(float aa_modifier);
$client->SetAAPoints(uint32 points);
$client->SetAATitle(string title, bool save);
$client->SetAATitle(string title);
$client->SetAFK(uint8 afk_flag);
$client->SetAccountFlag(string flag, string value);
$client->SetAlternateCurrencyValue(uint32 currency_id, uint32 amount);
$client->SetAnon(uint8 anon_flag);
$client->SetAutoLoginCharacterName();
$client->SetAutoLoginCharacterName(string character_name);
$client->SetBaseClass(uint32 class_id);
$client->SetBaseGender(uint32 gender_id);
$client->SetBaseRace(uint32 race_id);
$client->SetBecomeNPC(bool flag);
$client->SetBecomeNPCLevel(uint8 level);
$client->SetBindPoint(int to_zone);
$client->SetBindPoint(int to_zone, int to_instance);
$client->SetBindPoint(int to_zone, int to_instance, float new_x, float new_y, float new_z);
$client->SetBindPoint(int to_zone, int to_instance, float new_x, float new_y);
$client->SetBindPoint();
$client->SetBindPoint(int to_zone, int to_instance, float new_x);
$client->SetBindPoint(int to_zone, int to_instance, float new_x, float new_y, float new_z, float new_heading);
$client->SetBotCreationLimit(uint32 new_creation_limit, uint8 class_id);
$client->SetBotCreationLimit(uint32 new_creation_limit);
$client->SetBotRequiredLevel(int new_required_level, uint8 class_id);
$client->SetBotRequiredLevel(int new_required_level);
$client->SetBotSpawnLimit(int new_spawn_limit);
$client->SetBotSpawnLimit(int new_spawn_limit, uint8 class_id);
$client->SetClientMaxLevel(uint8 max_level);
$client->SetConsumption(int hunger_amount, int thirst_amount);
$client->SetCustomItemData(int16 slot_id, string identifier, string value);
$client->SetDeity(uint32 deity_id);
$client->SetDuelTarget(uint32_t set_id);
$client->SetDueling(bool duel);
$client->SetEXP(uint64 set_exp, uint64 set_aaxp);
$client->SetEXP(uint64 set_exp, uint64 set_aaxp, bool resexp);
$client->SetEXPEnabled(bool is_exp_enabled);
$client->SetEXPModifier(uint32 zone_id, float exp_modifier, int16 instance_version);
$client->SetEXPModifier(uint32 zone_id, float exp_modifier);
$client->SetEXPModifier(float exp_modifier);
$client->SetEbonCrystals(uint32 value);
$client->SetEndurance(int endurance);
$client->SetEnvironmentDamageModifier(int modifier);
$client->SetFactionLevel(uint32 char_id, uint32 npc_faction_id, uint8 char_class, uint8 char_race, uint8 char_deity);
$client->SetFactionLevel2(uint32 char_id, int32 faction_id, uint8 char_class, uint8 char_race, uint8 char_deity, int32 value);
$client->SetFactionLevel2(uint32 char_id, int32 faction_id, uint8 char_class, uint8 char_race, uint8 char_deity, int32 value, uint8 temp);
$client->SetFeigned(bool feigned);
$client->SetGM(bool on);
$client->SetGMStatus(int new_status);
$client->SetHideMe(bool hide_me_state);
$client->SetHorseId(uint16_t horseid);
$client->SetHunger(int in_hunger);
$client->SetIPExemption(int exemption_amount);
$client->SetInvulnerableEnvironmentDamage(bool invul);
$client->SetItemCooldown(uint32 item_id, uint32 in_time);
$client->SetLDoNPoints(uint32 theme_id, uint32 points);
$client->SetLanguageSkill(uint8 language_id, uint8 language_skill);
$client->SetMaterial(int16 slot_id, uint32 item_id);
$client->SetPEQZoneFlag(uint32 zone_id);
$client->SetPVP(bool on);
$client->SetPrimaryWeaponOrnamentation(int model_id);
$client->SetRadiantCrystals(uint32 value);
$client->SetSecondaryWeaponOrnamentation(int model_id);
$client->SetSkill(int skill_id, uint16 value);
$client->SetSkillPoints(int points);
$client->SetSpellDuration(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
$client->SetSpellDuration(int spell_id);
$client->SetSpellDuration(int spell_id, int duration);
$client->SetSpellDuration(int spell_id, int duration, int level);
$client->SetSpellDuration(int spell_id, int duration, int level, bool allow_pets);
$client->SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
$client->SetSpellDurationGroup(int spell_id);
$client->SetSpellDurationGroup(int spell_id, int duration);
$client->SetSpellDurationGroup(int spell_id, int duration, int level);
$client->SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets);
$client->SetSpellDurationRaid(int spell_id, int duration);
$client->SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only, bool allow_bots);
$client->SetSpellDurationRaid(int spell_id);
$client->SetSpellDurationRaid(int spell_id, int duration, int level);
$client->SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets);
$client->SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
$client->SetStartZone(uint32 zone_id);
$client->SetStartZone(uint32 zone_id, float x, float y, float z);
$client->SetStartZone(uint32 zone_id, float x, float y, float z, float heading);
$client->SetStats(uint8 type, uint16 increase_val);
$client->SetThirst(int in_thirst);
$client->SetTint(int16 slot_id, uint32 color);
$client->SetTitleSuffix(string suffix);
$client->SetTitleSuffix(string suffix, bool save);
$client->SetZoneFlag(uint32 zone_id);
$client->Signal(int signal_id);
$client->SignalClient(int signal_id);
$client->SilentMessage(string message);
$client->Sit();
$client->SlotConvert2(uint8 slot);
$client->Stand();
$client->SummonBaggedItems(uint32 bag_item_id, reference bag_items_ref);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint16 slot_id);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
$client->SummonItem(uint32 item_id);
$client->SummonItem(uint32 item_id, int16 charges);
$client->SummonItem(uint32 item_id, int16 charges, bool attune);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1, uint32 aug2);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1, uint32 aug2, uint32 aug3);
$client->SummonItem(uint32 item_id, int16 charges, bool attune, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
$client->SummonItemIntoInventory(reference table_ref);
$client->TGB();
$client->TakeMoneyFromPP(uint64 copper, update_client);
$client->TakeMoneyFromPP(uint64 copper);
$client->TakePlatinum(uint32 platinum);
$client->TakePlatinum(uint32 platinum, update_client);
$client->TaskSelector(array task_ids);
$client->TaskSelectorNoCooldown(array task_ids);
$client->TeleportGroupToPlayerByName(string player_name);
$client->TeleportRaidToPlayerByName(string player_name);
$client->TeleportToPlayerByName(string player_name);
$client->Thirsty();
$client->TrainDiscBySpellID(int spell_id);
$client->UnFreeze();
$client->Undye();
$client->UnmemSpell(int slot);
$client->UnmemSpell(int slot, bool update_client);
$client->UnmemSpellAll();
$client->UnmemSpellAll(bool update_client);
$client->UnmemSpellBySpellID(int spell_id);
$client->UnscribeSpell(int slot, bool update_client);
$client->UnscribeSpell(int slot);
$client->UnscribeSpellAll(bool update_client);
$client->UnscribeSpellAll();
$client->UnscribeSpellBySpellID(uint16 spell_id);
$client->UnscribeSpellBySpellID(uint16 spell_id, bool update_client);
$client->UntrainDisc(int slot);
$client->UntrainDisc(int slot, bool update_client);
$client->UntrainDiscAll();
$client->UntrainDiscAll(bool update_client);
$client->UntrainDiscBySpellID(uint16 spell_id);
$client->UntrainDiscBySpellID(uint16 spell_id, bool update_client);
$client->UpdateAdmin();
$client->UpdateAdmin(bool from_database);
$client->UpdateGroupAAs(int points, uint32 type);
$client->UpdateLDoNPoints(uint32 theme_id, int points);
$client->UpdateTaskActivity(int task_id, int activity_id, int count);
$client->UpdateTaskActivity(int task_id, int activity_id, int count, bool ignore_quest_update);
$client->UpdateWho();
$client->UpdateWho(uint8 remove);
$client->UseAugmentContainer(int container_slot);
$client->UseDiscipline(uint32 spell_id, uint32 target);
$client->WorldKick();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`client:AccountID();
client:AccountName();
client:AddAAPoints(int points);
client:AddAlternateCurrencyValue(uint32 currency, int amount);
client:AddCrystals(uint32 radiant_count, uint32 ebon_count);
client:AddEXP(uint32 add_exp, int conlevel, bool resexp);
client:AddEXP(uint32 add_exp, int conlevel);
client:AddEXP(uint32 add_exp);
client:AddEbonCrystals(uint32 amount);
client:AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid);
client:AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds);
client:AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid);
client:AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds);
client:AddItem(object item_table);
client:AddLDoNLoss(uint32 theme_id);
client:AddLDoNWin(uint32 theme_id);
client:AddLevelBasedExp(int exp_pct, int max_level);
client:AddLevelBasedExp(int exp_pct, int max_level, bool ignore_mods);
client:AddLevelBasedExp(int exp_pct);
client:AddMoneyToPP(uint32 copper, uint32 silver, uint32 gold, uint32 platinum, bool update_client);
client:AddMoneyToPP(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
client:AddPVPPoints(uint32 points);
client:AddPlatinum(uint32 platinum);
client:AddPlatinum(uint32 platinum, bool update_client);
client:AddRadiantCrystals(uint32 amount);
client:AddSkill(int skill_id, int value);
client:Admin();
client:ApplySpell(int spell_id, int duration, int level, bool allow_pets);
client:ApplySpell(int spell_id, int duration, int level);
client:ApplySpell(int spell_id, int duration);
client:ApplySpell(int spell_id);
client:ApplySpell(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
client:ApplySpellGroup(int spell_id);
client:ApplySpellGroup(int spell_id, int duration);
client:ApplySpellGroup(int spell_id, int duration, int level);
client:ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets);
client:ApplySpellGroup(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
client:ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets);
client:ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
client:ApplySpellRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only, bool allow_bots);
client:ApplySpellRaid(int spell_id);
client:ApplySpellRaid(int spell_id, int duration);
client:ApplySpellRaid(int spell_id, int duration, int level);
client:AreaTaunt();
client:AreaTaunt(float range, int bonus_hate);
client:AreaTaunt(float range);
client:AssignTask(int task_id);
client:AssignTask(int task_id, int npc_id, bool enforce_level_requirement);
client:AssignTask(int task_id, int npc_id);
client:AssignToInstance(int instance_id);
client:AutoSplitEnabled();
client:BreakInvis();
client:CalcATK();
client:CalcCurrentWeight();
client:CalcEXP(uint8 consider_level, bool ignore_modifiers);
client:CalcEXP(uint8 consider_level);
client:CalcPriceMod(Mob other, bool reverse);
client:CampAllBots();
client:CampAllBots(uint8 class_id);
client:CanEnterZone(string zone_short_name, int16 instance_version);
client:CanEnterZone(string zone_short_name);
client:CanHaveSkill(int skill_id);
client:CashReward(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
client:ChangeLastName(string last_name);
client:CharacterID();
client:CheckIncreaseSkill(int skill_id, Mob target);
client:CheckIncreaseSkill(int skill_id, Mob target, int chance_mod);
client:CheckSpecializeIncrease(int spell_id);
client:ClearAccountFlag(const std);
client:ClearCompassMark();
client:ClearPEQZoneFlag(uint32 zone_id);
client:ClearXTargets();
client:ClearZoneFlag(uint32 zone_id);
client:Connected();
client:CountAugmentEquippedByID(uint32 item_id);
client:CountItem(uint32 item_id);
client:CountItemEquippedByID(uint32 item_id);
client:CreateExpedition(string zone_name, uint32 version, uint32 duration, string expedition_name, uint32 min_players, uint32 max_players, bool disable_messages);
client:CreateExpedition(string zone_name, uint32 version, uint32 duration, string expedition_name, uint32 min_players, uint32 max_players);
client:CreateExpedition(object expedition_table);
client:CreateExpeditionFromTemplate(uint32_t dz_template_id);
client:CreateTaskDynamicZone(int task_id, object dz_table);
client:DecreaseByID(uint32 type, int amt);
client:DeleteBucket(string bucket_name);
client:DeleteItemInInventory(int slot_id, int quantity);
client:DeleteItemInInventory(int slot_id, int quantity, bool update_client);
client:DescribeSpecialAbilities(NPC n);
client:DialogueWindow(string markdown);
client:DisableAreaEndRegen();
client:DisableAreaHPRegen();
client:DisableAreaManaRegen();
client:DisableAreaRegens();
client:Disconnect();
client:DropItem(int slot_id);
client:Duck();
client:DyeArmorBySlot(uint8 slot, uint8 red, uint8 green, uint8 blue);
client:DyeArmorBySlot(uint8 slot, uint8 red, uint8 green, uint8 blue, uint8 use_tint);
client:EnableAreaEndRegen(int value);
client:EnableAreaHPRegen(int value);
client:EnableAreaManaRegen(int value);
client:EnableAreaRegens(int value);
client:EndSharedTask(bool send_fail);
client:EndSharedTask();
client:Escape();
client:FailTask(int task);
client:FilteredMessage(Mob sender, uint32 type, int filter, string message);
client:FindEmptyMemSlot();
client:FindMemmedSpellBySlot(int slot);
client:FindMemmedSpellBySpellID(uint16 spell_id);
client:FindSpellBookSlotBySpellID(spell_id);
client:Fling(float value, float target_x, float target_y, float target_z, bool ignore_los);
client:Fling(float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
client:Fling(float target_x, float target_y, float target_z);
client:Fling(float value, float target_x, float target_y, float target_z);
client:Fling(float value, float target_x, float target_y, float target_z, bool ignore_los, bool clip_through_walls);
client:Fling(float target_x, float target_y, float target_z, bool ignore_los);
client:ForageItem(bool guarantee);
client:ForageItem();
client:Freeze();
client:GetAAEXPModifier();
client:GetAAEXPModifier(uint32 zone_id, int16 instance_version);
client:GetAAEXPModifier(uint32 zone_id);
client:GetAAEXPPercentage();
client:GetAAExp();
client:GetAAPercent();
client:GetAAPoints();
client:GetAFK();
client:GetAccountAge();
client:GetAccountFlag(const std);
client:GetAccountFlags();
client:GetAggroCount();
client:GetAllMoney();
client:GetAlternateCurrencyValue(currency);
client:GetAnon();
client:GetAugmentIDAt(slot_id, aug_slot);
client:GetAugmentIDsBySlotID(int16 slot_id);
client:GetAutoLoginCharacterName();
client:GetBaseAGI();
client:GetBaseCHA();
client:GetBaseDEX();
client:GetBaseFace();
client:GetBaseINT();
client:GetBaseSTA();
client:GetBaseSTR();
client:GetBaseWIS();
client:GetBindHeading();
client:GetBindHeading(int index);
client:GetBindX(int index);
client:GetBindX();
client:GetBindY(int index);
client:GetBindY();
client:GetBindZ();
client:GetBindZ(int index);
client:GetBindZoneID(int index);
client:GetBindZoneID();
client:GetBotCreationLimit(uint8 class_id);
client:GetBotCreationLimit();
client:GetBotRequiredLevel(uint8 class_id);
client:GetBotRequiredLevel();
client:GetBotSpawnLimit(uint8 class_id);
client:GetBotSpawnLimit();
client:GetBucket(bucket_name);
client:GetBucketExpires(bucket_name);
client:GetBucketRemaining(bucket_name);
client:GetCarriedMoney();
client:GetCarriedPlatinum();
client:GetCharacterFactionLevel(faction_id);
client:GetClassAbbreviation();
client:GetClassBitmask();
client:GetClientMaxLevel();
client:GetClientVersion();
client:GetClientVersionBit();
client:GetCorpseCount();
client:GetCorpseID(corpse);
client:GetCorpseItemAt(corpse, slot);
client:GetDeityBitmask();
client:GetDiscSlotBySpellID(int32 spell_id);
client:GetDisciplineTimer(timer_id);
client:GetDuelTarget();
client:GetEXP();
client:GetEXPForLevel(uint16 check_level);
client:GetEXPModifier(uint32 zone_id, int16 instance_version);
client:GetEXPModifier();
client:GetEXPModifier(uint32 zone_id);
client:GetEXPPercentage();
client:GetEbonCrystals();
client:GetEndurance();
client:GetEndurancePercent();
client:GetEnvironmentDamageModifier();
client:GetExpedition();
client:GetFace();
client:GetFactionLevel(uint32 char_id, uint32 npc_id, uint32 race, uint32 class_, uint32 deity, uint32 faction, NPC npc);
client:GetFeigned();
client:GetGM();
client:GetGMStatus();
client:GetGroup();
client:GetGroupPoints();
client:GetGuildPublicNote();
client:GetHealAmount();
client:GetHorseId();
client:GetHunger();
client:GetIP();
client:GetIPExemption();
client:GetIPString();
client:GetInstrumentMod(spell_id);
client:GetIntoxication();
client:GetInventory();
client:GetInvulnerableEnvironmentDamage();
client:GetItemCooldown(item_id);
client:GetItemIDAt(slot_id);
client:GetLDoNLosses();
client:GetLDoNLossesTheme(theme);
client:GetLDoNPointsTheme(theme);
client:GetLDoNWins();
client:GetLDoNWinsTheme(theme);
client:GetLanguageSkill(skill_id);
client:GetLearnableDisciplines();
client:GetLearnableDisciplines(uint8 min_level);
client:GetLearnableDisciplines(uint8 min_level, uint8 max_level);
client:GetLearnedDisciplines();
client:GetLockoutExpeditionUUID(expedition_name, event_name);
client:GetMaxEndurance();
client:GetMemmedSpells();
client:GetModCharacterFactionLevel(faction);
client:GetMoney(uint8 type, uint8 subtype);
client:GetNextAvailableDisciplineSlot(starting_slot);
client:GetNextAvailableDisciplineSlot();
client:GetNextAvailableSpellBookSlot();
client:GetNextAvailableSpellBookSlot(start);
client:GetPEQZoneFlags();
client:GetPVP();
client:GetPVPPoints();
client:GetRaceAbbreviation();
client:GetRaceBitmask();
client:GetRadiantCrystals();
client:GetRaid();
client:GetRaidPoints();
client:GetRawItemAC();
client:GetRawSkill(skill_id);
client:GetRecipeMadeCount(uint32 recipe_id);
client:GetScribeableSpells();
client:GetScribeableSpells(uint8 min_level);
client:GetScribeableSpells(uint8 min_level, uint8 max_level);
client:GetScribedSpells();
client:GetSkillPoints();
client:GetSkillTrainLevel(int skill_id);
client:GetSpellDamage();
client:GetSpellIDByBookSlot(int slot_id);
client:GetSpentAA();
client:GetStartZone();
client:GetTargetRingX();
client:GetTargetRingY();
client:GetTargetRingZ();
client:GetThirst();
client:GetTotalSecondsPlayed();
client:GetWeight();
client:GetZoneFlags();
client:GoFish();
client:GrantAllAAPoints();
client:GrantAllAAPoints(uint8 unlock_level, bool skip_grant_only);
client:GrantAllAAPoints(uint8 unlock_level);
client:GrantAlternateAdvancementAbility(int aa_id, int points, ignore_cost);
client:GrantAlternateAdvancementAbility(int aa_id, int points);
client:GuildID();
client:GuildRank();
client:HasAugmentEquippedByID(uint32 item_id);
client:HasDisciplineLearned(uint16 spell_id);
client:HasExpeditionLockout(string expedition_name, string event_name);
client:HasItemEquippedByID(uint32 item_id);
client:HasItemOnCorpse(uint32 item_id);
client:HasPEQZoneFlag(uint32 zone_id);
client:HasRecipeLearned(uint32 recipe_id);
client:HasSkill(int skill_id);
client:HasSpellScribed(int spell_id);
client:HasZoneFlag(uint32 zone_id);
client:Hungry();
client:InZone();
client:IncStats(int type, int value);
client:IncreaseLanguageSkill(uint8 language_id, uint8 increase);
client:IncreaseLanguageSkill(uint8 language_id);
client:IncreaseSkill(int skill_id);
client:IncreaseSkill(int skill_id, int value);
client:IncrementAA(int aa);
client:IsAutoAttackEnabled();
client:IsAutoFireEnabled();
client:IsCrouching();
client:IsDead();
client:IsDueling();
client:IsEXPEnabled();
client:IsGrouped();
client:IsInAGuild();
client:IsLD();
client:IsMedding();
client:IsRaidGrouped();
client:IsSitting();
client:IsStanding();
client:IsTaskActive(int task);
client:IsTaskActivityActive(int task, int activity);
client:IsTaskCompleted(int task_id);
client:KeyRingAdd(uint32 item);
client:KeyRingCheck(uint32 item);
client:Kick();
client:LearnDisciplines(uint8 min_level, uint8 max_level);
client:LearnRecipe(uint32 recipe);
client:LeaveGroup();
client:LoadPEQZoneFlags();
client:LoadZoneFlags();
client:LockSharedTask(bool lock);
client:MarkSingleCompassLoc(float in_x, float in_y, float in_z, int count);
client:MarkSingleCompassLoc(float in_x, float in_y, float in_z);
client:MaxSkill(skill_id);
client:MaxSkills();
client:MemSpell(int spell_id, int slot);
client:MemSpell(int spell_id, int slot, bool update_client);
client:MemmedCount();
client:MovePC(int zone, float x, float y, float z, float heading);
client:MovePCDynamicZone(uint32 zone_id, int zone_version, bool msg_if_invalid);
client:MovePCDynamicZone(string zone_name, int zone_version);
client:MovePCDynamicZone(string zone_name);
client:MovePCDynamicZone(uint32 zone_id, int zone_version);
client:MovePCDynamicZone(string zone_name, int zone_version, bool msg_if_invalid);
client:MovePCDynamicZone(uint32 zone_id);
client:MovePCInstance(int zone, int instance, float x, float y, float z, float heading);
client:MoveZone(string zone_short_name);
client:MoveZone(string zone_short_name, float x, float y, float z);
client:MoveZone(string zone_short_name, float x, float y, float z, float heading);
client:MoveZoneGroup(string zone_short_name, float x, float y, float z, float heading);
client:MoveZoneGroup(string zone_short_name);
client:MoveZoneGroup(string zone_short_name, float x, float y, float z);
client:MoveZoneInstance(uint16 instance_id);
client:MoveZoneInstance(uint16 instance_id, float x, float y, float z, float heading);
client:MoveZoneInstance(uint16 instance_id, float x, float y, float z);
client:MoveZoneInstanceGroup(uint16 instance_id, float x, float y, float z);
client:MoveZoneInstanceGroup(uint16 instance_id, float x, float y, float z, float heading);
client:MoveZoneInstanceGroup(uint16 instance_id);
client:MoveZoneInstanceRaid(uint16 instance_id);
client:MoveZoneInstanceRaid(uint16 instance_id, float x, float y, float z, float heading);
client:MoveZoneInstanceRaid(uint16 instance_id, float x, float y, float z);
client:MoveZoneRaid(string zone_short_name);
client:MoveZoneRaid(string zone_short_name, float x, float y, float z);
client:MoveZoneRaid(string zone_short_name, float x, float y, float z, float heading);
client:NotifyNewTitlesAvailable();
client:NukeItem(uint32 item_num, int where_to_check);
client:NukeItem(uint32 item_num);
client:OpenLFGuildWindow();
client:PlayMP3(string file);
client:Popup(string title, string text, uint32 popup_id, uint32 negative_id);
client:Popup(string title, string text, uint32 popup_id);
client:Popup(string title, string text);
client:Popup(string title, string text, uint32 popup_id, uint32 negative_id, uint32 button_type, uint32 duration, string button_name_one, string button_name_two, uint32 sound_controls);
client:Popup(string title, string text, uint32 popup_id, uint32 negative_id, uint32 button_type);
client:Popup(string title, string text, uint32 popup_id, uint32 negative_id, uint32 button_type, uint32 duration, string button_name_one, string button_name_two);
client:Popup(string title, string text, uint32 popup_id, uint32 negative_id, uint32 button_type, uint32 duration);
client:PushItemOnCursor(ItemInst inst);
client:PutItemInInventory(int slot_id, ItemInst inst);
client:QuestReadBook(string text, int type);
client:QuestReward(Mob target, uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
client:QuestReward(Mob target);
client:QuestReward(Mob target, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 itemid, uint32 exp);
client:QuestReward(Mob target, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 itemid);
client:QuestReward(Mob target, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, uint32 itemid, uint32 exp, bool faction);
client:QuestReward(Mob target, object reward);
client:QuestReward(Mob target, uint32 copper, uint32 silver, uint32 gold);
client:QuestReward(Mob target, uint32 copper, uint32 silver);
client:QuestReward(Mob target, uint32 copper);
client:QueuePacket(Packet app, bool ack_req, int client_connection_status);
client:QueuePacket(Packet app, bool ack_req);
client:QueuePacket(Packet app, bool ack_req, int client_connection_status, int filter);
client:QueuePacket(Packet app);
client:ReadBookByName(string book_name, uint8 book_type);
client:RefundAA();
client:ReloadDataBuckets();
client:RemoveAAPoints(uint32 points);
client:RemoveAllExpeditionLockouts(string expedition_name);
client:RemoveAllExpeditionLockouts();
client:RemoveAlternateCurrencyValue(uint32 currency_id, uint32 amount);
client:RemoveEbonCrystals(uint32 amount);
client:RemoveExpeditionLockout(string expedition_name, string event_name);
client:RemoveItem(uint32 item_id, uint32 quantity);
client:RemoveItem(uint32 item_id);
client:RemoveLDoNLoss(uint32 theme_id);
client:RemoveLDoNWin(uint32 theme_id);
client:RemoveRadiantCrystals(uint32 amount);
client:ResetAA();
client:ResetAllCastbarCooldowns();
client:ResetAllDisciplineTimers();
client:ResetAlternateAdvancementRank(int aa_id);
client:ResetCastbarCooldownBySlot(int slot);
client:ResetCastbarCooldownBySpellID(uint32 spell_id);
client:ResetDisciplineTimer(uint32 timer_id);
client:ResetItemCooldown(uint32 item_id);
client:ResetLeadershipAA();
client:ResetTrade();
client:RewardFaction(int id, int amount);
client:Save();
client:Save(int commit_now);
client:ScribeSpell(int spell_id, int slot, bool update_client);
client:ScribeSpell(int spell_id, int slot);
client:ScribeSpells(uint8 min_level, uint8 max_level);
client:SendColoredText(uint32 type, string msg);
client:SendGMCommand(string message, ignore_status);
client:SendGMCommand(string message);
client:SendItemScale(ItemInst inst);
client:SendMarqueeMessage(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
client:SendMarqueeMessage(uint32 type, string message, uint32 duration);
client:SendMarqueeMessage(uint32 type, string message);
client:SendOPTranslocateConfirm(Mob caster, int spell_id);
client:SendPEQZoneFlagInfo(Client to);
client:SendPath(Mob target);
client:SendPayload(int payload_id, string payload_value);
client:SendPayload(int payload_id);
client:SendSound();
client:SendToGuildHall();
client:SendToInstance(string instance_type, string zone_short_name, uint32 instance_version, float x, float y, float z, float heading, string instance_identifier, uint32 duration);
client:SendWebLink(string site);
client:SendZoneFlagInfo(Client to);
client:SetAAEXPModifier(uint32 zone_id, float aa_modifier);
client:SetAAEXPModifier(float aa_modifier);
client:SetAAEXPModifier(uint32 zone_id, float aa_modifier, int16 instance_version);
client:SetAAPoints(int points);
client:SetAATitle(string title);
client:SetAATitle(string title, bool save_to_database);
client:SetAFK(uint8 afk_flag);
client:SetAccountFlag(const std);
client:SetAlternateCurrencyValue(uint32 currency, uint32 amount);
client:SetAnon(uint8 anon_flag);
client:SetAutoLoginCharacterName();
client:SetAutoLoginCharacterName(string character_name);
client:SetBaseClass(int v);
client:SetBaseGender(int v);
client:SetBaseRace(int v);
client:SetBindPoint(int to_zone, int to_instance);
client:SetBindPoint(int to_zone);
client:SetBindPoint(int to_zone, int to_instance, float new_x);
client:SetBindPoint(int to_zone, int to_instance, float new_x, float new_y, float new_z, float new_heading);
client:SetBindPoint();
client:SetBindPoint(int to_zone, int to_instance, float new_x, float new_y, float new_z);
client:SetBindPoint(int to_zone, int to_instance, float new_x, float new_y);
client:SetBotCreationLimit(uint32 new_creation_limit);
client:SetBotCreationLimit(uint32 new_creation_limit, uint8 class_id);
client:SetBotRequiredLevel(int new_required_level, uint8 class_id);
client:SetBotRequiredLevel(int new_required_level);
client:SetBotSpawnLimit(int new_spawn_limit, uint8 class_id);
client:SetBotSpawnLimit(int new_spawn_limit);
client:SetBucket(string bucket_name, string bucket_value, string expiration);
client:SetBucket(string bucket_name, string bucket_value);
client:SetClientMaxLevel(uint8 max_level);
client:SetConsumption(int in_hunger, int in_thirst);
client:SetDeity(int v);
client:SetDuelTarget(int c);
client:SetDueling(bool v);
client:SetEXP(uint64 set_exp, uint64 set_aaxp, bool resexp);
client:SetEXP(uint64 set_exp, uint64 set_aaxp);
client:SetEXPEnabled(bool is_exp_enabled);
client:SetEXPModifier(uint32 zone_id, float exp_modifier);
client:SetEXPModifier(uint32 zone_id, float exp_modifier, int16 instance_version);
client:SetEXPModifier(float exp_modifier);
client:SetEbonCrystals(uint32 value);
client:SetEndurance(int endur);
client:SetEnvironmentDamageModifier(int value);
client:SetFactionLevel(uint32 char_id, uint32 npc_faction_id, int char_class, int char_race, int char_deity);
client:SetFactionLevel2(uint32 char_id, int faction_id, int char_class, int char_race, int char_deity, int value, int temp);
client:SetFeigned(bool v);
client:SetGM(bool v);
client:SetGMStatus(int new_status);
client:SetHideMe(bool hide_me_state);
client:SetHorseId(int id);
client:SetHunger(int in_hunger);
client:SetIPExemption(int exemption_amount);
client:SetInvulnerableEnvironmentDamage(bool value);
client:SetItemCooldown(uint32 item_id, uint32 in_time);
client:SetLDoNPoints(uint32 theme_id, uint32 points);
client:SetLanguageSkill(uint8 language_id, uint8 language_skill);
client:SetMaterial(int slot_id, uint32 item_id);
client:SetPEQZoneFlag(uint32 zone_id);
client:SetPVP(bool v);
client:SetPrimaryWeaponOrnamentation(uint32 model_id);
client:SetRadiantCrystals(uint32 value);
client:SetSecondaryWeaponOrnamentation(uint32 model_id);
client:SetSkill(int skill_id, int value);
client:SetSkillPoints(int skill);
client:SetSpellDuration(int spell_id, int duration, int level, bool allow_pets);
client:SetSpellDuration(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
client:SetSpellDuration(int spell_id, int duration, int level);
client:SetSpellDuration(int spell_id, int duration);
client:SetSpellDuration(int spell_id);
client:SetSpellDurationGroup(int spell_id, int duration);
client:SetSpellDurationGroup(int spell_id, int duration, int level);
client:SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets);
client:SetSpellDurationGroup(int spell_id, int duration, int level, bool allow_pets, bool allow_bots);
client:SetSpellDurationGroup(int spell_id);
client:SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only);
client:SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets, bool is_raid_group_only, bool allow_bots);
client:SetSpellDurationRaid(int spell_id, int duration, int level, bool allow_pets);
client:SetSpellDurationRaid(int spell_id, int duration, int level);
client:SetSpellDurationRaid(int spell_id, int duration);
client:SetSpellDurationRaid(int spell_id);
client:SetStartZone(int zone_id, float x);
client:SetStartZone(int zone_id);
client:SetStartZone(int zone_id, float x, float y, float z);
client:SetStartZone(int zone_id, float x, float y);
client:SetStats(int type, int value);
client:SetThirst(int in_thirst);
client:SetTint(int slot_id, uint32 color);
client:SetTitleSuffix(string text);
client:SetZoneFlag(uint32 zone_id);
client:Signal(int signal_id);
client:Sit();
client:Stand();
client:SummonBaggedItems(uint32 bag_item_id, object bag_items_table);
client:SummonItem(uint32 item_id);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2);
client:SummonItem(uint32 item_id, int charges);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, bool attuned, int to_slot);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, bool attuned);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
client:SummonItem(uint32 item_id, int charges, uint32 aug1);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
client:SummonItem(uint32 item_id, int charges, uint32 aug1, uint32 aug2, uint32 aug3);
client:SummonItemIntoInventory(object item_table);
client:TGB();
client:TakeMoneyFromPP(uint64 copper);
client:TakeMoneyFromPP(uint64 copper, update_client);
client:TakePlatinum(uint32 platinum, update_client);
client:TakePlatinum(uint32 platinum);
client:TaskSelector(object table);
client:TaskSelector(object table, bool ignore_cooldown);
client:TeleportGroupToPlayerByCharID(uint32 character_id);
client:TeleportGroupToPlayerByName(string player_name);
client:TeleportRaidToPlayerByCharID(uint32 character_id);
client:TeleportRaidToPlayerByName(string player_name);
client:TeleportToPlayerByCharID(uint32 character_id);
client:TeleportToPlayerByName(string player_name);
client:Thirsty();
client:TrainDisc(int itemid);
client:TrainDiscBySpellID(int32 spell_id);
client:UnFreeze();
client:Undye();
client:UnmemSpell(int slot, bool update_client);
client:UnmemSpell(int slot);
client:UnmemSpellAll(bool update_client);
client:UnmemSpellAll();
client:UnmemSpellBySpellID(int32 spell_id);
client:UnscribeSpell(int slot);
client:UnscribeSpell(int slot, bool update_client);
client:UnscribeSpellAll();
client:UnscribeSpellAll(bool update_client);
client:UnscribeSpellBySpellID(uint16 spell_id);
client:UnscribeSpellBySpellID(uint16 spell_id, bool update_client);
client:UntrainDisc(int slot);
client:UntrainDisc(int slot, bool update_client);
client:UntrainDiscAll(bool update_client);
client:UntrainDiscAll();
client:UntrainDiscBySpellID(uint16 spell_id);
client:UntrainDiscBySpellID(uint16 spell_id, bool update_client);
client:UpdateAdmin();
client:UpdateAdmin(bool from_database);
client:UpdateGroupAAs(int points, uint32 type);
client:UpdateLDoNPoints(uint32 theme_id, int points);
client:UpdateTaskActivity(int task, int activity, int count);
client:UseAugmentContainer(int container_slot);
client:UseDiscipline(int spell_id, int target_id);
client:WorldKick();
`
```

---

## Corpse

*Source: quest-api/methods/corpse/index.html*

# Corpse

Perl (34)Lua (39)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$corpse->AddItem(uint32 item_id, uint16 charges);
$corpse->AddItem(uint32 item_id, uint16 charges, uint16 slot);
$corpse->AddLooter(Mob* who);
$corpse->AllowMobLoot(Mob* them, uint8_t slot);
$corpse->CanMobLoot(int character_id);
$corpse->CastRezz(uint16_t spell_id, Mob* caster);
$corpse->CompleteRezz();
$corpse->CountItem(uint32_t item_id);
$corpse->CountItems();
$corpse->Delete();
$corpse->GetCharID();
$corpse->GetCopper();
$corpse->GetDBID();
$corpse->GetDecayTime();
$corpse->GetGold();
$corpse->GetLootList();
$corpse->GetOwnerName();
$corpse->GetPlatinum();
$corpse->GetSilver();
$corpse->GetWornItem(uint16_t equip_slot);
$corpse->HasItem(uint32_t item_id);
$corpse->IsEmpty();
$corpse->IsLocked();
$corpse->IsRezzed();
$corpse->Lock();
$corpse->RemoveItem(uint16_t loot_slot);
$corpse->RemoveItemByID(uint32_t item_id);
$corpse->RemoveItemByID(uint32_t item_id, int quantity);
$corpse->ResetDecayTimer();
$corpse->ResetLooter();
$corpse->SetCash(uint16 copper, uint16 silver, uint16 gold, uint16 platinum);
$corpse->SetDecayTimer(uint32_t decay_time);
$corpse->Summon(Client* client, bool is_spell);
$corpse->UnLock();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`corpse:AddItem(uint32 itemnum, uint16 charges, int16 slot, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
corpse:AddItem(uint32 itemnum, uint16 charges, int16 slot);
corpse:AddItem(uint32 itemnum, uint16 charges);
corpse:AddLooter(Mob who);
corpse:AllowMobLoot(Mob them, uint8 slot);
corpse:Bury();
corpse:CanMobLoot(int charid);
corpse:CountItem(uint32 item_id);
corpse:CountItems();
corpse:Delete();
corpse:Depop();
corpse:GetCharID();
corpse:GetCopper();
corpse:GetDBID();
corpse:GetDecayTime();
corpse:GetFirstSlotByItemID(uint32 item_id);
corpse:GetGold();
corpse:GetItemIDBySlot(uint16 loot_slot);
corpse:GetLootList();
corpse:GetOwnerName();
corpse:GetPlatinum();
corpse:GetSilver();
corpse:GetWornItem(int16 equipSlot);
corpse:HasItem(uint32 item_id);
corpse:IsEmpty();
corpse:IsLocked();
corpse:IsRezzed();
corpse:Lock();
corpse:RemoveCash();
corpse:RemoveItem(uint16 lootslot);
corpse:RemoveItemByID(uint32 item_id);
corpse:RemoveItemByID(uint32 item_id, int quantity);
corpse:ResetDecayTimer();
corpse:ResetLooter();
corpse:Save();
corpse:SetCash(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
corpse:SetDecayTimer(uint32 decaytime);
corpse:Summon(Client client, spell, checkdistance);
corpse:UnLock();
`
```

---

## Database

*Source: quest-api/methods/database/index.html*

# Database

Lua (2)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`database:Prepare(string query);
database:close();
`
```

---

## Door

*Source: quest-api/methods/door/index.html*

# Door

Lua (51)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`door:CreateDatabaseEntry();
door:ForceClose(Mob sender, bool alt_mode);
door:ForceClose(Mob sender);
door:ForceOpen(Mob sender);
door:ForceOpen(Mob sender, bool alt_mode);
door:GetClientVersionMask();
door:GetDestinationHeading();
door:GetDestinationInstanceID();
door:GetDestinationX();
door:GetDestinationY();
door:GetDestinationZ();
door:GetDestinationZoneName();
door:GetDisableTimer();
door:GetDoorDBID();
door:GetDoorID();
door:GetDoorName();
door:GetDoorParam();
door:GetDzSwitchID();
door:GetGuildID();
door:GetHeading();
door:GetID();
door:GetIncline();
door:GetInvertState();
door:GetKeyItem();
door:GetLockPick();
door:GetNoKeyring();
door:GetOpenType();
door:GetSize();
door:GetTriggerDoorID();
door:GetTriggerType();
door:GetX();
door:GetY();
door:GetZ();
door:HasDestinationZone();
door:IsDestinationZoneSame();
door:IsDoorBlacklisted();
door:IsLDoNDoor();
door:SetDisableTimer(bool flag);
door:SetDoorName(string name);
door:SetHeading(float h);
door:SetIncline(uint32 incline);
door:SetInvertState(int invert_state);
door:SetKeyItem(uint32 key);
door:SetLocation(float x, float y, float z);
door:SetLockPick(uint32 pick);
door:SetNoKeyring(int type);
door:SetOpenType(uint32 type);
door:SetSize(uint32 sz);
door:SetX(float x);
door:SetY(float y);
door:SetZ(float z);
`
```

---

## Doors

*Source: quest-api/methods/doors/index.html*

# Doors

Perl (51)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$doors->CreateDatabaseEntry();
$doors->ForceClose(Mob* sender);
$doors->ForceClose(Mob* sender, bool alt_mode);
$doors->ForceOpen(Mob* sender);
$doors->ForceOpen(Mob* sender, bool alt_mode);
$doors->GetClientVersionMask();
$doors->GetDestinationHeading();
$doors->GetDestinationInstanceID();
$doors->GetDestinationX();
$doors->GetDestinationY();
$doors->GetDestinationZ();
$doors->GetDestinationZoneName();
$doors->GetDisableTimer();
$doors->GetDoorDBID();
$doors->GetDoorID();
$doors->GetDoorParam();
$doors->GetDzSwitchID();
$doors->GetGuildID();
$doors->GetHeading();
$doors->GetID();
$doors->GetIncline();
$doors->GetInvertState();
$doors->GetKeyItem();
$doors->GetLockPick();
$doors->GetModelName();
$doors->GetNoKeyring();
$doors->GetOpenType();
$doors->GetSize();
$doors->GetTriggerDoorID();
$doors->GetTriggerType();
$doors->GetX();
$doors->GetY();
$doors->GetZ();
$doors->HasDestinationZone();
$doors->IsDestinationZoneSame();
$doors->IsDoorBlacklisted();
$doors->IsLDoNDoor();
$doors->SetDisableTimer(bool disable_timer);
$doors->SetHeading(float heading);
$doors->SetIncline(uint32_t incline);
$doors->SetInvertState(int invert_state);
$doors->SetKeyItem(uint32_t key_item_id);
$doors->SetLocation(float x, float y, float z);
$doors->SetLockPick(uint32_t lockpick_type);
$doors->SetModelName(string name);
$doors->SetNoKeyring(uint8_t no_key_ring);
$doors->SetOpenType(uint32_t open_type);
$doors->SetSize(uint32_t size);
$doors->SetX(float x);
$doors->SetY(float y);
$doors->SetZ(float z);
`
```

---

## Entity

*Source: quest-api/methods/entity/index.html*

# Entity

Lua (25)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`entity:CastToBot();
entity:CastToClient();
entity:CastToCorpse();
entity:CastToDoor();
entity:CastToMerc();
entity:CastToMob();
entity:CastToNPC();
entity:CastToObject();
entity:GetID();
entity:IsAura();
entity:IsBeacon();
entity:IsBot();
entity:IsClient();
entity:IsCorpse();
entity:IsDoor();
entity:IsEncounter();
entity:IsMerc();
entity:IsMob();
entity:IsNPC();
entity:IsNPCCorpse();
entity:IsObject();
entity:IsOfClientBot();
entity:IsOfClientBotMerc();
entity:IsPlayerCorpse();
entity:IsTrap();
`
```

---

## EntityList

*Source: quest-api/methods/entitylist/index.html*

# EntityList

Perl (122)Lua (106)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$entitylist->AreaAttack(Mob* attacker, float distance);
$entitylist->AreaAttack(Mob* attacker, float distance, int16 slot_id);
$entitylist->AreaAttack(Mob* attacker, float distance, int16 slot_id, int count, bool is_from_spell);
$entitylist->AreaAttack(Mob* attacker, float distance, int16 slot_id, int count);
$entitylist->AreaAttack(Mob* attacker, float distance, int16 slot_id, int count, bool is_from_spell, int attack_rounds);
$entitylist->AreaSpell(Mob* caster, Mob* center, uint16 spell_id, bool affect_caster, int16 resist_adjust, int max_targets);
$entitylist->AreaSpell(Mob* caster, Mob* center, uint16 spell_id, bool affect_caster, int16 resist_adjust);
$entitylist->AreaSpell(Mob* caster, Mob* center, uint16 spell_id, bool affect_caster);
$entitylist->AreaSpell(Mob* caster, Mob* center, uint16 spell_id);
$entitylist->AreaTaunt(Client* caster, float range);
$entitylist->AreaTaunt(Client* caster);
$entitylist->AreaTaunt(Client* caster, float range, int bonus_hate);
$entitylist->CanAddHateForMob(Mob* target);
$entitylist->Clear();
$entitylist->ClearClientPetitionQueue();
$entitylist->ClearFeignAggro(Mob* target);
$entitylist->DeleteNPCCorpses();
$entitylist->DeletePlayerCorpses();
$entitylist->DoubleAggro(Mob* who);
$entitylist->Fighting(Mob* target);
$entitylist->FindDoor(uint32_t door_id);
$entitylist->GetBotByID(uint32_t bot_id);
$entitylist->GetBotByName(string bot_name);
$entitylist->GetBotList();
$entitylist->GetBotListByCharacterID(uint32_t character_id);
$entitylist->GetBotListByCharacterID(uint32_t character_id, uint8_t class_id);
$entitylist->GetBotListByClientName(string client_name, uint8 class_id);
$entitylist->GetBotListByClientName(string client_name);
$entitylist->GetBotOwnerByBotEntityID(uint32_t entity_id);
$entitylist->GetBotOwnerByBotID(uint32_t bot_id);
$entitylist->GetClientByAccID(uint32_t account_id);
$entitylist->GetClientByCharID(uint32_t character_id);
$entitylist->GetClientByID(uint16_t client_id);
$entitylist->GetClientByName(string name);
$entitylist->GetClientByWID(uint32_t wid);
$entitylist->GetClientList();
$entitylist->GetCloseMobList(Mob* mob, float distance, bool ignore_self);
$entitylist->GetCloseMobList(Mob* mob, float distance);
$entitylist->GetCloseMobList(Mob* mob);
$entitylist->GetCorpseByID(uint16_t id);
$entitylist->GetCorpseByName(string name);
$entitylist->GetCorpseByOwner(Client* client);
$entitylist->GetCorpseList();
$entitylist->GetDoorsByDBID(uint32_t database_id);
$entitylist->GetDoorsByDoorID(uint32_t door_id);
$entitylist->GetDoorsByID(uint32_t entity_id);
$entitylist->GetDoorsList();
$entitylist->GetGroupByClient(Client* client);
$entitylist->GetGroupByID(uint32_t id);
$entitylist->GetGroupByLeaderName(string leader_name);
$entitylist->GetGroupByMob(Mob* mob);
$entitylist->GetMob(string name);
$entitylist->GetMobByID(uint16_t mob_id);
$entitylist->GetMobByNpcTypeID(uint32_t npc_type_id);
$entitylist->GetMobID(uint16_t mob_id);
$entitylist->GetMobList();
$entitylist->GetNPCByID(uint16_t id);
$entitylist->GetNPCByNPCTypeID(uint32_t npc_id);
$entitylist->GetNPCBySpawnID(uint32_t spawn_id);
$entitylist->GetNPCList();
$entitylist->GetNPCsByExcludedIDs(npc_ids);
$entitylist->GetNPCsByIDs(npc_ids);
$entitylist->GetObjectByDBID(uint32_t database_id);
$entitylist->GetObjectByID(uint32_t entity_id);
$entitylist->GetObjectList();
$entitylist->GetRaidByClient(Client* client);
$entitylist->GetRaidByID(uint32_t id);
$entitylist->GetRandomBot();
$entitylist->GetRandomBot(float x, float y, float z, float distance);
$entitylist->GetRandomBot(float x, float y, float z, float distance, exclude_bot);
$entitylist->GetRandomClient(float x, float y, float z, float distance);
$entitylist->GetRandomClient(float x, float y, float z, float distance, exclude_client);
$entitylist->GetRandomClient();
$entitylist->GetRandomMob();
$entitylist->GetRandomMob(float x, float y, float z, float distance);
$entitylist->GetRandomMob(float x, float y, float z, float distance, exclude_mob);
$entitylist->GetRandomNPC(float x, float y, float z, float distance, exclude_npc);
$entitylist->GetRandomNPC();
$entitylist->GetRandomNPC(float x, float y, float z, float distance);
$entitylist->GetSpawnByID(uint32 spawn_id);
$entitylist->GetSpawnList();
$entitylist->HalveAggro(Mob* who);
$entitylist->IsMobSpawnedByNpcTypeID(uint32_t npc_type_id);
$entitylist->MakeNameUnique(char* name);
$entitylist->Marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
$entitylist->Marquee(uint32 type, string message, uint32 duration);
$entitylist->Marquee(uint32 type, string message);
$entitylist->MassGroupBuff(Mob* caster, Mob* center, uint16 spell_id);
$entitylist->MassGroupBuff(Mob* caster, Mob* center, uint16 spell_id, bool affect_caster);
$entitylist->Message(uint32 guild_id, uint32 color_type, string message);
$entitylist->MessageClose(Mob* sender, bool skip_sender, float distance, uint32 color_type, string message);
$entitylist->MessageGroup(Mob* sender, bool skip_close, uint32_t emote_color_type, string message);
$entitylist->MessageStatus(uint32 guild_id, int to_minstatus, uint32 color_type, string message);
$entitylist->OpenDoorsNear(Mob* opener);
$entitylist->RemoveAllClients();
$entitylist->RemoveAllCorpses();
$entitylist->RemoveAllDoors();
$entitylist->RemoveAllGroups();
$entitylist->RemoveAllMobs();
$entitylist->RemoveAllNPCs();
$entitylist->RemoveAllObjects();
$entitylist->RemoveAllTraps();
$entitylist->RemoveClient(uint16_t delete_id);
$entitylist->RemoveCorpse(uint16_t delete_id);
$entitylist->RemoveDoor(uint16_t delete_id);
$entitylist->RemoveEntity(uint16_t id);
$entitylist->RemoveFromHateLists(Mob* mob, bool set_to_one);
$entitylist->RemoveFromHateLists(Mob* mob);
$entitylist->RemoveFromTargets(Mob* mob);
$entitylist->RemoveGroup(uint32_t delete_id);
$entitylist->RemoveMob(uint16_t delete_id);
$entitylist->RemoveNPC(uint16_t delete_id);
$entitylist->RemoveNumbers(char* name);
$entitylist->RemoveObject(uint16_t delete_id);
$entitylist->RemoveTrap(uint16_t delete_id);
$entitylist->ReplaceWithTarget(Mob* old_mob, Mob* new_target);
$entitylist->SignalAllBotsByOwnerCharacterID(uint32_t character_id, int signal_id);
$entitylist->SignalAllBotsByOwnerName(string owner_name, int signal_id);
$entitylist->SignalAllClients(int signal_id);
$entitylist->SignalBotByBotID(uint32_t bot_id, int signal_id);
$entitylist->SignalBotByBotName(string bot_name, int signal_id);
$entitylist->SignalMobsByNPCID(uint32 npc_type_id, int signal_id);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`entitylist:AreaAttack(Mob attacker, float distance);
entitylist:AreaAttack(Mob attacker, float distance, int16 slot_id, int count, bool is_from_spell, int attack_rounds);
entitylist:AreaAttack(Mob attacker, float distance, int16 slot_id, int count, bool is_from_spell);
entitylist:AreaAttack(Mob attacker, float distance, int16 slot_id, int count);
entitylist:AreaAttack(Mob attacker, float distance, int16 slot_id);
entitylist:AreaSpell(Mob caster, Mob center, uint16 spell_id, bool affect_caster, int16 resist_adjust);
entitylist:AreaSpell(Mob caster, Mob center, uint16 spell_id);
entitylist:AreaSpell(Mob caster, Mob center, uint16 spell_id, bool affect_caster);
entitylist:AreaSpell(Mob caster, Mob center, uint16 spell_id, bool affect_caster, int16 resist_adjust, int max_targets);
entitylist:AreaTaunt(Client caster, float range);
entitylist:AreaTaunt(Client caster, float range, int bonus_hate);
entitylist:AreaTaunt(Client caster);
entitylist:CanAddHateForMob(Mob p);
entitylist:ChannelMessage(Mob from, int channel_num, uint8 language_id, string message);
entitylist:ClearClientPetitionQueue();
entitylist:ClearFeignAggro(Mob who);
entitylist:DeleteNPCCorpses();
entitylist:DeletePlayerCorpses();
entitylist:DoubleAggro(Mob who);
entitylist:Fighting(Mob who);
entitylist:FilteredMessageClose(Mob sender, bool skip_sender, float dist, uint32 type, int filter, string message);
entitylist:FindDoor(uint32 id);
entitylist:GetBotByID(uint32 bot_id);
entitylist:GetBotByName(string bot_name);
entitylist:GetBotList();
entitylist:GetBotListByCharacterID(uint32 character_id, uint8 class_id);
entitylist:GetBotListByCharacterID(uint32 character_id);
entitylist:GetBotListByClientName(string client_name);
entitylist:GetBotListByClientName(string client_name, uint8 class_id);
entitylist:GetBotOwnerByBotEntityID(uint32 entity_id);
entitylist:GetBotOwnerByBotID(uint32 bot_id);
entitylist:GetClientByAccID(uint32 acct_id);
entitylist:GetClientByCharID(uint32 char_id);
entitylist:GetClientByID(int id);
entitylist:GetClientByName(string name);
entitylist:GetClientByWID(uint32 wid);
entitylist:GetClientList();
entitylist:GetCloseMobList(Mob mob);
entitylist:GetCloseMobList(Mob mob, float distance, bool ignore_self);
entitylist:GetCloseMobList(Mob mob, float distance);
entitylist:GetCorpseByID(int id);
entitylist:GetCorpseByName(string name);
entitylist:GetCorpseByOwner(Client client);
entitylist:GetCorpseList();
entitylist:GetDoorsByDBID(uint32 db_id);
entitylist:GetDoorsByDoorID(uint32 door_id);
entitylist:GetDoorsByID(int id);
entitylist:GetDoorsList();
entitylist:GetGroupByClient(Client client);
entitylist:GetGroupByID(int id);
entitylist:GetGroupByLeaderName(string name);
entitylist:GetGroupByMob(Mob mob);
entitylist:GetMob(int id);
entitylist:GetMob(string name);
entitylist:GetMobByNpcTypeID(int npc_type);
entitylist:GetMobID(int id);
entitylist:GetMobList();
entitylist:GetNPCByID(int id);
entitylist:GetNPCByNPCTypeID(int npc_type);
entitylist:GetNPCBySpawnID(uint32 spawn_id);
entitylist:GetNPCList();
entitylist:GetObjectByDBID(uint32 db_id);
entitylist:GetObjectByID(int id);
entitylist:GetObjectList();
entitylist:GetRaidByClient(Client client);
entitylist:GetRaidByID(int id);
entitylist:GetRandomBot();
entitylist:GetRandomBot(float x, float y, float z, float distance);
entitylist:GetRandomBot(float x, float y, float z, float distance, exclude_bot);
entitylist:GetRandomClient(float x, float y, float z, float distance);
entitylist:GetRandomClient();
entitylist:GetRandomClient(float x, float y, float z, float distance, exclude_client);
entitylist:GetRandomMob(float x, float y, float z, float distance, exclude_mob);
entitylist:GetRandomMob();
entitylist:GetRandomMob(float x, float y, float z, float distance);
entitylist:GetRandomNPC(float x, float y, float z, float distance, exclude_npc);
entitylist:GetRandomNPC(float x, float y, float z, float distance);
entitylist:GetRandomNPC();
entitylist:GetShuffledClientList();
entitylist:GetSpawnByID(uint32 id);
entitylist:GetSpawnList();
entitylist:HalveAggro(Mob who);
entitylist:IsMobSpawnedByNpcTypeID(int npc_type);
entitylist:MakeNameUnique(string name);
entitylist:Marquee(uint32 type, string message);
entitylist:Marquee(uint32 type, string message, uint32 duration);
entitylist:Marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
entitylist:MassGroupBuff(Mob caster, Mob center, uint16 spell_id);
entitylist:MassGroupBuff(Mob caster, Mob center, uint16 spell_id, bool affect_caster);
entitylist:Message(uint32 guild_dbid, uint32 type, string message);
entitylist:MessageClose(Mob sender, bool skip_sender, float dist, uint32 type, string message);
entitylist:MessageGroup(Mob who, bool skip_close, uint32 type, string message);
entitylist:MessageStatus(uint32 guild_dbid, int min_status, uint32 type, string message);
entitylist:OpenDoorsNear(Mob opener);
entitylist:RemoveFromHateLists(Mob who, bool set_to_one);
entitylist:RemoveFromHateLists(Mob who);
entitylist:RemoveFromTargets(Mob mob);
entitylist:RemoveFromTargets(Mob mob, bool RemoveFromXTargets);
entitylist:RemoveNumbers(string name);
entitylist:ReplaceWithTarget(Mob target, Mob new_target);
entitylist:SignalAllBotsByOwnerCharacterID(uint32 character_id, int signal_id);
entitylist:SignalAllBotsByOwnerName(string owner_name, int signal_id);
entitylist:SignalAllClients(int signal_id);
entitylist:SignalBotByBotID(uint32 bot_id, int signal_id);
entitylist:SignalBotByBotName(string bot_name, int signal_id);
entitylist:SignalMobsByNPCID(uint32 npc_id, int signal_id);
`
```

---

## eq

*Source: quest-api/methods/eq/index.html*

# eq

Lua (894)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`eq.active_speak_activity(task_id);
eq.active_speak_task();
eq.active_tasks_in_set(task_set);
eq.add_area(int id, int type, float min_x, float max_x, float min_y, float max_y, float min_z, float max_z);
eq.add_expedition_lockout_all_clients(string expedition_name, string event_name, uint32 seconds);
eq.add_expedition_lockout_all_clients(string expedition_name, string event_name, uint32 seconds, string uuid);
eq.add_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name, uint32 seconds, string uuid);
eq.add_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name, uint32 seconds);
eq.add_ldon_loss(uint32 theme_id);
eq.add_ldon_points(uint32 theme_id, int points);
eq.add_ldon_win(uint32 theme_id);
eq.add_spawn_point(object table);
eq.assign_group_to_instance(uint32 instance_id);
eq.assign_raid_to_instance(uint32 instance_id);
eq.assign_task(int task_id);
eq.assign_to_instance(uint32 instance_id);
eq.assign_to_instance_by_char_id(uint32 instance_id, uint32 character_id);
eq.attack(string client_name);
eq.attack_npc(int entity_id);
eq.attack_npc_type(int npc_type);
eq.bury_player_corpse(uint32 char_id);
eq.calculate_corruption_counters(uint16 spell_id);
eq.calculate_counters(uint16 spell_id);
eq.calculate_curse_counters(uint16 spell_id);
eq.calculate_disease_counters(uint16 spell_id);
eq.calculate_poison_counters(uint16 spell_id);
eq.cast_spell(uint16 spell_id, uint16 target_id);
eq.check_instance_by_char_id(uint32 instance_id, uint32 character_id);
eq.check_name_filter(string name);
eq.check_title(uint32 title_set);
eq.clear_areas();
eq.clear_npctype_cache(int npctype_id);
eq.clear_opcode(int op);
eq.clear_proximity();
eq.clear_spawn_timers();
eq.clock();
eq.collect_items(uint32 item_id, bool remove);
eq.commify(number);
eq.completed_tasks_in_set(task_set);
eq.count_item(uint32 item_id);
eq.count_spawned_npcs(object table);
eq.create_door(string model, float x, float y, float z, float h);
eq.create_door(string model, float x, float y, float z, float h, uint8 open_type);
eq.create_door(string model, float x, float y, float z, float h, uint8 open_type, size);
eq.create_ground_object(uint32 item_id, float x, float y, float z, float h);
eq.create_ground_object(uint32 item_id, float x, float y, float z, float h, uint32 decay_time);
eq.create_ground_object_from_model(string model, float x, float y, float z, float h, uint8 type);
eq.create_ground_object_from_model(string model, float x, float y, float z, float h, uint8 type, uint32 decay_time);
eq.create_ground_object_from_model(string model, float x, float y, float z, float h);
eq.create_guild(string name, string leader);
eq.create_instance(string zone, version, duration);
eq.create_npc(object table, float x, float y, float z, float heading);
eq.cross_zone_add_ldon_loss_by_char_id(int character_id, uint32 theme_id);
eq.cross_zone_add_ldon_loss_by_client_name(string client_name, uint32 theme_id);
eq.cross_zone_add_ldon_loss_by_expedition_id(uint32 expedition_id, uint32 theme_id);
eq.cross_zone_add_ldon_loss_by_group_id(int group_id, uint32 theme_id);
eq.cross_zone_add_ldon_loss_by_guild_id(int guild_id, uint32 theme_id);
eq.cross_zone_add_ldon_loss_by_raid_id(int raid_id, uint32 theme_id);
eq.cross_zone_add_ldon_points_by_char_id(int character_id, uint32 theme_id, int points);
eq.cross_zone_add_ldon_points_by_client_name(string client_name, uint32 theme_id, int points);
eq.cross_zone_add_ldon_points_by_expedition_id(uint32 expedition_id, uint32 theme_id, int points);
eq.cross_zone_add_ldon_points_by_group_id(int group_id, uint32 theme_id, int points);
eq.cross_zone_add_ldon_points_by_guild_id(int guild_id, uint32 theme_id, int points);
eq.cross_zone_add_ldon_points_by_raid_id(int raid_id, uint32 theme_id, int points);
eq.cross_zone_add_ldon_win_by_char_id(int character_id, uint32 theme_id);
eq.cross_zone_add_ldon_win_by_client_name(string client_name, uint32 theme_id);
eq.cross_zone_add_ldon_win_by_expedition_id(uint32 expedition_id, uint32 theme_id);
eq.cross_zone_add_ldon_win_by_group_id(int group_id, uint32 theme_id);
eq.cross_zone_add_ldon_win_by_guild_id(int guild_id, uint32 theme_id);
eq.cross_zone_add_ldon_win_by_raid_id(int raid_id, uint32 theme_id);
eq.cross_zone_assign_task_by_char_id(int character_id, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_assign_task_by_char_id(int character_id, uint32 task_id);
eq.cross_zone_assign_task_by_client_name(string client_name, uint32 task_id);
eq.cross_zone_assign_task_by_client_name(string client_name, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_assign_task_by_expedition_id(uint32 expedition_id, uint32 task_id);
eq.cross_zone_assign_task_by_expedition_id(uint32 expedition_id, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_assign_task_by_group_id(int group_id, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_assign_task_by_group_id(int group_id, uint32 task_id);
eq.cross_zone_assign_task_by_guild_id(int guild_id, uint32 task_id);
eq.cross_zone_assign_task_by_guild_id(int guild_id, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_assign_task_by_raid_id(int raid_id, uint32 task_id);
eq.cross_zone_assign_task_by_raid_id(int raid_id, uint32 task_id, bool enforce_level_requirement);
eq.cross_zone_cast_spell_by_char_id(int character_id, uint32 spell_id);
eq.cross_zone_cast_spell_by_client_name(string client_name, uint32 spell_id);
eq.cross_zone_cast_spell_by_expedition_id(uint32 expedition_id, uint32 spell_id);
eq.cross_zone_cast_spell_by_group_id(int group_id, uint32 spell_id);
eq.cross_zone_cast_spell_by_guild_id(int guild_id, uint32 spell_id);
eq.cross_zone_cast_spell_by_raid_id(int raid_id, uint32 spell_id);
eq.cross_zone_dialogue_window_by_char_id(int character_id, string message);
eq.cross_zone_dialogue_window_by_client_name(string client_name, string message);
eq.cross_zone_dialogue_window_by_expedition_id(uint32 expedition_id, string message);
eq.cross_zone_dialogue_window_by_group_id(int group_id, string message);
eq.cross_zone_dialogue_window_by_guild_id(int guild_id, string message);
eq.cross_zone_dialogue_window_by_raid_id(int raid_id, string message);
eq.cross_zone_disable_task_by_char_id(int character_id, uint32 task_id);
eq.cross_zone_disable_task_by_client_name(string client_name, uint32 task_id);
eq.cross_zone_disable_task_by_expedition_id(uint32 expedition_id, uint32 task_id);
eq.cross_zone_disable_task_by_group_id(int group_id, uint32 task_id);
eq.cross_zone_disable_task_by_guild_id(int guild_id, uint32 task_id);
eq.cross_zone_disable_task_by_raid_id(int raid_id, uint32 task_id);
eq.cross_zone_enable_task_by_char_id(int character_id, uint32 task_id);
eq.cross_zone_enable_task_by_client_name(string client_name, uint32 task_id);
eq.cross_zone_enable_task_by_expedition_id(uint32 expedition_id, uint32 task_id);
eq.cross_zone_enable_task_by_group_id(int group_id, uint32 task_id);
eq.cross_zone_enable_task_by_guild_id(int guild_id, uint32 task_id);
eq.cross_zone_enable_task_by_raid_id(int raid_id, uint32 task_id);
eq.cross_zone_fail_task_by_char_id(int character_id, uint32 task_id);
eq.cross_zone_fail_task_by_client_name(string client_name, uint32 task_id);
eq.cross_zone_fail_task_by_expedition_id(uint32 expedition_id, uint32 task_id);
eq.cross_zone_fail_task_by_group_id(int group_id, uint32 task_id);
eq.cross_zone_fail_task_by_guild_id(int guild_id, uint32 task_id);
eq.cross_zone_fail_task_by_raid_id(int raid_id, uint32 task_id);
eq.cross_zone_marquee_by_char_id(int character_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_marquee_by_client_name(string client_name, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_marquee_by_expedition_id(uint32 expedition_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_marquee_by_group_id(int group_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_marquee_by_guild_id(int guild_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_marquee_by_raid_id(int raid_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.cross_zone_message_player_by_char_id(uint32 type, int character_id, string message);
eq.cross_zone_message_player_by_expedition_id(uint32 type, int expedition_id, string message);
eq.cross_zone_message_player_by_group_id(uint32 type, int group_id, string message);
eq.cross_zone_message_player_by_guild_id(uint32 type, int guild_id, string message);
eq.cross_zone_message_player_by_name(uint32 type, string client_name, string message);
eq.cross_zone_message_player_by_raid_id(uint32 type, int raid_id, string message);
eq.cross_zone_move_instance_by_char_id(uint32 character_id, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_char_id(uint32 character_id, uint16 instance_id);
eq.cross_zone_move_instance_by_char_id(uint32 character_id, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_instance_by_client_name(string client_name, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_instance_by_client_name(string client_name, uint16 instance_id);
eq.cross_zone_move_instance_by_client_name(string client_name, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_expedition_id(uint32 expedition_id, uint16 instance_id);
eq.cross_zone_move_instance_by_expedition_id(uint32 expedition_id, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_instance_by_expedition_id(uint32 expedition_id, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_group_id(uint32 group_id, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_group_id(uint32 group_id, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_instance_by_group_id(uint32 group_id, uint16 instance_id);
eq.cross_zone_move_instance_by_guild_id(uint32 guild_id, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_instance_by_guild_id(uint32 guild_id, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_guild_id(uint32 guild_id, uint16 instance_id);
eq.cross_zone_move_instance_by_raid_id(uint32 raid_id, uint16 instance_id);
eq.cross_zone_move_instance_by_raid_id(uint32 raid_id, uint16 instance_id, float x, float y, float z, float heading);
eq.cross_zone_move_instance_by_raid_id(uint32 raid_id, uint16 instance_id, float x, float y, float z);
eq.cross_zone_move_player_by_char_id(uint32 character_id, string zone_short_name, float x, float y, float z);
eq.cross_zone_move_player_by_char_id(uint32 character_id, string zone_short_name);
eq.cross_zone_move_player_by_char_id(uint32 character_id, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_client_name(string client_name, string zone_short_name);
eq.cross_zone_move_player_by_client_name(string client_name, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_client_name(string client_name, string zone_short_name, float x, float y, float z);
eq.cross_zone_move_player_by_expedition_id(uint32 expedition_id, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_expedition_id(uint32 expedition_id, string zone_short_name, float x, float y, float z);
eq.cross_zone_move_player_by_expedition_id(uint32 expedition_id, string zone_short_name);
eq.cross_zone_move_player_by_group_id(uint32 group_id, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_group_id(uint32 group_id, string zone_short_name);
eq.cross_zone_move_player_by_group_id(uint32 group_id, string zone_short_name, float x, float y, float z);
eq.cross_zone_move_player_by_guild_id(uint32 guild_id, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_guild_id(uint32 guild_id, string zone_short_name, float x, float y, float z);
eq.cross_zone_move_player_by_guild_id(uint32 guild_id, string zone_short_name);
eq.cross_zone_move_player_by_raid_id(uint32 raid_id, string zone_short_name);
eq.cross_zone_move_player_by_raid_id(uint32 raid_id, string zone_short_name, float x, float y, float z, float heading);
eq.cross_zone_move_player_by_raid_id(uint32 raid_id, string zone_short_name, float x, float y, float z);
eq.cross_zone_remove_ldon_loss_by_char_id(int character_id, uint32 theme_id);
eq.cross_zone_remove_ldon_loss_by_client_name(string client_name, uint32 theme_id);
eq.cross_zone_remove_ldon_loss_by_expedition_id(uint32 expedition_id, uint32 theme_id);
eq.cross_zone_remove_ldon_loss_by_group_id(int group_id, uint32 theme_id);
eq.cross_zone_remove_ldon_loss_by_guild_id(int guild_id, uint32 theme_id);
eq.cross_zone_remove_ldon_loss_by_raid_id(int raid_id, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_char_id(int character_id, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_client_name(string client_name, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_expedition_id(uint32 expedition_id, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_group_id(int group_id, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_guild_id(int guild_id, uint32 theme_id);
eq.cross_zone_remove_ldon_win_by_raid_id(int raid_id, uint32 theme_id);
eq.cross_zone_remove_spell_by_char_id(int character_id, uint32 spell_id);
eq.cross_zone_remove_spell_by_client_name(string client_name, uint32 spell_id);
eq.cross_zone_remove_spell_by_expedition_id(uint32 expedition_id, uint32 spell_id);
eq.cross_zone_remove_spell_by_group_id(int group_id, uint32 spell_id);
eq.cross_zone_remove_spell_by_guild_id(int guild_id, uint32 spell_id);
eq.cross_zone_remove_spell_by_raid_id(int raid_id, uint32 spell_id);
eq.cross_zone_remove_task_by_char_id(int character_id, uint32 task_id);
eq.cross_zone_remove_task_by_client_name(string client_name, uint32 task_id);
eq.cross_zone_remove_task_by_expedition_id(uint32 expedition_id, uint32 task_id);
eq.cross_zone_remove_task_by_group_id(int group_id, uint32 task_id);
eq.cross_zone_remove_task_by_guild_id(int guild_id, uint32 task_id);
eq.cross_zone_remove_task_by_raid_id(int raid_id, uint32 task_id);
eq.cross_zone_reset_activity_by_char_id(int character_id, uint32 task_id, int activity_id);
eq.cross_zone_reset_activity_by_client_name(string client_name, uint32 task_id, int activity_id);
eq.cross_zone_reset_activity_by_expedition_id(uint32 expedition_id, uint32 task_id, int activity_id);
eq.cross_zone_reset_activity_by_group_id(int group_id, uint32 task_id, int activity_id);
eq.cross_zone_reset_activity_by_guild_id(int guild_id, uint32 task_id, int activity_id);
eq.cross_zone_reset_activity_by_raid_id(int raid_id, uint32 task_id, int activity_id);
eq.cross_zone_set_entity_variable_by_char_id(int character_id, string variable_name, string variable_value);
eq.cross_zone_set_entity_variable_by_client_name(string character_name, string variable_name, string variable_value);
eq.cross_zone_set_entity_variable_by_expedition_id(uint32 expedition_id, string variable_name, string variable_value);
eq.cross_zone_set_entity_variable_by_group_id(int group_id, string variable_name, string variable_value);
eq.cross_zone_set_entity_variable_by_guild_id(int guild_id, string variable_name, string variable_value);
eq.cross_zone_set_entity_variable_by_raid_id(int raid_id, string variable_name, string variable_value);
eq.cross_zone_signal_client_by_char_id(uint32 character_id, int signal_id);
eq.cross_zone_signal_client_by_expedition_id(uint32 expedition_id, int signal_id);
eq.cross_zone_signal_client_by_group_id(uint32 group_id, int signal_id);
eq.cross_zone_signal_client_by_guild_id(uint32 guild_id, int signal_id);
eq.cross_zone_signal_client_by_name(string client_name, int signal_id);
eq.cross_zone_signal_client_by_raid_id(uint32 raid_id, int signal_id);
eq.cross_zone_signal_npc_by_npctype_id(uint32 npctype_id, int signal_id);
eq.cross_zone_update_activity_by_char_id(int character_id, uint32 task_id, int activity_id, int activity_count);
eq.cross_zone_update_activity_by_char_id(int character_id, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_client_name(string client_name, uint32 task_id, int activity_id, int activity_count);
eq.cross_zone_update_activity_by_client_name(string client_name, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_expedition_id(uint32 expedition_id, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_expedition_id(uint32 expedition_id, uint32 task_id, int activity_id, int activity_count);
eq.cross_zone_update_activity_by_group_id(int group_id, uint32 task_id, int activity_id, int activity_count);
eq.cross_zone_update_activity_by_group_id(int group_id, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_guild_id(int guild_id, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_guild_id(int guild_id, uint32 task_id, int activity_id, int activity_count);
eq.cross_zone_update_activity_by_raid_id(int raid_id, uint32 task_id, int activity_id);
eq.cross_zone_update_activity_by_raid_id(int raid_id, uint32 task_id, int activity_id, int activity_count);
eq.debug(string message);
eq.debug(string message, int level);
eq.delete_data(string bucket_key);
eq.delete_global(string name);
eq.depop(int npc_type);
eq.depop();
eq.depop_all(int npc_type);
eq.depop_all();
eq.depop_with_timer(int npc_type);
eq.depop_with_timer();
eq.depop_zone(bool start_spawn_status);
eq.destroy_instance(uint32 instance_id);
eq.disable_proximity_say();
eq.disable_recipe(uint32 recipe_id);
eq.disable_spawn2(int spawn2_id);
eq.disable_task(object table);
eq.discord_send(string webhook_name, string message);
eq.do_anim(int animation_id);
eq.do_anim(int animation_id, int animation_speed);
eq.do_anim(int animation_id, int animation_speed, bool ackreq, int filter);
eq.do_anim(int animation_id, int animation_speed, bool ackreq);
eq.do_augment_slots_match(uint32 item_one, uint32 item_two);
eq.does_augment_fit(ItemInst inst, uint32 augment_id);
eq.does_augment_fit_slot(ItemInst inst, uint32 augment_id, uaugment_slot);
eq.enable_proximity_say();
eq.enable_recipe(uint32 recipe_id);
eq.enable_spawn2(int spawn2_id);
eq.enable_task(object table);
eq.enable_title(uint32 title_set);
eq.enabled_task_count(task_set);
eq.end_dz_task(bool send_fail);
eq.end_dz_task();
eq.faction_value();
eq.fail_task(int task_id);
eq.first_task_in_set(task_set);
eq.flag_instance_by_group_leader(uint32 zone, uint32 version);
eq.flag_instance_by_raid_leader(uint32 zone, uint32 version);
eq.fly_mode(int flymode);
eq.follow(int entity_id);
eq.follow(int entity_id, int distance);
eq.get_aa_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, int16 instance_version);
eq.get_aa_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id);
eq.get_aa_name(int aa_id);
eq.get_auto_login_character_name_by_account_id(uint32 account_id);
eq.get_body_type_name(uint8 body_type_id);
eq.get_bot_class_by_id(uint32 bot_id);
eq.get_bot_gender_by_id(uint32 bot_id);
eq.get_bot_level_by_id(uint32 bot_id);
eq.get_bot_name_by_id(uint32 bot_id);
eq.get_bot_race_by_id(uint32 bot_id);
eq.get_char_id_by_name(string name);
eq.get_char_name_by_id(uint32 char_id);
eq.get_characters_in_instance(uint16 instance_id);
eq.get_class_bitmask(uint8 class_id);
eq.get_class_name(uint8 class_id, uint8 level);
eq.get_class_name(uint8 class_id);
eq.get_clean_npc_name_by_id(uint32 npc_id);
eq.get_consider_level_name(uint8 consider_level);
eq.get_currency_id(item_id);
eq.get_currency_item_id(currency_id);
eq.get_data(bucket_key);
eq.get_data_expires(bucket_key);
eq.get_data_remaining(bucket_name);
eq.get_deity_bitmask(deity_id);
eq.get_deity_name(uint32 deity_id);
eq.get_dz_task_id();
eq.get_encounter();
eq.get_entity_list();
eq.get_environmental_damage_name(uint8 damage_type);
eq.get_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id);
eq.get_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, int16 instance_version);
eq.get_expedition();
eq.get_expedition_by_char_id(uint32 char_id);
eq.get_expedition_by_dz_id(uint32 dz_id);
eq.get_expedition_by_zone_instance(uint32 zone_id, uint32 instance_id);
eq.get_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name);
eq.get_expedition_lockouts_by_char_id(uint32 char_id, string expedition_name);
eq.get_expedition_lockouts_by_char_id(uint32 char_id);
eq.get_faction_name(int faction_id);
eq.get_gender_name(uint32 gender_id);
eq.get_group_id_by_char_id(uint32 char_id);
eq.get_guild_id_by_char_id(uint32 char_id);
eq.get_guild_name_by_id(uint32 guild_id);
eq.get_hex_color_code(color_name);
eq.get_initiator();
eq.get_instance_id(string zone, uint32 version);
eq.get_instance_id_by_char_id(string zone, uint32 version, uint32 character_id);
eq.get_instance_ids(string zone_name);
eq.get_instance_ids_by_char_id(string zone_name, uint32 character_id);
eq.get_instance_timer();
eq.get_instance_timer_by_id(uint16 instance_id);
eq.get_instance_version_by_id(uint16 instance_id);
eq.get_instance_zone_id_by_id(uint16 instance_id);
eq.get_inventory_slot_name(int16 slot_id);
eq.get_item_comment(uint32 item_id);
eq.get_item_lore(uint32 item_id);
eq.get_item_name(uint32 item_id);
eq.get_language_name(uint8 language_id);
eq.get_ldon_theme_name(uint32 theme_id);
eq.get_level(type);
eq.get_npc_name_by_id(uint32 npc_id);
eq.get_owner();
eq.get_player_buried_corpse_count(uint32 character_id);
eq.get_player_corpse_count(uint32 character_id);
eq.get_player_corpse_count_by_zone_id(uint32 character_id, uint32 zone_id);
eq.get_qglobals(NPC npc, Client client);
eq.get_qglobals(Client client);
eq.get_qglobals(NPC npc);
eq.get_qglobals();
eq.get_quest_item();
eq.get_quest_spell();
eq.get_race_bitmask(race_id);
eq.get_race_name(uint32 race_id);
eq.get_raid_id_by_char_id(uint32 char_id);
eq.get_recipe_component_count(uint32 recipe_id, uint32 item_id);
eq.get_recipe_fail_count(uint32 recipe_id, uint32 item_id);
eq.get_recipe_made_count(uint32 recipe_id);
eq.get_recipe_name(uint32 recipe_id);
eq.get_recipe_salvage_count(uint32 recipe_id, uint32 item_id);
eq.get_recipe_salvage_item_ids(uint32 recipe_id);
eq.get_recipe_success_count(uint32 recipe_id, uint32 item_id);
eq.get_recipe_success_item_ids(uint32 recipe_id);
eq.get_remaining_time(string timer);
eq.get_rule(rule_name);
eq.get_skill_name(int skill_id);
eq.get_spawn_condition(string zone, uint32 instance_id, condition_id);
eq.get_spell(uint32 spell_id);
eq.get_spell_effect_description_number(uint16 spell_id);
eq.get_spell_effect_index(uint16 spell_id, effect_id);
eq.get_spell_furious_bash(uint16 spell_id);
eq.get_spell_level(uint16 spell_id, class_id);
eq.get_spell_minimum_level(uint16 spell_id);
eq.get_spell_name(uint32 spell_id);
eq.get_spell_nimbus_effect(uint16 spell_id);
eq.get_spell_partial_magic_rune_amount(uint16 spell_id);
eq.get_spell_partial_magic_rune_reduction(uint16 spell_id);
eq.get_spell_partial_melee_rune_amount(uint16 spell_id);
eq.get_spell_partial_melee_rune_reduction(uint16 spell_id);
eq.get_spell_proc_limit_timer(uint16 spell_id, proc_type);
eq.get_spell_resist_type(uint16 spell_id);
eq.get_spell_resurrection_sickness_check(uint16 spell_id_one, uint16 spell_id_two);
eq.get_spell_stat(uint32 spell_id, string stat_identifier);
eq.get_spell_stat(uint32 spell_id, string stat_identifier, uint8 slot);
eq.get_spell_target_type(uint16 spell_id);
eq.get_spell_trigger_spell_id(spell_id, int effect_id);
eq.get_spell_viral_maximum_spread_time(uint16 spell_id);
eq.get_spell_viral_minimum_spread_time(uint16 spell_id);
eq.get_spell_viral_spread_range(uint16 spell_id);
eq.get_task_activity_done_count(task, activity);
eq.get_task_name(uint32 task_id);
eq.get_timer_duration(string timer);
eq.get_zone_bypass_expansion_check(uint32 zone_id, int version);
eq.get_zone_bypass_expansion_check(uint32 zone_id);
eq.get_zone_can_bind(uint32 zone_id);
eq.get_zone_can_bind(uint32 zone_id, int version);
eq.get_zone_can_combat(uint32 zone_id);
eq.get_zone_can_combat(uint32 zone_id, int version);
eq.get_zone_can_levitate(uint32 zone_id);
eq.get_zone_can_levitate(uint32 zone_id, int version);
eq.get_zone_cast_outdoor(uint32 zone_id);
eq.get_zone_cast_outdoor(uint32 zone_id, int version);
eq.get_zone_content_flags(uint32 zone_id, int version);
eq.get_zone_content_flags(uint32 zone_id);
eq.get_zone_content_flags_disabled(uint32 zone_id, int version);
eq.get_zone_content_flags_disabled(uint32 zone_id);
eq.get_zone_expansion(uint32 zone_id, int version);
eq.get_zone_expansion(uint32 zone_id);
eq.get_zone_experience_multiplier(uint32 zone_id, int version);
eq.get_zone_experience_multiplier(uint32 zone_id);
eq.get_zone_fast_regen_endurance(uint32 zone_id, version);
eq.get_zone_fast_regen_endurance(uint32 zone_id);
eq.get_zone_fast_regen_hp(uint32 zone_id);
eq.get_zone_fast_regen_hp(uint32 zone_id, version);
eq.get_zone_fast_regen_mana(uint32 zone_id);
eq.get_zone_fast_regen_mana(uint32 zone_id, version);
eq.get_zone_flag_needed(uint32 zone_id);
eq.get_zone_flag_needed(uint32 zone_id, int version);
eq.get_zone_fog_blue(uint32 zone_id);
eq.get_zone_fog_blue(uint32 zone_id, slot);
eq.get_zone_fog_blue(uint32 zone_id, slot, int version);
eq.get_zone_fog_density(uint32 zone_id, int version);
eq.get_zone_fog_density(uint32 zone_id);
eq.get_zone_fog_green(uint32 zone_id);
eq.get_zone_fog_green(uint32 zone_id, slot, int version);
eq.get_zone_fog_green(uint32 zone_id, slot);
eq.get_zone_fog_maximum_clip(uint32 zone_id, uint8 slot);
eq.get_zone_fog_maximum_clip(uint32 zone_id, uint8 slot, int version);
eq.get_zone_fog_maximum_clip(uint32 zone_id);
eq.get_zone_fog_minimum_clip(uint32 zone_id);
eq.get_zone_fog_minimum_clip(uint32 zone_id, uint8 slot, int version);
eq.get_zone_fog_minimum_clip(uint32 zone_id, uint8 slot);
eq.get_zone_fog_red(uint32 zone_id, slot, int version);
eq.get_zone_fog_red(uint32 zone_id, slot);
eq.get_zone_fog_red(uint32 zone_id);
eq.get_zone_graveyard_id(uint32 zone_id, int version);
eq.get_zone_graveyard_id(uint32 zone_id);
eq.get_zone_gravity(uint32 zone_id, int version);
eq.get_zone_gravity(uint32 zone_id);
eq.get_zone_hotzone(uint32 zone_id, int version);
eq.get_zone_hotzone(uint32 zone_id);
eq.get_zone_id();
eq.get_zone_id_by_long_name(string zone_long_name);
eq.get_zone_id_by_name(string zone_name);
eq.get_zone_idle_when_empty(uint32 zone_id, int version);
eq.get_zone_idle_when_empty(uint32 zone_id);
eq.get_zone_instance_id();
eq.get_zone_instance_type(uint32 zone_id);
eq.get_zone_instance_type(uint32 zone_id, int version);
eq.get_zone_instance_version();
eq.get_zone_lava_damage(uint32 zone_id, version);
eq.get_zone_lava_damage(uint32 zone_id);
eq.get_zone_long_name();
eq.get_zone_long_name_by_id(uint32 zone_id);
eq.get_zone_long_name_by_name(zone_name);
eq.get_zone_maximum_clip(uint32 zone_id);
eq.get_zone_maximum_clip(uint32 zone_id, int version);
eq.get_zone_maximum_expansion(uint32 zone_id);
eq.get_zone_maximum_expansion(uint32 zone_id, int version);
eq.get_zone_maximum_level(uint32 zone_id, int version);
eq.get_zone_maximum_level(uint32 zone_id);
eq.get_zone_maximum_movement_update_range(zone_id, int version);
eq.get_zone_maximum_movement_update_range(zone_id);
eq.get_zone_maximum_players(uint32 zone_id, version);
eq.get_zone_maximum_players(uint32 zone_id);
eq.get_zone_minimum_clip(uint32 zone_id, int version);
eq.get_zone_minimum_clip(uint32 zone_id);
eq.get_zone_minimum_expansion(uint32 zone_id);
eq.get_zone_minimum_expansion(uint32 zone_id, int version);
eq.get_zone_minimum_lava_damage(uint32 zone_id);
eq.get_zone_minimum_lava_damage(uint32 zone_id, version);
eq.get_zone_minimum_level(uint32 zone_id);
eq.get_zone_minimum_level(uint32 zone_id, int version);
eq.get_zone_minimum_status(uint32 zone_id);
eq.get_zone_minimum_status(uint32 zone_id, int version);
eq.get_zone_note(uint32 zone_id);
eq.get_zone_note(uint32 zone_id, int version);
eq.get_zone_npc_maximum_aggro_distance(uint32 zone_id, version);
eq.get_zone_npc_maximum_aggro_distance(uint32 zone_id);
eq.get_zone_peqzone(uint32 zone_id, int version);
eq.get_zone_peqzone(uint32 zone_id);
eq.get_zone_rain_chance(uint32 zone_id);
eq.get_zone_rain_chance(uint32 zone_id, version);
eq.get_zone_rain_duration(uint32 zone_id);
eq.get_zone_rain_duration(uint32 zone_id, version);
eq.get_zone_rule_set(zone_id, int version);
eq.get_zone_rule_set(zone_id);
eq.get_zone_safe_heading(uint32 zone_id, int version);
eq.get_zone_safe_heading(uint32 zone_id);
eq.get_zone_safe_x(uint32 zone_id);
eq.get_zone_safe_x(uint32 zone_id, int version);
eq.get_zone_safe_y(uint32 zone_id);
eq.get_zone_safe_y(uint32 zone_id, int version);
eq.get_zone_safe_z(uint32 zone_id);
eq.get_zone_safe_z(uint32 zone_id, int version);
eq.get_zone_seconds_before_idle(zone_id);
eq.get_zone_seconds_before_idle(zone_id, int version);
eq.get_zone_short_name();
eq.get_zone_short_name_by_id(uint32 zone_id);
eq.get_zone_short_name_by_long_name(zone_long_name);
eq.get_zone_shutdown_delay(uint32 zone_id, int version);
eq.get_zone_shutdown_delay(uint32 zone_id);
eq.get_zone_sky(uint32 zone_id, int version);
eq.get_zone_sky(uint32 zone_id);
eq.get_zone_sky_lock(uint32 zone_id, version);
eq.get_zone_sky_lock(uint32 zone_id);
eq.get_zone_snow_chance(uint32 zone_id, version);
eq.get_zone_snow_chance(uint32 zone_id);
eq.get_zone_snow_duration(uint32 zone_id);
eq.get_zone_snow_duration(uint32 zone_id, version);
eq.get_zone_suspend_buffs(uint32 zone_id);
eq.get_zone_suspend_buffs(uint32 zone_id, int version);
eq.get_zone_time();
eq.get_zone_time_type(uint32 zone_id);
eq.get_zone_time_type(uint32 zone_id, int version);
eq.get_zone_time_zone(uint32 zone_id);
eq.get_zone_time_zone(uint32 zone_id, version);
eq.get_zone_type(uint32 zone_id, version);
eq.get_zone_type(uint32 zone_id);
eq.get_zone_underworld(uint32 zone_id);
eq.get_zone_underworld(uint32 zone_id, int version);
eq.get_zone_underworld_teleport_index(uint32 zone_id);
eq.get_zone_underworld_teleport_index(uint32 zone_id, version);
eq.get_zone_uptime();
eq.get_zone_walk_speed(uint32 zone_id, int version);
eq.get_zone_walk_speed(uint32 zone_id);
eq.get_zone_weather();
eq.get_zone_ztype(uint32 zone_id, int version);
eq.get_zone_ztype(uint32 zone_id);
eq.has_recipe_learned(uint32 recipe_id);
eq.has_timer(string timer);
eq.is_ae_duration_spell(uint16 spell_id);
eq.is_ae_nuke_spell(uint16 spell_id);
eq.is_ae_rain_nuke_spell(uint16 spell_id);
eq.is_alliance_spell(uint16 spell_id);
eq.is_bard_only_stack_effect(int effect_id);
eq.is_bard_song(uint16 spell_id);
eq.is_beneficial_spell(uint16 spell_id);
eq.is_blank_spell_effect(uint16 spell_id, int effect_index);
eq.is_blind_spell(uint16 spell_id);
eq.is_buff_spell(uint16 spell_id);
eq.is_call_of_the_forsaken_enabled();
eq.is_cast_not_standing_spell(uint16 spell_id);
eq.is_cast_on_fade_duration_spell(uint16 spell_id);
eq.is_cast_restricted_spell(uint16 spell_id);
eq.is_cast_time_reduction_spell(uint16 spell_id);
eq.is_cast_while_invisible_spell(uint16 spell_id);
eq.is_charm_spell(uint16 spell_id);
eq.is_classic_enabled();
eq.is_combat_skill(uint16 spell_id);
eq.is_complete_heal_duration_spell(uint16 spell_id);
eq.is_complete_heal_spell(uint16 spell_id);
eq.is_content_flag_enabled(string content_flag{);
eq.is_cure_spell(uint16 spell_id);
eq.is_current_expansion_call_of_the_forsaken();
eq.is_current_expansion_classic();
eq.is_current_expansion_depths_of_darkhollow();
eq.is_current_expansion_dragons_of_norrath();
eq.is_current_expansion_empires_of_kunark();
eq.is_current_expansion_gates_of_discord();
eq.is_current_expansion_house_of_thule();
eq.is_current_expansion_lost_dungeons_of_norrath();
eq.is_current_expansion_omens_of_war();
eq.is_current_expansion_prophecy_of_ro();
eq.is_current_expansion_rain_of_fear();
eq.is_current_expansion_ring_of_scale();
eq.is_current_expansion_secrets_of_faydwer();
eq.is_current_expansion_seeds_of_destruction();
eq.is_current_expansion_the_broken_mirror();
eq.is_current_expansion_the_buried_sea();
eq.is_current_expansion_the_burning_lands();
eq.is_current_expansion_the_darkened_sea();
eq.is_current_expansion_the_legacy_of_ykesha();
eq.is_current_expansion_the_planes_of_power();
eq.is_current_expansion_the_ruins_of_kunark();
eq.is_current_expansion_the_scars_of_velious();
eq.is_current_expansion_the_serpents_spine();
eq.is_current_expansion_the_shadows_of_luclin();
eq.is_current_expansion_torment_of_velious();
eq.is_current_expansion_underfoot();
eq.is_current_expansion_veil_of_alaris();
eq.is_damage_spell(uint16 spell_id);
eq.is_death_save_spell(uint16 spell_id);
eq.is_debuff_spell(uint16 spell_id);
eq.is_depths_of_darkhollow_enabled();
eq.is_detrimental_spell(uint16 spell_id);
eq.is_disc_tome(int item_id);
eq.is_discipline(uint16 spell_id);
eq.is_discipline_buff(uint16 spell_id);
eq.is_disease_counter_spell(uint16 spell_id);
eq.is_distance_modifier_spell(uint16 spell_id);
eq.is_dragons_of_norrath_enabled();
eq.is_effect_ignored_in_stacking(int effect_id);
eq.is_effect_in_spell(uint16 spell_id, int effect_id);
eq.is_empires_of_kunark_enabled();
eq.is_fast_heal_spell(uint16 spell_id);
eq.is_fear_spell(uint16 spell_id);
eq.is_focus_limit(int effect_id);
eq.is_full_death_save_spell(uint16 spell_id);
eq.is_gate_spell(uint16 spell_id);
eq.is_gates_of_discord_enabled();
eq.is_group_complete_heal_spell(uint16 spell_id);
eq.is_group_heal_over_time_spell(uint16 spell_id);
eq.is_group_only_spell(uint16 spell_id);
eq.is_group_spell(uint16 spell_id);
eq.is_harmony_spell(uint16 spell_id);
eq.is_haste_spell(uint16 spell_id);
eq.is_heal_over_time_spell(uint16 spell_id);
eq.is_health_spell(uint16 spell_id);
eq.is_hotzone();
eq.is_house_of_thule_enabled();
eq.is_illusion_spell(uint16 spell_id);
eq.is_improved_damage_spell(uint16 spell_id);
eq.is_improved_healing_spell(uint16 spell_id);
eq.is_increase_duration_spell(uint16 spell_id);
eq.is_increase_range_spell(uint16 spell_id);
eq.is_instrument_modifier_applied_to_spell_effect(uint16 spell_id, int effect_id);
eq.is_invisible_spell(uint16 spell_id);
eq.is_invulnerability_spell(uint16 spell_id);
eq.is_ldon_object_spell(uint16 spell_id);
eq.is_lifetap_spell(uint16 spell_id);
eq.is_lost_dungeons_of_norrath_enabled();
eq.is_magic_rune_spell(uint16 spell_id);
eq.is_mana_cost_reduction_spell(uint16 spell_id);
eq.is_mana_tap_spell(uint16 spell_id);
eq.is_mesmerize_spell(uint16 spell_id);
eq.is_no_detrimental_spell_aggro_spell(uint16 spell_id);
eq.is_npc_spawned(object table);
eq.is_omens_of_war_enabled();
eq.is_partial_death_save_spell(uint16 spell_id);
eq.is_partial_resistable_spell(uint16 spell_id);
eq.is_paused_timer(string timer);
eq.is_pbae_nuke_spell(uint16 spell_id);
eq.is_percental_heal_spell(uint16 spell_id);
eq.is_persist_death_spell(uint16 spell_id);
eq.is_pet_spell(uint16 spell_id);
eq.is_poison_counter_spell(uint16 spell_id);
eq.is_prophecy_of_ro_enabled();
eq.is_pulsing_bard_song(uint16 spell_id);
eq.is_pure_nuke_spell(uint16 spell_id);
eq.is_rain_of_fear_enabled();
eq.is_raining();
eq.is_regular_group_heal_spell(uint16 spell_id);
eq.is_regular_single_target_heal_spell(uint16 spell_id);
eq.is_resist_debuff_spell(uint16 spell_id);
eq.is_resistable_spell(uint16 spell_id);
eq.is_rest_allowed_spell(uint16 spell_id);
eq.is_resurrection_effects(uint16 spell_id);
eq.is_ring_of_scale_enabled();
eq.is_rune_spell(uint16 spell_id);
eq.is_sacrifice_spell(uint16 spell_id);
eq.is_secrets_of_faydwer_enabled();
eq.is_seeds_of_destruction_enabled();
eq.is_self_conversion_spell(uint16 spell_id);
eq.is_shadow_step_spell(uint16 spell_id);
eq.is_short_duration_buff(uint16 spell_id);
eq.is_snowing();
eq.is_spell_usable_in_this_zone_type(uint16 spell_id);
eq.is_spell_usable_in_this_zone_type(uint16 spell_id, uint8 zone_type);
eq.is_stackable_dot(uint16 spell_id);
eq.is_stun_spell(uint16 spell_id);
eq.is_succor_spell(uint16 spell_id);
eq.is_summon_item_spell(uint16 spell_id);
eq.is_summon_pc_spell(uint16 spell_id);
eq.is_summon_pet_spell(uint16 spell_id);
eq.is_summon_skeleton_spell(uint16 spell_id);
eq.is_summon_spell(uint16 spell_id);
eq.is_suspendable_spell(uint16 spell_id);
eq.is_target_required_for_spell(uint16 spell_id);
eq.is_targetable_ae_spell(uint16 spell_id);
eq.is_task_active(int task);
eq.is_task_activity_active(int task, int activity);
eq.is_task_appropriate(int task);
eq.is_task_completed(task_id);
eq.is_task_enabled(int task);
eq.is_teleport_spell(uint16 spell_id);
eq.is_tgb_compatible_spell(uint16 spell_id);
eq.is_the_broken_mirror_enabled();
eq.is_the_buried_sea_enabled();
eq.is_the_burning_lands_enabled();
eq.is_the_darkened_sea_enabled();
eq.is_the_legacy_of_ykesha_enabled();
eq.is_the_planes_of_power_enabled();
eq.is_the_ruins_of_kunark_enabled();
eq.is_the_scars_of_velious_enabled();
eq.is_the_serpents_spine_enabled();
eq.is_the_shadows_of_luclin_enabled();
eq.is_torment_of_velious_enabled();
eq.is_translocate_spell(uint16 spell_id);
eq.is_underfoot_enabled();
eq.is_valid_spell(uint16 spell_id);
eq.is_veil_of_alaris_enabled();
eq.is_very_fast_heal_spell(uint16 spell_id);
eq.is_virus_spell(uint16 spell_id);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
eq.item_link(uint32 item_id);
eq.item_link(ItemInst inst);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6, bool attuned);
eq.item_link(uint32 item_id, int16 charges);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
eq.item_link(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2);
eq.last_task_in_set(task_set);
eq.log(int category, string message);
eq.log_combat(string message);
eq.log_spells(string message);
eq.map_opcodes();
eq.marquee(uint32 type, string message);
eq.marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.marquee(uint32 type, string message, uint32 duration);
eq.merchant_count_item(uint32 npc_id, uint32 item_id);
eq.merchant_set_item(uint32 npc_id, uint32 item_id, uint32 quantity);
eq.merchant_set_item(uint32 npc_id, uint32 item_id);
eq.message(int color, string message);
eq.modify_npc_stat(string stat, string value);
eq.move_to(float x, float y, float z, float h, bool save_guard_spot);
eq.move_to(float x, float y, float z, float h);
eq.move_to(float x, float y, float z);
eq.next_task_in_set(task_set, task_id);
eq.path_resume();
eq.pause(int duration);
eq.pause_timer(string timer);
eq.popup(string title, string text, uint32 id, uint32 buttons);
eq.popup(string title, string text, uint32 id, uint32 buttons, uint32 duration);
eq.popup(string title, string text);
eq.popup(string title, string text, uint32 id);
eq.popup_break();
eq.popup_break(uint32 break_count);
eq.popup_center_message(message);
eq.popup_color_message(color, message);
eq.popup_indent(uint32 indent_count);
eq.popup_indent();
eq.popup_link(link, message);
eq.popup_link(link);
eq.popup_table(message);
eq.popup_table_cell(message);
eq.popup_table_cell();
eq.popup_table_row(message);
eq.process_mobs_while_zone_empty(bool on);
eq.rain(int weather);
eq.reloadzonestaticdata();
eq.remove_all_expedition_lockouts_by_char_id(uint32 char_id, string expedition_name);
eq.remove_all_expedition_lockouts_by_char_id(uint32 char_id);
eq.remove_all_from_instance(uint32 instance_id);
eq.remove_area(int id);
eq.remove_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name);
eq.remove_from_instance(uint32 instance_id);
eq.remove_from_instance_by_char_id(uint32 instance_id, uint32 character_id);
eq.remove_item(uint32 item_id, uint32 quantity);
eq.remove_item(uint32 item_id);
eq.remove_ldon_loss(uint32 theme_id);
eq.remove_ldon_win(uint32 theme_id);
eq.remove_spawn_point(uint32 spawn2_id);
eq.remove_title(uint32 title_set);
eq.rename(string name);
eq.repop_zone(bool is_forced);
eq.repop_zone();
eq.reset_task_activity(int task, int activity);
eq.respawn(int npc_type, int grid);
eq.resume_timer(string timer);
eq.safe_move();
eq.say_link(text);
eq.say_link(text, bool silent, link_name);
eq.say_link(text, bool silent);
eq.scribe_spells(max);
eq.scribe_spells(max, min);
eq.seconds_to_time(int duration);
eq.self_cast(uint16 spell_id);
eq.send_channel_message(uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
eq.send_channel_message(Client from, uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
eq.send_channel_message(Client from, string to, uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
eq.send_mail(string to, string from, string subject, string message);
eq.send_player_handin_event();
eq.set_aa_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, float aa_modifier, int16 instance_version);
eq.set_aa_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, float aa_modifier);
eq.set_anim(int npc_type, int anim_num);
eq.set_auto_login_character_name_by_account_id(uint32 account_id, string character_name);
eq.set_content_flag(string flag_name, bool enabled{);
eq.set_data(string bucket_key, string bucket_value, string expires_at);
eq.set_data(string bucket_key, string bucket_value);
eq.set_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, float exp_modifier, int16 instance_version);
eq.set_exp_modifier_by_char_id(uint32 character_id, uint32 zone_id, float exp_modifier);
eq.set_global(string name, string value, int options, string duration);
eq.set_guild(int guild_id, int rank);
eq.set_hotzone(bool is_hotzone);
eq.set_next_hp_event(int hp);
eq.set_next_inc_hp_event(int hp);
eq.set_proximity(float min_x, float max_x, float min_y, float max_y, float min_z, float max_z, bool enable_say);
eq.set_proximity(float min_x, float max_x, float min_y, float max_y, float min_z, float max_z);
eq.set_proximity(float min_x, float max_x, float min_y, float max_y);
eq.set_proximity_range(float x_range, float y_range, float z_range, bool enable_say);
eq.set_proximity_range(float x_range, float y_range, float z_range);
eq.set_proximity_range(float x_range, float y_range);
eq.set_rule(string rule_name, string rule_value);
eq.set_sky(int sky);
eq.set_time(int hour, int min, bool update_world);
eq.set_time(int hour, int min);
eq.set_timer(string timer, uint32 time_ms, ItemInst inst);
eq.set_timer(string timer, uint32 time_ms, Encounter enc);
eq.set_timer(string timer, uint32 time_ms, Mob mob);
eq.set_timer(string timer, uint32 time_ms);
eq.signal(int npc_id, int signal_id, int wait);
eq.signal(int npc_id, int signal_id);
eq.silent_say_link(text);
eq.silent_say_link(text, link_name);
eq.snow(int weather);
eq.spawn2(int npc_type, int grid, int unused, double x, double y, double z, double heading);
eq.spawn_circle(uint32 npc_id, float x, float y, float z, float heading, float radius, uint32 points);
eq.spawn_condition(string zone, uint32 instance_id, int condition_id, int value);
eq.spawn_from_spawn2(uint32 spawn2_id);
eq.spawn_grid(uint32 npc_id, float x, float y, float z, float heading, float spacing, uint32 spawn_count);
eq.start(int wp);
eq.stop();
eq.stop_all_timers(Mob mob);
eq.stop_all_timers(Encounter enc);
eq.stop_all_timers();
eq.stop_all_timers(ItemInst inst);
eq.stop_follow();
eq.stop_timer(string timer, Mob mob);
eq.stop_timer(string timer, ItemInst inst);
eq.stop_timer(string timer, Encounter enc);
eq.stop_timer(string timer);
eq.summon_all_player_corpses(uint32 char_id, float x, float y, float z, float h);
eq.summon_buried_player_corpse(uint32 char_id, float x, float y, float z, float h);
eq.target_global(string name, string value, string duration, int npc_id, int char_id, int zone_id);
eq.task_selector(object table);
eq.task_selector(object table, bool ignore_cooldown);
eq.task_set_selector(int task_set);
eq.task_set_selector(int task_set, bool ignore_cooldown);
eq.task_time_left(task_id);
eq.time_to_seconds(string time_string);
eq.toggle_spawn_event(int event_id, bool enable, bool strict, bool reset);
eq.track_npc(uint32 entity_id);
eq.train_discs(max, min);
eq.train_discs(max);
eq.unique_spawn(int npc_type, int grid, int unused, double x, double y, double z, double heading = 0.0);
eq.update_instance_timer(uint16 instance_id, uint32 new_duration);
eq.update_spawn_timer(uint32 id, uint32 new_time);
eq.update_task_activity(int task, int activity, int count);
eq.update_zone_header(string type, string value);
eq.voice_tell(string str, uint32 macro_num, uint32 race_num, uint32 gender_num);
eq.wear_change(uint32 slot, uint32 texture);
eq.whisper(string message);
eq.world_emote(int type, string str);
eq.world_wide_add_ldon_loss(uint32 theme_id, uint8 min_status);
eq.world_wide_add_ldon_loss(uint32 theme_id);
eq.world_wide_add_ldon_loss(uint32 theme_id, uint8 min_status, uint8 max_status);
eq.world_wide_add_ldon_points(uint32 theme_id, int points, uint8 min_status);
eq.world_wide_add_ldon_points(uint32 theme_id, int points);
eq.world_wide_add_ldon_points(uint32 theme_id, int points, uint8 min_status, uint8 max_status);
eq.world_wide_add_ldon_win(uint32 theme_id);
eq.world_wide_add_ldon_win(uint32 theme_id, uint8 min_status);
eq.world_wide_add_ldon_win(uint32 theme_id, uint8 min_status, uint8 max_status);
eq.world_wide_assign_task(uint32 task_id);
eq.world_wide_assign_task(uint32 task_id, bool enforce_level_requirement);
eq.world_wide_assign_task(uint32 task_id, bool enforce_level_requirement, uint8 min_status);
eq.world_wide_assign_task(uint32 task_id, bool enforce_level_requirement, uint8 min_status, uint8 max_status);
eq.world_wide_cast_spell(uint32 spell_id);
eq.world_wide_cast_spell(uint32 spell_id, uint8 min_status);
eq.world_wide_cast_spell(uint32 spell_id, uint8 min_status, uint8 max_status);
eq.world_wide_dialogue_window(string message);
eq.world_wide_dialogue_window(string message, uint8 min_status);
eq.world_wide_dialogue_window(string message, uint8 min_status, uint8 max_status);
eq.world_wide_disable_task(uint32 task_id);
eq.world_wide_disable_task(uint32 task_id, uint8 min_status);
eq.world_wide_disable_task(uint32 task_id, uint8 min_status, uint8 max_status);
eq.world_wide_enable_task(uint32 task_id);
eq.world_wide_enable_task(uint32 task_id, uint8 min_status);
eq.world_wide_enable_task(uint32 task_id, uint8 min_status, uint8 max_status);
eq.world_wide_fail_task(uint32 task_id);
eq.world_wide_fail_task(uint32 task_id, uint8 min_status);
eq.world_wide_fail_task(uint32 task_id, uint8 min_status, uint8 max_status);
eq.world_wide_marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.world_wide_marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message, uint8 min_status);
eq.world_wide_marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message, uint8 min_status, uint8 max_status);
eq.world_wide_message(uint32 type, string message);
eq.world_wide_message(uint32 type, string message, uint8 min_status);
eq.world_wide_message(uint32 type, string message, uint8 min_status, uint8 max_status);
eq.world_wide_move(string zone_short_name);
eq.world_wide_move(string zone_short_name, uint8 min_status);
eq.world_wide_move(string zone_short_name, uint8 min_status, uint8 max_status);
eq.world_wide_move_instance(uint16 instance_id, uint8 min_status);
eq.world_wide_move_instance(uint16 instance_id);
eq.world_wide_move_instance(uint16 instance_id, uint8 min_status, uint8 max_status);
eq.world_wide_remove_ldon_loss(uint32 theme_id);
eq.world_wide_remove_ldon_loss(uint32 theme_id, uint8 min_status);
eq.world_wide_remove_ldon_loss(uint32 theme_id, uint8 min_status, uint8 max_status);
eq.world_wide_remove_ldon_win(uint32 theme_id);
eq.world_wide_remove_ldon_win(uint32 theme_id, uint8 min_status);
eq.world_wide_remove_ldon_win(uint32 theme_id, uint8 min_status, uint8 max_status);
eq.world_wide_remove_spell(uint32 spell_id);
eq.world_wide_remove_spell(uint32 spell_id, uint8 min_status);
eq.world_wide_remove_spell(uint32 spell_id, uint8 min_status, uint8 max_status);
eq.world_wide_remove_task(uint32 task_id);
eq.world_wide_remove_task(uint32 task_id, uint8 min_status);
eq.world_wide_remove_task(uint32 task_id, uint8 min_status, uint8 max_status);
eq.world_wide_reset_activity(uint32 task_id, int activity_id);
eq.world_wide_reset_activity(uint32 task_id, int activity_id, uint8 min_status);
eq.world_wide_reset_activity(uint32 task_id, int activity_id, uint8 min_status, uint8 max_status);
eq.world_wide_set_entity_variable_client(string variable_name, string variable_value, uint8 min_status);
eq.world_wide_set_entity_variable_client(string variable_name, string variable_value);
eq.world_wide_set_entity_variable_client(string variable_name, string variable_value, uint8 min_status, uint8 max_status);
eq.world_wide_set_entity_variable_npc(string variable_name, string variable_value);
eq.world_wide_signal_client(int signal_id);
eq.world_wide_signal_client(int signal_id, uint8 min_status);
eq.world_wide_signal_client(int signal_id, uint8 min_status, uint8 max_status);
eq.world_wide_signal_npc(int signal_id);
eq.world_wide_update_activity(uint32 task_id, int activity_id, int activity_count);
eq.world_wide_update_activity(uint32 task_id, int activity_id);
eq.world_wide_update_activity(uint32 task_id, int activity_id, int activity_count, uint8 min_status);
eq.world_wide_update_activity(uint32 task_id, int activity_id, int activity_count, uint8 min_status, uint8 max_status);
eq.zone(string zone_name);
eq.zone_emote(int type, string str);
eq.zone_group(string zone_name);
eq.zone_marquee(uint32 type, string message);
eq.zone_marquee(uint32 type, string message, uint32 duration);
eq.zone_marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
eq.zone_raid(string zone_name);
`
```

---

## Expedition

*Source: quest-api/methods/expedition/index.html*

# Expedition

Perl (39)Lua (41)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$expedition->AddLockout(string event_name, uint32_t seconds);
$expedition->AddLockoutDuration(string event_name, int seconds);
$expedition->AddLockoutDuration(string event_name, int seconds, bool members_only);
$expedition->AddReplayLockout(uint32_t seconds);
$expedition->AddReplayLockoutDuration(int seconds);
$expedition->AddReplayLockoutDuration(int seconds, bool members_only);
$expedition->GetDynamicZoneID();
$expedition->GetID();
$expedition->GetInstanceID();
$expedition->GetLeaderName();
$expedition->GetLockouts();
$expedition->GetLootEventByNPCTypeID(uint32_t npc_type_id);
$expedition->GetLootEventBySpawnID(uint32_t spawn_id);
$expedition->GetMemberCount();
$expedition->GetMembers();
$expedition->GetName();
$expedition->GetSecondsRemaining();
$expedition->GetUUID();
$expedition->GetZoneID();
$expedition->GetZoneName();
$expedition->GetZoneVersion();
$expedition->HasLockout(string event_name);
$expedition->HasReplayLockout();
$expedition->IsLocked();
$expedition->RemoveCompass();
$expedition->RemoveLockout(string event_name);
$expedition->SetCompass(scalar zone, float x, float y, float z);
$expedition->SetLocked(bool locked);
$expedition->SetLocked(bool locked, int lock_msg);
$expedition->SetLocked(bool locked, int lock_msg, uint32_t color);
$expedition->SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name);
$expedition->SetLootEventBySpawnID(uint32_t entity_id, string event_name);
$expedition->SetReplayLockoutOnMemberJoin(bool enable);
$expedition->SetSafeReturn(scalar zone, float x, float y, float z, float heading);
$expedition->SetSecondsRemaining(uint32_t seconds_remaining);
$expedition->SetSwitchID(int dz_switch_id);
$expedition->SetZoneInLocation(float x, float y, float z, float heading);
$expedition->UpdateLockoutDuration(string event_name, uint32_t seconds);
$expedition->UpdateLockoutDuration(string event_name, uint32_t seconds, bool members_only);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`expedition:AddLockout(string event_name, uint32_t seconds);
expedition:AddLockoutDuration(string event_name, int seconds);
expedition:AddLockoutDuration(string event_name, int seconds, bool members_only);
expedition:AddReplayLockout(uint32_t seconds);
expedition:AddReplayLockoutDuration(int seconds);
expedition:AddReplayLockoutDuration(int seconds, bool members_only);
expedition:GetDynamicZoneID();
expedition:GetID();
expedition:GetInstanceID();
expedition:GetLeaderName();
expedition:GetLockouts();
expedition:GetLootEventByNPCTypeID(uint32_t npc_type_id);
expedition:GetLootEventBySpawnID(uint32_t spawn_id);
expedition:GetMemberCount();
expedition:GetMembers();
expedition:GetName();
expedition:GetSecondsRemaining();
expedition:GetUUID();
expedition:GetZoneID();
expedition:GetZoneName();
expedition:GetZoneVersion();
expedition:HasLockout(string event_name);
expedition:HasReplayLockout();
expedition:IsLocked();
expedition:RemoveCompass();
expedition:RemoveLockout(string event_name);
expedition:SetCompass(uint32_t zone_id, float x, float y, float z);
expedition:SetCompass(string zone_name, float x, float y, float z);
expedition:SetLocked(bool lock_expedition);
expedition:SetLocked(bool lock_expedition, int lock_msg);
expedition:SetLocked(bool lock_expedition, int lock_msg, uint32_t msg_color);
expedition:SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name);
expedition:SetLootEventBySpawnID(uint32_t spawn_id, string event_name);
expedition:SetReplayLockoutOnMemberJoin(bool enable);
expedition:SetSafeReturn(uint32_t zone_id, float x, float y, float z, float heading);
expedition:SetSafeReturn(string zone_name, float x, float y, float z, float heading);
expedition:SetSecondsRemaining(uint32_t seconds_remaining);
expedition:SetSwitchID(int dz_switch_id);
expedition:SetZoneInLocation(float x, float y, float z, float heading);
expedition:UpdateLockoutDuration(string event_name, uint32_t duration);
expedition:UpdateLockoutDuration(string event_name, uint32_t duration, bool members_only);
`
```

---

## Group

*Source: quest-api/methods/group/index.html*

# Group

Perl (26)Lua (24)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$group->CastGroupSpell(Mob* caster, uint16 spell_id);
$group->DisbandGroup();
$group->DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count);
$group->DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name);
$group->GetAverageLevel();
$group->GetHighestLevel();
$group->GetID();
$group->GetLeader();
$group->GetLeaderName();
$group->GetLowestLevel();
$group->GetMember(int member_index);
$group->GetTotalGroupDamage(Mob* other);
$group->GroupCount();
$group->GroupMessage(Mob* sender, uint8_t language, string message);
$group->GroupMessage(Mob* sender, string message);
$group->IsGroupMember(Mob* c);
$group->IsGroupMember(string name);
$group->IsLeader(Mob* c);
$group->IsLeader(string name);
$group->SendHPPacketsFrom(Mob* new_member);
$group->SendHPPacketsTo(Mob* new_member);
$group->SetLeader(Mob* new_leader);
$group->SplitExp(uint32_t exp, Mob* other);
$group->SplitMoney(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
$group->SplitMoney(uint32 copper, uint32 silver, uint32 gold, uint32 platinum, Client* splitter);
$group->TeleportGroup(Mob* sender, uint32 zone_id, float x, float y, float z, float heading);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`group:CastGroupSpell(Mob caster, int spell_id);
group:DisbandGroup();
group:DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count);
group:DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name);
group:GetAverageLevel();
group:GetHighestLevel();
group:GetID();
group:GetLeader();
group:GetLeaderName();
group:GetLowestLevel();
group:GetMember(int member_index);
group:GetTotalGroupDamage(Mob other);
group:GroupCount();
group:GroupMessage(Mob sender, uint8 language, string message);
group:GroupMessage(Mob sender, string message);
group:IsGroupMember(Mob c);
group:IsGroupMember(string name);
group:IsLeader(Mob c);
group:IsLeader(string name);
group:SetLeader(Mob c);
group:SplitExp(uint64 exp, Mob other);
group:SplitMoney(uint32 copper, uint32 silver, uint32 gold, uint32 platinum, Client splitter);
group:SplitMoney(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
group:TeleportGroup(Mob sender, uint32 zone_id, uint32 instance_id, float x, float y, float z, float h);
`
```

---

## HateEntry

*Source: quest-api/methods/hateentry/index.html*

# HateEntry

Perl (8)Lua (8)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$hateentry->GetDamage();
$hateentry->GetEnt();
$hateentry->GetFrenzy();
$hateentry->GetHate();
$hateentry->SetDamage(int64 value);
$hateentry->SetEnt(Mob* mob);
$hateentry->SetFrenzy(bool is_frenzy);
$hateentry->SetHate(int64 value);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`hateentry:GetDamage();
hateentry:GetEnt();
hateentry:GetFrenzy();
hateentry:GetHate();
hateentry:SetDamage(int64 value);
hateentry:SetEnt(Mob e);
hateentry:SetFrenzy(bool value);
hateentry:SetHate(int64 value);
`
```

---

## Inventory

*Source: quest-api/methods/inventory/index.html*

# Inventory

Perl (32)Lua (34)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$inventory->CanItemFitInContainer(EQ::ItemInstance* item_to_check, EQ::ItemInstance* container_to_check);
$inventory->CheckNoDrop(int16_t slot_id);
$inventory->CountAugmentEquippedByID(uint32_t item_id);
$inventory->CountItemEquippedByID(uint32_t item_id);
$inventory->DeleteItem(int16_t slot_id);
$inventory->DeleteItem(int16_t slot_id, uint8_t quantity);
$inventory->FindFreeSlot(bool is_for_bag, bool try_cursor);
$inventory->FindFreeSlot(bool is_for_bag, bool try_cursor, uint8_t min_size);
$inventory->FindFreeSlot(bool is_for_bag, bool try_cursor, uint8_t min_size, bool is_arrow);
$inventory->GetAugmentIDsBySlotID(int16 slot_id);
$inventory->GetBagIndex(int16_t slot_id);
$inventory->GetItem(int16_t slot_id);
$inventory->GetMaterialFromSlot(int16_t slot_id);
$inventory->GetSlotByItemInst(EQ::ItemInstance* item);
$inventory->GetSlotFromMaterial(uint8_t material);
$inventory->GetSlotID(int16_t slot_id);
$inventory->GetSlotID(int16_t slot_id, uint8_t bag_index);
$inventory->HasAugmentEquippedByID(uint32_t item_id);
$inventory->HasItem(uint32_t item_id, uint8_t quantity, uint8_t where_to_look);
$inventory->HasItem(uint32_t item_id);
$inventory->HasItem(uint32_t item_id, uint8_t quantity);
$inventory->HasItemByLoreGroup(uint32_t loregroup, uint8_t where_to_look);
$inventory->HasItemByLoreGroup(uint32_t loregroup);
$inventory->HasItemByUse(uint8_t item_use, uint8_t quantity, uint8_t where_to_look);
$inventory->HasItemByUse(uint8_t item_use, uint8_t quantity);
$inventory->HasItemEquippedByID(uint32_t item_id);
$inventory->HasSpaceForItem(EQ::ItemInstance* item_to_check, uint8_t quantity);
$inventory->PopItem(int16_t slot_id);
$inventory->PushCursor(EQ::ItemInstance* item);
$inventory->PutItem(int16_t slot_id, EQ::ItemInstance* item);
$inventory->SupportsContainers(int16_t slot_id);
$inventory->SwapItem(int16_t source_slot_id, int16_t destination_slot_id);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`inventory:CalcBagIdx(slot_id);
inventory:CalcMaterialFromSlot(equipslot);
inventory:CalcSlotFromMaterial(material);
inventory:CalcSlotId(slot_id);
inventory:CalcSlotId(slot_id, bag_slot);
inventory:CanItemFitInContainer(Item item, Item container);
inventory:CheckNoDrop(int slot_id);
inventory:CountAugmentEquippedByID(uint32 item_id);
inventory:CountItemEquippedByID(uint32 item_id);
inventory:DeleteItem(int slot_id);
inventory:DeleteItem(int slot_id, int quantity);
inventory:FindFreeSlot(bool for_bag, bool try_cursor);
inventory:FindFreeSlot(bool for_bag, bool try_cursor, min_size);
inventory:FindFreeSlot(bool for_bag, bool try_cursor, min_size, bool is_arrow);
inventory:GetAugmentIDsBySlotID(int16 slot_id);
inventory:GetItem(int slot_id);
inventory:GetItem(int slot_id, int bag_slot);
inventory:GetSlotByItemInst(ItemInst inst);
inventory:HasAugmentEquippedByID(uint32 item_id);
inventory:HasItem(item_id, quantity);
inventory:HasItem(item_id, quantity, where);
inventory:HasItem(item_id);
inventory:HasItemByLoreGroup(uint32 loregroup);
inventory:HasItemByLoreGroup(uint32 loregroup, where);
inventory:HasItemByUse(use, uint8 quantity, uint8 where);
inventory:HasItemByUse(use, uint8 quantity);
inventory:HasItemByUse(use);
inventory:HasItemEquippedByID(uint32 item_id);
inventory:HasSpaceForItem(Item item, int quantity);
inventory:PopItem(int slot_id);
inventory:PushCursor(ItemInst item);
inventory:PutItem(slot_id, ItemInst item);
inventory:SupportsContainers(int slot_id);
inventory:SwapItem(int source_slot, int destination_slot);
`
```

---

## Item

*Source: quest-api/methods/item/index.html*

# Item

Lua (176)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`item:AAgi();
item:AC();
item:ACha();
item:ADex();
item:AInt();
item:ASta();
item:AStr();
item:AWis();
item:Accuracy();
item:ArtifactFlag();
item:Attack();
item:Attuneable();
item:AugDistiller();
item:AugRestrict();
item:AugSlotType(uint8 slot_id);
item:AugSlotUnk2(uint8 slot_id);
item:AugSlotVisible(uint8 slot_id);
item:AugType();
item:Avoidance();
item:BackstabDmg();
item:BagSize();
item:BagSlots();
item:BagType();
item:BagWR();
item:BaneDmgAmt();
item:BaneDmgBody();
item:BaneDmgRace();
item:BaneDmgRaceAmt();
item:BardType();
item:BardValue();
item:Bard_Effect();
item:Bard_Level();
item:Bard_Level2();
item:Bard_Type();
item:BenefitFlag();
item:Book();
item:BookType();
item:CR();
item:CastTime();
item:CastTime_();
item:CharmFile();
item:CharmFileID();
item:Clairvoyance();
item:Classes();
item:ClickName();
item:Click_Effect();
item:Click_Level();
item:Click_Level2();
item:Click_Type();
item:Color();
item:CombatEffects();
item:Comment();
item:DR();
item:DSMitigation();
item:Damage();
item:DamageShield();
item:Deity();
item:Delay();
item:DotShielding();
item:ElemDmgAmt();
item:ElemDmgType();
item:EliteMaterial();
item:Endur();
item:EnduranceRegen();
item:ExpendableArrow();
item:ExtraDmgAmt();
item:ExtraDmgSkill();
item:FR();
item:FVNoDrop();
item:FactionAmt1();
item:FactionAmt2();
item:FactionAmt3();
item:FactionAmt4();
item:FactionMod1();
item:FactionMod2();
item:FactionMod3();
item:FactionMod4();
item:Favor();
item:Filename();
item:FocusName();
item:Focus_Effect();
item:Focus_Level();
item:Focus_Level2();
item:Focus_Type();
item:Fulfilment();
item:GetWorn_Type();
item:GuildFavor();
item:HP();
item:Haste();
item:HealAmt();
item:HeroicAgi();
item:HeroicCR();
item:HeroicCha();
item:HeroicDR();
item:HeroicDex();
item:HeroicFR();
item:HeroicInt();
item:HeroicMR();
item:HeroicPR();
item:HeroicSVCorrup();
item:HeroicSta();
item:HeroicStr();
item:HeroicWis();
item:ID();
item:IDFile();
item:Icon();
item:ItemClass();
item:ItemType();
item:LDoNPrice();
item:LDoNSellBackRate();
item:LDoNSold();
item:LDoNTheme();
item:Light();
item:Lore();
item:LoreFlag();
item:LoreGroup();
item:MR();
item:Magic();
item:Mana();
item:ManaRegen();
item:Material();
item:MaxCharges();
item:MinStatus();
item:Name();
item:NoDrop();
item:NoPet();
item:NoRent();
item:NoTransfer();
item:PR();
item:PendingLoreFlag();
item:PointType();
item:PotionBelt();
item:PotionBeltSlots();
item:Price();
item:ProcName();
item:ProcRate();
item:Proc_Effect();
item:Proc_Level();
item:Proc_Level2();
item:Proc_Type();
item:Purity();
item:QuestItemFlag();
item:Races();
item:Range();
item:RecLevel();
item:RecSkill();
item:RecastDelay();
item:RecastType();
item:Regen();
item:ReqLevel();
item:SVCorruption();
item:ScriptFileID();
item:ScrollName();
item:Scroll_Effect();
item:Scroll_Level();
item:Scroll_Level2();
item:Scroll_Type();
item:SellRate();
item:Shielding();
item:Size();
item:SkillModType();
item:SkillModValue();
item:Slots();
item:SpellDmg();
item:SpellShield();
item:StackSize();
item:Stackable();
item:StrikeThrough();
item:StunResist();
item:SummonedFlag();
item:Tradeskills();
item:Weight();
item:WornName();
item:Worn_Effect();
item:Worn_Level();
item:Worn_Level2();
`
```

---

## ItemInst

*Source: quest-api/methods/iteminst/index.html*

# ItemInst

Lua (56)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`iteminst:AddExp(uint32 exp);
iteminst:ClearTimers();
iteminst:Clone();
iteminst:ContainsAugmentByID(uint32 item_id);
iteminst:CountAugmentByID(uint32 item_id);
iteminst:DeleteCustomData(const std);
iteminst:GetAugment(uint8 slot_id);
iteminst:GetAugmentItemID(uint8 slot_id);
iteminst:GetAugmentType();
iteminst:GetCharges();
iteminst:GetColor();
iteminst:GetCustomData(const std);
iteminst:GetCustomDataString();
iteminst:GetExp();
iteminst:GetID();
iteminst:GetItem();
iteminst:GetItem(uint8 slot_id);
iteminst:GetItemID(uint8 slot_id);
iteminst:GetItemLink();
iteminst:GetItemScriptID();
iteminst:GetKillsNeeded(uint8 current_level);
iteminst:GetMaxEvolveLvl();
iteminst:GetName();
iteminst:GetPrice();
iteminst:GetTaskDeliveredCount();
iteminst:GetTotalItemCount();
iteminst:GetUnscaledItem();
iteminst:IsAmmo();
iteminst:IsAttuned();
iteminst:IsAugmentable();
iteminst:IsAugmented();
iteminst:IsEquipable(uint16 race_bitmask, uint16 class_bitmask);
iteminst:IsEquipable(int16 slot_id);
iteminst:IsExpendable();
iteminst:IsInstNoDrop();
iteminst:IsStackable();
iteminst:IsType(int item_class);
iteminst:IsWeapon();
iteminst:ItemSay(string text // @categories Inventory and Items);
iteminst:ItemSay(string text, uint8 language_id // @categories Inventory and Items);
iteminst:RemoveTaskDeliveredItems();
iteminst:SetAttuned(bool flag);
iteminst:SetCharges(int charges);
iteminst:SetColor(uint32 color);
iteminst:SetCustomData(const string &identifier, std);
iteminst:SetCustomData(const std);
iteminst:SetCustomData(const std);
iteminst:SetCustomData(const std);
iteminst:SetExp(uint32 exp);
iteminst:SetInstNoDrop(bool flag);
iteminst:SetPrice(uint32 price);
iteminst:SetScale(double scale_factor);
iteminst:SetScaling(bool v);
iteminst:SetTimer(string name, uint32 time);
iteminst:StopTimer(string name);
iteminst:operator=(const o);
`
```

---

## Merc

*Source: quest-api/methods/merc/index.html*

# Merc

Perl (30)Lua (30)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$merc->GetCostFormula();
$merc->GetGroup();
$merc->GetHatedCount();
$merc->GetMaxMeleeRangeToTarget(Mob* target);
$merc->GetMercenaryCharacterID();
$merc->GetMercenaryID();
$merc->GetMercenaryNameType();
$merc->GetMercenaryOwner();
$merc->GetMercenarySubtype();
$merc->GetMercenaryTemplateID();
$merc->GetMercenaryType();
$merc->GetOwner();
$merc->GetOwnerOrSelf();
$merc->GetProficiencyID();
$merc->GetStance();
$merc->GetTierID();
$merc->HasOrMayGetAggro();
$merc->IsMercenaryCaster();
$merc->IsMercenaryCasterCombatRange(Mob* target);
$merc->IsSitting();
$merc->IsStanding();
$merc->ScaleStats(int scale_percentage);
$merc->ScaleStats(int scale_percentage, bool set_to_max);
$merc->SendPayload(int payload_id, string payload_value);
$merc->SetTarget(Mob* target);
$merc->Signal(int signal_id);
$merc->Sit();
$merc->Stand();
$merc->Suspend();
$merc->UseDiscipline(uint16 spell_id, uint16 target_id);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`merc:GetCostFormula();
merc:GetGroup();
merc:GetHatedCount();
merc:GetMaxMeleeRangeToTarget(Mob target);
merc:GetMercenaryCharacterID();
merc:GetMercenaryID();
merc:GetMercenaryNameType();
merc:GetMercenaryOwner();
merc:GetMercenarySubtype();
merc:GetMercenaryTemplateID();
merc:GetMercenaryType();
merc:GetOwner();
merc:GetOwnerOrSelf();
merc:GetProficiencyID();
merc:GetStance();
merc:GetTierID();
merc:HasOrMayGetAggro();
merc:IsMercenaryCaster();
merc:IsMercenaryCasterCombatRange(Mob target);
merc:IsSitting();
merc:IsStanding();
merc:ScaleStats(int scale_percentage);
merc:ScaleStats(int scale_percentage, bool set_to_max);
merc:SendPayload(int payload_id, string payload_value);
merc:SetTarget(Mob target);
merc:Signal(int signal_id);
merc:Sit();
merc:Stand();
merc:Suspend();
merc:UseDiscipline(uint16 spell_id, uint16 target_id);
`
```

---

## Mob

*Source: quest-api/methods/mob/index.html*

# Mob

Perl (639)Lua (568)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$mob->AddFeignMemory(Client* attacker);
$mob->AddNimbusEffect(int effect_id);
$mob->AddToHateList(Mob* other, int64_t hate, int64_t damage, bool yell_for_help);
$mob->AddToHateList(Mob* other);
$mob->AddToHateList(Mob* other, int64_t hate);
$mob->AddToHateList(Mob* other, int64_t hate, int64_t damage, bool yell_for_help, bool frenzy, bool buff_tic);
$mob->AddToHateList(Mob* other, int64_t hate, int64_t damage, bool yell_for_help, bool frenzy);
$mob->AddToHateList(Mob* other, int64_t hate, int64_t damage);
$mob->ApplySpellBuff(int spell_id);
$mob->ApplySpellBuff(int spell_id, int duration, int level);
$mob->ApplySpellBuff(int spell_id, int duration);
$mob->AreaAttack(float distance, int16 slot_id);
$mob->AreaAttack(float distance, int16 slot_id, int count, bool is_from_spell, int attack_rounds);
$mob->AreaAttack(float distance, int16 slot_id, int count, bool is_from_spell);
$mob->AreaAttack(float distance);
$mob->AreaAttack(float distance, int16 slot_id, int count);
$mob->AreaSpell(Mob* center, uint16 spell_id, bool affect_caster);
$mob->AreaSpell(Mob* center, uint16 spell_id);
$mob->AreaSpell(Mob* center, uint16 spell_id, bool affect_caster, int16 resist_adjust);
$mob->AreaSpell(Mob* center, uint16 spell_id, bool affect_caster, int16 resist_adjust, int max_targets);
$mob->Attack(Mob* other);
$mob->Attack(Mob* other, int hand);
$mob->Attack(Mob* other, int hand, from_riposte);
$mob->BehindMob(Mob* other);
$mob->BehindMob(Mob* other, float x, float y);
$mob->BehindMob(Mob* other, float x);
$mob->BuffCount();
$mob->BuffCount(bool is_beneficial, bool is_detrimental);
$mob->BuffCount(bool is_beneficial);
$mob->BuffFadeAll();
$mob->BuffFadeBeneficial();
$mob->BuffFadeByEffect(int effect_id);
$mob->BuffFadeByEffect(int effect_id, int skip_slot);
$mob->BuffFadeBySlot(int slot, bool recalc_bonuses);
$mob->BuffFadeBySlot(int slot);
$mob->BuffFadeBySpellID(uint16 spell_id);
$mob->BuffFadeDetrimental();
$mob->BuffFadeDetrimentalByCaster(Mob* caster);
$mob->BuffFadeNonPersistDeath();
$mob->BuffFadeSongs();
$mob->CalculateDistance(x, y, z);
$mob->CalculateDistance(Mob* mob);
$mob->CalculateHeadingToTarget(x, y);
$mob->CameraEffect(uint32 duration);
$mob->CameraEffect(uint32 duration, float intensity);
$mob->CameraEffect(uint32 duration, float intensity, Client* client);
$mob->CameraEffect(uint32 duration, float intensity, perl::nullable<Client*> client, bool global);
$mob->CanBuffStack(uint16 spell_id, uint8 caster_level);
$mob->CanBuffStack(uint16 spell_id, uint8 caster_level, fail_if_overwritten);
$mob->CanClassEquipItem(uint32 item_id);
$mob->CanRaceEquipItem(uint32 item_id);
$mob->CanThisClassDodge();
$mob->CanThisClassDoubleAttack();
$mob->CanThisClassDualWield();
$mob->CanThisClassParry();
$mob->CanThisClassRiposte();
$mob->CastSpell(uint16 spell_id, uint16 target_id, int slot, int cast_time, int mana_cost);
$mob->CastSpell(uint16 spell_id, uint16 target_id, int slot, int cast_time, int mana_cost, int16 resist_adjust);
$mob->CastSpell(uint16 spell_id, uint16 target_id, int slot, int cast_time);
$mob->CastSpell(uint16 spell_id, uint16 target_id, int slot);
$mob->CastSpell(uint16 spell_id, uint16 target_id);
$mob->CastToBot();
$mob->CastToClient();
$mob->CastToCorpse();
$mob->CastToMob();
$mob->CastToNPC();
$mob->CastingSpellID();
$mob->ChangeSize(float in_size, bool unrestricted);
$mob->ChangeSize(float in_size);
$mob->Charmed();
$mob->CheckAggro(Mob* other);
$mob->CheckAggroAmount(uint16 spell_id);
$mob->CheckHealAggroAmount(uint16 spell_id);
$mob->CheckHealAggroAmount(uint16 spell_id, uint32 possible);
$mob->CheckLoS(Mob* other);
$mob->CheckLoSToLoc(float x, float y, float z, float mob_size);
$mob->CheckLoSToLoc(float x, float y, float z);
$mob->ClearEntityVariables();
$mob->ClearFeignMemory();
$mob->ClearSpecialAbilities();
$mob->CloneAppearance(Mob* other);
$mob->CloneAppearance(Mob* other, bool clone_name);
$mob->CombatRange(Mob* target);
$mob->CopyHateList(Mob* to);
$mob->Damage(Mob* from, int64_t damage, uint16_t spell_id, int attack_skill, bool avoidable);
$mob->Damage(Mob* from, int64_t damage, uint16_t spell_id, int attack_skill, bool avoidable, int8_t buffslot, bool buff_tic);
$mob->Damage(Mob* from, int64_t damage, uint16_t spell_id, int attack_skill, bool avoidable, int8_t buffslot);
$mob->Damage(Mob* from, int64_t damage, uint16_t spell_id, int attack_skill);
$mob->DamageArea(int64 damage, uint32 distance);
$mob->DamageArea(int64 damage);
$mob->DamageAreaBots(int64 damage);
$mob->DamageAreaBots(int64 damage, uint32 distance);
$mob->DamageAreaBotsPercentage(int64 damage);
$mob->DamageAreaBotsPercentage(int64 damage, uint32 distance);
$mob->DamageAreaClients(int64 damage, uint32 distance);
$mob->DamageAreaClients(int64 damage);
$mob->DamageAreaClientsPercentage(int64 damage);
$mob->DamageAreaClientsPercentage(int64 damage, uint32 distance);
$mob->DamageAreaNPCs(int64 damage, uint32 distance);
$mob->DamageAreaNPCs(int64 damage);
$mob->DamageAreaNPCsPercentage(int64 damage, uint32 distance);
$mob->DamageAreaNPCsPercentage(int64 damage);
$mob->DamageAreaPercentage(int64 damage, uint32 distance);
$mob->DamageAreaPercentage(int64 damage);
$mob->DamageHateList(int64 damage);
$mob->DamageHateList(int64 damage, uint32 distance);
$mob->DamageHateListBots(int64 damage, uint32 distance);
$mob->DamageHateListBots(int64 damage);
$mob->DamageHateListBotsPercentage(int64 damage, uint32 distance);
$mob->DamageHateListBotsPercentage(int64 damage);
$mob->DamageHateListClients(int64 damage);
$mob->DamageHateListClients(int64 damage, uint32 distance);
$mob->DamageHateListClientsPercentage(int64 damage);
$mob->DamageHateListClientsPercentage(int64 damage, uint32 distance);
$mob->DamageHateListNPCs(int64 damage);
$mob->DamageHateListNPCs(int64 damage, uint32 distance);
$mob->DamageHateListNPCsPercentage(int64 damage);
$mob->DamageHateListNPCsPercentage(int64 damage, uint32 distance);
$mob->DamageHateListPercentage(int64 damage);
$mob->DamageHateListPercentage(int64 damage, uint32 distance);
$mob->DelGlobal(string var_name);
$mob->DeleteBucket(string bucket_name);
$mob->DeleteEntityVariable(string variable_name);
$mob->Depop(bool start_spawn_timer);
$mob->Depop();
$mob->DivineAura();
$mob->DoAnim(int animation_id, int animation_speed, bool ackreq, int filter);
$mob->DoAnim(int animation_id);
$mob->DoAnim(int animation_id, int animation_speed);
$mob->DoAnim(int animation_id, int animation_speed, bool ackreq);
$mob->DoArcheryAttackDmg(Mob* target, uint16 weapon_damage, int16 chance_mod, int16 focus);
$mob->DoKnockback(Mob* caster, uint32 push_back, uint32 push_up);
$mob->DoMeleeSkillAttackDmg(Mob* target, uint16 weapon_damage, int skill, int16 chance_mod, int16 focus, uint8 can_riposte);
$mob->DoSpecialAttackDamage(Mob* other, int skill, int max_damage, int min_damage, int hate_override, int reuse_time);
$mob->DoSpecialAttackDamage(Mob* other, int skill, int max_damage, int min_damage, int hate_override);
$mob->DoSpecialAttackDamage(Mob* other, int skill, int max_damage, int min_damage);
$mob->DoSpecialAttackDamage(Mob* other, int skill, int max_damage);
$mob->DoThrowingAttackDmg(Mob* target, uint16 weapon_damage, int16 chance_mod, int16 focus);
$mob->DontBuffMeBefore();
$mob->DontDotMeBefore();
$mob->DontHealMeBefore();
$mob->DontRootMeBefore();
$mob->DontSnareMeBefore();
$mob->DoubleAggro(Mob* other);
$mob->Emote(string message);
$mob->EntityVariableExists(string variable_name);
$mob->FaceTarget(Mob* target);
$mob->FaceTarget();
$mob->FindBuff(uint16 spell_id);
$mob->FindBuff(uint16 spell_id, uint16 caster_id);
$mob->FindBuffBySlot(slot);
$mob->FindGroundZ(x, y);
$mob->FindGroundZ(x, y, z_offset);
$mob->FindType(uint16_t type);
$mob->FindType(uint16_t type, offensive);
$mob->FindType(uint16_t type, offensive, uint16_t threshold);
$mob->GMMove(float x, float y, float z);
$mob->GMMove(float x, float y, float z, float heading);
$mob->GMMove(float x, float y, float z, float heading, bool save_guard_spot);
$mob->Gate();
$mob->GetAA(uint32 rank_id);
$mob->GetAABonuses();
$mob->GetAAByAAID(uint32 aa_id);
$mob->GetAC();
$mob->GetAGI();
$mob->GetATK();
$mob->GetActDoTDamage(uint16 spell_id, int64 value, Mob* target);
$mob->GetActDoTDamage(uint16 spell_id, int64 value, Mob* target, bool from_buff_tic);
$mob->GetActReflectedSpellDamage(uint16 spell_id, value, int effectiveness);
$mob->GetActSpellCasttime(uint16 spell_id, uint32 cast_time);
$mob->GetActSpellCost(uint16 spell_id, int32 cost);
$mob->GetActSpellDamage(uint16 spell_id, int64 value, Mob* target);
$mob->GetActSpellDamage(uint16 spell_id, int64 value);
$mob->GetActSpellDuration(uint16 spell_id, int32 duration);
$mob->GetActSpellHealing(uint16 spell_id, int64 value, Mob* target);
$mob->GetActSpellHealing(uint16 spell_id, int64 value, Mob* target, bool from_buff_tic);
$mob->GetActSpellHealing(uint16 spell_id, int64 value);
$mob->GetActSpellRange(uint16 spell_id, range);
$mob->GetAggroRange();
$mob->GetAllowBeneficial();
$mob->GetAppearance();
$mob->GetArchetypeName();
$mob->GetArmorTint(uint8_t material_slot);
$mob->GetAssistRange();
$mob->GetBaseGender();
$mob->GetBaseRace();
$mob->GetBaseRaceName();
$mob->GetBaseSize();
$mob->GetBeard();
$mob->GetBeardColor();
$mob->GetBodyType();
$mob->GetBucket(bucket_name);
$mob->GetBucketExpires(bucket_name);
$mob->GetBucketKey();
$mob->GetBucketRemaining(bucket_name);
$mob->GetBuffSlotFromType(uint16 type);
$mob->GetBuffSpellIDs();
$mob->GetBuffStatValueBySlot(uint8 slot, string stat);
$mob->GetBuffStatValueBySpell(spell_id, string stat);
$mob->GetBuffs();
$mob->GetCHA();
$mob->GetCR();
$mob->GetCasterLevel(uint16_t spell_id);
$mob->GetClass();
$mob->GetClassLevelFactor();
$mob->GetClassName();
$mob->GetClassPlural();
$mob->GetCleanName();
$mob->GetCloseMobList();
$mob->GetCloseMobList(float distance, bool ignore_self);
$mob->GetCloseMobList(float distance);
$mob->GetConsiderColor(Mob* other);
$mob->GetConsiderColor(uint8 other_level);
$mob->GetCorruption();
$mob->GetDEX();
$mob->GetDR();
$mob->GetDamageAmount(Mob* target);
$mob->GetDefaultRaceSize(int race_id);
$mob->GetDefaultRaceSize(int race_id, int gender_id);
$mob->GetDefaultRaceSize();
$mob->GetDeity();
$mob->GetDeityName();
$mob->GetDisplayAC();
$mob->GetDrakkinDetails();
$mob->GetDrakkinHeritage();
$mob->GetDrakkinTattoo();
$mob->GetEntityVariable(variable_name);
$mob->GetEntityVariables();
$mob->GetEquipment(uint8_t material_slot);
$mob->GetEquipmentColor(uint8_t material_slot);
$mob->GetEquipmentMaterial(uint8_t material_slot);
$mob->GetExtraHaste();
$mob->GetEyeColor1();
$mob->GetEyeColor2();
$mob->GetFR();
$mob->GetFlurryChance();
$mob->GetFollowID();
$mob->GetGender();
$mob->GetGlobal(string varname);
$mob->GetHP();
$mob->GetHPRatio();
$mob->GetHairColor();
$mob->GetHairStyle();
$mob->GetHandToHandDamage();
$mob->GetHandToHandDelay();
$mob->GetHaste();
$mob->GetHateAmount(Mob* target, bool is_damage);
$mob->GetHateAmount(Mob* target);
$mob->GetHateClosest(bool skip_mezzed);
$mob->GetHateClosest();
$mob->GetHateClosestBot();
$mob->GetHateClosestBot(bool skip_mezzed);
$mob->GetHateClosestClient(bool skip_mezzed);
$mob->GetHateClosestClient();
$mob->GetHateClosestNPC();
$mob->GetHateClosestNPC(bool skip_mezzed);
$mob->GetHateDamageTop(other);
$mob->GetHateList();
$mob->GetHateListBotCount();
$mob->GetHateListBots(uint32 distance);
$mob->GetHateListBots();
$mob->GetHateListByDistance();
$mob->GetHateListByDistance(uint32 distance);
$mob->GetHateListClientCount();
$mob->GetHateListClients(uint32 distance);
$mob->GetHateListClients();
$mob->GetHateListCount();
$mob->GetHateListNPCCount();
$mob->GetHateListNPCs();
$mob->GetHateListNPCs(uint32 distance);
$mob->GetHateRandom();
$mob->GetHateRandomBot();
$mob->GetHateRandomClient();
$mob->GetHateRandomNPC();
$mob->GetHateTop();
$mob->GetHateTopBot();
$mob->GetHateTopClient();
$mob->GetHateTopNPC();
$mob->GetHeading();
$mob->GetHelmTexture();
$mob->GetHeroicStrikethrough();
$mob->GetHerosForgeModel(uint8_t material_slot);
$mob->GetID();
$mob->GetINT();
$mob->GetInvisibleLevel();
$mob->GetInvisibleUndeadLevel();
$mob->GetInvul();
$mob->GetItemBonuses();
$mob->GetItemHPBonuses();
$mob->GetItemStat(uint32 item_id, string identifier);
$mob->GetLastName();
$mob->GetLevel();
$mob->GetLevelCon(uint8_t other_level);
$mob->GetLevelHP(uint8 level);
$mob->GetLuclinFace();
$mob->GetMR();
$mob->GetMana();
$mob->GetManaRatio();
$mob->GetMaxAGI();
$mob->GetMaxCHA();
$mob->GetMaxDEX();
$mob->GetMaxHP();
$mob->GetMaxINT();
$mob->GetMaxMana();
$mob->GetMaxSTA();
$mob->GetMaxSTR();
$mob->GetMaxWIS();
$mob->GetMeleeMitigation();
$mob->GetMobTypeIdentifier();
$mob->GetModSkillDmgTaken(skill_id);
$mob->GetModVulnerability(uint8 resist);
$mob->GetNPCTypeID();
$mob->GetName();
$mob->GetNimbusEffect1();
$mob->GetNimbusEffect2();
$mob->GetNimbusEffect3();
$mob->GetOwner();
$mob->GetOwnerID();
$mob->GetPR();
$mob->GetPet();
$mob->GetPetID();
$mob->GetPetOrder();
$mob->GetPetType();
$mob->GetPhR();
$mob->GetRace();
$mob->GetRaceName();
$mob->GetRacePlural();
$mob->GetRemainingTimeMS(string timer_name);
$mob->GetResist(uint8_t type);
$mob->GetReverseFactionCon(Mob* other);
$mob->GetRunAnimSpeed();
$mob->GetRunspeed();
$mob->GetSTA();
$mob->GetSTR();
$mob->GetSize();
$mob->GetSkill(int skill_id);
$mob->GetSkillDmgAmt(skill_id);
$mob->GetSkillDmgTaken(skill_id);
$mob->GetSpecialAbility(ability);
$mob->GetSpecialAbilityParam(ability, param);
$mob->GetSpecializeSkillValue(uint16 spell_id);
$mob->GetSpellBonuses();
$mob->GetSpellHPBonuses();
$mob->GetSpellIDFromSlot(uint8_t slot);
$mob->GetSpellStat(uint32 spell_id, string stat);
$mob->GetSpellStat(uint32 spell_id, string stat, uint8 slot);
$mob->GetTarget();
$mob->GetTexture();
$mob->GetTimerDurationMS(string timer_name);
$mob->GetUltimateOwner();
$mob->GetWIS();
$mob->GetWalkspeed();
$mob->GetWaypointH();
$mob->GetWaypointID();
$mob->GetWaypointPause();
$mob->GetWaypointX();
$mob->GetWaypointY();
$mob->GetWaypointZ();
$mob->GetX();
$mob->GetY();
$mob->GetZ();
$mob->GetZoneID();
$mob->GoToBind();
$mob->HalveAggro(Mob* other);
$mob->HasNPCSpecialAtk(string ability_string);
$mob->HasOwner();
$mob->HasPet();
$mob->HasProcs();
$mob->HasShieldEquipped();
$mob->HasSpellEffect(int effect_id);
$mob->HasTimer(string timer_name);
$mob->HasTwoHandBluntEquipped();
$mob->HasTwoHanderEquipped();
$mob->HateSummon();
$mob->HealDamage(int64_t amount, Mob* caster);
$mob->HealDamage(int64_t amount);
$mob->InterruptSpell(uint16 spell_id);
$mob->InterruptSpell();
$mob->IsAIControlled();
$mob->IsAlwaysAggro();
$mob->IsAmnesiad();
$mob->IsAnimation();
$mob->IsAttackAllowed(Mob* target);
$mob->IsAttackAllowed(Mob* target, is_spell_attack);
$mob->IsAura();
$mob->IsBeacon();
$mob->IsBeneficialAllowed(Mob* target);
$mob->IsBerserk();
$mob->IsBlind();
$mob->IsBoat();
$mob->IsBot();
$mob->IsCasting();
$mob->IsCharmed();
$mob->IsClient();
$mob->IsControllableBoat();
$mob->IsCorpse();
$mob->IsDestructibleObject();
$mob->IsDoor();
$mob->IsEliteMaterialItem(uint8_t material_slot);
$mob->IsEncounter();
$mob->IsEngaged();
$mob->IsEnraged();
$mob->IsFamiliar();
$mob->IsFeared();
$mob->IsFindable();
$mob->IsHorse();
$mob->IsImmuneToSpell(uint16 spell_id, Mob* caster);
$mob->IsIntelligenceCasterClass();
$mob->IsInvisible();
$mob->IsInvisible(Mob* other);
$mob->IsMeleeDisabled();
$mob->IsMerc();
$mob->IsMezzed();
$mob->IsMob();
$mob->IsMoving();
$mob->IsNPC();
$mob->IsNPCCorpse();
$mob->IsObject();
$mob->IsOfClientBot();
$mob->IsOfClientBotMerc();
$mob->IsPausedTimer(string timer_name);
$mob->IsPet();
$mob->IsPetOwnerBot();
$mob->IsPetOwnerClient();
$mob->IsPetOwnerNPC();
$mob->IsPlayerCorpse();
$mob->IsPureMeleeClass();
$mob->IsRoamer();
$mob->IsRooted();
$mob->IsRunning();
$mob->IsSilenced();
$mob->IsStunned();
$mob->IsTargetLockPet();
$mob->IsTargetable();
$mob->IsTargeted();
$mob->IsTemporaryPet();
$mob->IsTrackable();
$mob->IsTrap();
$mob->IsWarriorClass();
$mob->IsWisdomCasterClass();
$mob->Kill();
$mob->MakePet(uint16 spell_id, string pet_type);
$mob->MakePet(uint16 spell_id, string pet_type, string name);
$mob->MakeTempPet(uint16 spell_id);
$mob->MakeTempPet(uint16 spell_id, string name, uint32 duration, Mob* target, bool sticktarg);
$mob->MakeTempPet(uint16 spell_id, string name, uint32 duration, Mob* target);
$mob->MakeTempPet(uint16 spell_id, string name, uint32 duration);
$mob->MakeTempPet(uint16 spell_id, string name);
$mob->MassGroupBuff(Mob* center, uint16 spell_id);
$mob->MassGroupBuff(Mob* center, uint16 spell_id, bool affect_caster);
$mob->Mesmerize();
$mob->Message(uint32 type, string message);
$mob->Message_StringID(uint32 type, uint32 string_id);
$mob->Message_StringID(uint32 type, uint32 string_id, uint32 distance);
$mob->ModSkillDmgTaken(int skill, int16 value);
$mob->ModVulnerability(uint8 resist, int16 value);
$mob->NPCSpecialAttacks(string abilities_string, int perm_tag, bool reset);
$mob->NPCSpecialAttacks(string abilities_string, int perm_tag, bool reset, bool remove);
$mob->NPCSpecialAttacks(string abilities_string, int perm_tag);
$mob->NavigateTo(float x, float y, float z);
$mob->PauseTimer(string timer_name);
$mob->ProcessSpecialAbilities(string str);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow, float speed);
$mob->ProjectileAnim(Mob* to, int item_id);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow, float speed, float angle, float tilt, float arc, string idfile);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow, float speed, float angle, float tilt, float arc);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow, float speed, float angle, float tilt);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow, float speed, float angle);
$mob->ProjectileAnim(Mob* to, int item_id, bool is_arrow);
$mob->RandomizeFeatures();
$mob->RandomizeFeatures(send_illusion);
$mob->RandomizeFeatures(send_illusion, save_variables);
$mob->RangedAttack(Mob* other);
$mob->RemoveAllAppearanceEffects();
$mob->RemoveAllNimbusEffects();
$mob->RemoveFromFeignMemory(Client* attacker);
$mob->RemoveNimbusEffect(int effect_id);
$mob->RemovePet();
$mob->ResistSpell(uint8 resist_type, uint16 spell_id, Mob* caster);
$mob->RestoreEndurance();
$mob->RestoreHealth();
$mob->RestoreMana();
$mob->ResumeTimer(string timer_name);
$mob->RogueAssassinate(Mob* other);
$mob->RunTo(float x, float y, float z);
$mob->Say(string message);
$mob->SeeHide();
$mob->SeeImprovedHide();
$mob->SeeInvisible();
$mob->SeeInvisibleUndead();
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3, uint32 ground3, uint32 slot4, uint32 ground4, uint32 slot5, uint32 ground5);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3, uint32 ground3);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3, uint32 ground3, uint32 slot4);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3, uint32 ground3, uint32 slot4, uint32 ground4);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2, uint32 ground2, uint32 slot3, uint32 ground3, uint32 slot4, uint32 ground4, uint32 slot5);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2);
$mob->SendAppearanceEffect(int32 parm1);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client, uint32 slot1, uint32 ground1, uint32 slot2);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5);
$mob->SendAppearanceEffect(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, perl::nullable<Client*> client);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3, int32 parm4);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3, int32 parm4, uint32 slot4);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3, int32 parm4, uint32 slot4, int32 parm5);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3, int32 parm4, uint32 slot4, int32 parm5, uint32 slot5);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3, int32 parm4, uint32 slot4, int32 parm5, uint32 slot5, Client* client);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3, uint32 slot3);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2, int32 parm3);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2, uint32 slot2);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1, int32 parm2);
$mob->SendAppearanceEffectActor(int32 parm1, uint32 slot1);
$mob->SendAppearanceEffectGround(int32 parm1, int32 parm2, int32 parm3, int32 parm4);
$mob->SendAppearanceEffectGround(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5);
$mob->SendAppearanceEffectGround(int32 parm1, int32 parm2, int32 parm3, int32 parm4, int32 parm5, Client* client);
$mob->SendAppearanceEffectGround(int32 parm1);
$mob->SendAppearanceEffectGround(int32 parm1, int32 parm2);
$mob->SendAppearanceEffectGround(int32 parm1, int32 parm2, int32 parm3);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color, uint32 drakkin_heritage, uint32 drakkin_tattoo, uint32 drakkin_details);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color, uint32 drakkin_heritage);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color, uint32 drakkin_heritage, uint32 drakkin_tattoo, uint32 drakkin_details, float size);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color, uint32 drakkin_heritage, uint32 drakkin_tattoo);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture, uint8 helmet_texture, uint8 face, uint8 hair, uint8 hair_color, uint8 beard, uint8 beard_color, uint32 drakkin_heritage, uint32 drakkin_tattoo, uint32 drakkin_details, float size, Client *target);
$mob->SendIllusion(uint16 race_id, uint8 gender_id, uint8 texture);
$mob->SendIllusion(uint16 race_id, uint8 gender_id);
$mob->SendIllusion(uint16 race_id);
$mob->SendIllusionPacket(reference table_ref);
$mob->SendTo(float new_x, float new_y, float new_z);
$mob->SendToFixZ(float new_x, float new_y, float new_z);
$mob->SendWearChange(uint8_t material_slot);
$mob->SetAA(int aa_id, int points, int charges);
$mob->SetAA(int aa_id, int points);
$mob->SetAllowBeneficial(bool value);
$mob->SetAppearance(int app, bool ignore_self);
$mob->SetAppearance(int app);
$mob->SetBodyType(uint8 body_type_id);
$mob->SetBodyType(uint8 body_type_id, bool overwrite_orig);
$mob->SetBucket(string bucket_name, string bucket_value);
$mob->SetBucket(string bucket_name, string bucket_value, string expiration);
$mob->SetBuffDuration(int spell_id);
$mob->SetBuffDuration(int spell_id, int duration, int level);
$mob->SetBuffDuration(int spell_id, int duration);
$mob->SetCurrentWP(int waypoint);
$mob->SetDeltas(float delta_x, float delta_y, float delta_z, float delta_h);
$mob->SetDisableMelee(bool value);
$mob->SetEntityVariable(string variable_name, string variable_value);
$mob->SetExtraHaste(int haste, bool need_to_save);
$mob->SetExtraHaste(int haste);
$mob->SetFlurryChance(uint8 value);
$mob->SetFlyMode(int flymode);
$mob->SetFollowID(uint32_t id);
$mob->SetGender(uint8 gender_id);
$mob->SetGlobal(string varname, string newvalue, int options, string duration, Mob* other);
$mob->SetGlobal(string varname, string newvalue, int options, string duration);
$mob->SetHP(int64_t hp);
$mob->SetHate(Mob* other);
$mob->SetHate(Mob* other, int64_t hate, int64_t damage);
$mob->SetHate(Mob* other, int64_t hate);
$mob->SetHeading(float heading);
$mob->SetInvisible(uint8_t state);
$mob->SetInvul(bool value);
$mob->SetLD(bool value);
$mob->SetLevel(uint8_t in_level);
$mob->SetLevel(uint8_t in_level, bool command);
$mob->SetMana(amount);
$mob->SetMaxHP();
$mob->SetOOCRegen(int64 new_ooc_regen);
$mob->SetOwnerID(uint16 new_owner_id);
$mob->SetPet(Mob* new_pet);
$mob->SetPetID(uint16 new_pet_id);
$mob->SetPetOrder(int order);
$mob->SetRace(uint16 race_id);
$mob->SetRunAnimSpeed(int8 speed);
$mob->SetRunning(bool value);
$mob->SetSeeInvisibleLevel(uint8 see_invis_level);
$mob->SetSeeInvisibleUndeadLevel(uint8 see_invis_undead_level);
$mob->SetSlotTint(uint8 material_slot, uint8 red_tint, uint8 green_tint, uint8 blue_tint);
$mob->SetSpecialAbility(int ability, int value);
$mob->SetSpecialAbilityParam(int ability, int param, int value);
$mob->SetTarget(Mob* target);
$mob->SetTargetable(bool on);
$mob->SetTexture(uint8 texture);
$mob->SetTimer(string timer_name, int seconds);
$mob->SetTimerMS(string timer_name, int milliseconds);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance, int32 shield_duration, int32 shield_target_mitigation);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance, int32 shield_duration, int32 shield_target_mitigation, int32 shielder_mitigation, bool use_aa, bool can_shield_npc);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance, int32 shield_duration, int32 shield_target_mitigation, int32 shielder_mitigation, bool use_aa);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance, int32 shield_duration, int32 shield_target_mitigation, int32 shielder_mitigation);
$mob->ShieldAbility(uint32 target_id);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance, int32 shield_duration);
$mob->ShieldAbility(uint32 target_id, int32 shielder_max_distance);
$mob->Shout(string message);
$mob->SignalClient(Client* client, int signal_id);
$mob->SpellEffect(uint32 effect);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk20, bool perm_effect);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk20, bool perm_effect, Client* client);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk20, bool perm_effect, perl::nullable<Client*> client, uint32 caster_id);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk20, bool perm_effect, perl::nullable<Client*> client, uint32 caster_id, uint32 target_id);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay);
$mob->SpellEffect(uint32 effect, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk20);
$mob->SpellEffect(uint32 effect, uint32 duration);
$mob->SpellFinished(uint16 spell_id, Mob* target, int32 mana_cost);
$mob->SpellFinished(uint16 spell_id, Mob* target, int32 mana_cost, uint16 resist_diff);
$mob->SpellFinished(uint16 spell_id, Mob* target);
$mob->SpellFinished(uint16 spell_id);
$mob->Spin();
$mob->StartEnrage();
$mob->StopAllTimers();
$mob->StopNavigation();
$mob->StopTimer(string timer_name);
$mob->Stun(int duration);
$mob->TarGlobal(string varname, string value, string duration, int npc_id, int char_id, int zone_id);
$mob->TempName();
$mob->TempName(string name);
$mob->ThrowingAttack(Mob* other);
$mob->TryMoveAlong(float distance, float angle);
$mob->TryMoveAlong(float distance, float angle, bool send);
$mob->TypesTempPet(uint32 type_id, string name, uint32 duration, bool follow, Mob* target, bool stick_targ);
$mob->TypesTempPet(uint32 type_id, string name, uint32 duration, bool follow, Mob* target);
$mob->TypesTempPet(uint32 type_id);
$mob->TypesTempPet(uint32 type_id, string name);
$mob->TypesTempPet(uint32 type_id, string name, uint32 duration);
$mob->TypesTempPet(uint32 type_id, string name, uint32 duration, bool follow);
$mob->WalkTo(float x, float y, float z);
$mob->WearChange(uint8 material_slot, uint32 texture, uint32 color);
$mob->WearChange(uint8 material_slot, uint32 texture);
$mob->WearChange(uint8 material_slot, uint32 texture, uint32 color, uint32 hero_forge_model);
$mob->WipeHateList();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`mob:AddNimbusEffect(int effect_id);
mob:AddToHateList(Mob other, int64 hate, int64 damage, bool yell_for_help, bool frenzy, bool buff_tic);
mob:AddToHateList(Mob other, int64 hate, int64 damage);
mob:AddToHateList(Mob other, int64 hate, int64 damage, bool yell_for_help);
mob:AddToHateList(Mob other, int64 hate, int64 damage, bool yell_for_help, bool frenzy);
mob:AddToHateList(Mob other);
mob:AddToHateList(Mob other, int64 hate);
mob:ApplySpellBuff(int spell_id, int duration);
mob:ApplySpellBuff(int spell_id);
mob:ApplySpellBuff(int spell_id, int duration, int level);
mob:AreaAttack(float distance, int16 slot_id);
mob:AreaAttack(float distance, int16 slot_id, int count);
mob:AreaAttack(float distance, int16 slot_id, int count, bool is_from_spell);
mob:AreaAttack(float distance, int16 slot_id, int count, bool is_from_spell, int attack_rounds);
mob:AreaAttack(float distance);
mob:AreaSpell(Mob center, uint16 spell_id, bool affect_caster);
mob:AreaSpell(Mob center, uint16 spell_id, bool affect_caster, int16 resist_adjust, int max_targets);
mob:AreaSpell(Mob center, uint16 spell_id);
mob:AreaSpell(Mob center, uint16 spell_id, bool affect_caster, int16 resist_adjust);
mob:Attack(Mob other, int hand);
mob:Attack(Mob other, int hand, from_riposte);
mob:Attack(Mob other, int hand, from_riposte, is_strikethrough, is_from_spell, object opts);
mob:Attack(Mob other, int hand, from_riposte, is_strikethrough, is_from_spell);
mob:Attack(Mob other);
mob:Attack(Mob other, int hand, from_riposte, is_strikethrough);
mob:AttackAnimation(Hand, ItemInst weapon);
mob:BehindMob(Mob other);
mob:BehindMob(Mob other, float x);
mob:BehindMob();
mob:BehindMob(Mob other, float x, float y);
mob:BuffCount();
mob:BuffCount(bool is_beneficial, bool is_detrimental);
mob:BuffCount(bool is_beneficial);
mob:BuffFadeAll();
mob:BuffFadeBeneficial();
mob:BuffFadeByEffect(int effect_id, int skipslot);
mob:BuffFadeByEffect(int effect_id);
mob:BuffFadeBySlot(int slot);
mob:BuffFadeBySlot(int slot, bool recalc_bonuses);
mob:BuffFadeBySpellID(int spell_id);
mob:BuffFadeDetrimental();
mob:BuffFadeDetrimentalByCaster(Mob caster);
mob:BuffFadeNonPersistDeath();
mob:BuffFadeSongs();
mob:CalculateDistance(double x, double y, double z);
mob:CalculateDistance(Mob mob);
mob:CalculateHeadingToTarget(in_x, in_y);
mob:CameraEffect(uint32 duration, float intensity, Client c, bool global);
mob:CameraEffect(uint32 duration, float intensity, Client c);
mob:CameraEffect(uint32 duration, float intensity);
mob:CanBuffStack(spell_id, caster_level);
mob:CanBuffStack(spell_id, caster_level, bool fail_if_overwrite);
mob:CanClassEquipItem(uint32 item_id);
mob:CanRaceEquipItem(uint32 item_id);
mob:CanThisClassBlock();
mob:CanThisClassDodge();
mob:CanThisClassDoubleAttack();
mob:CanThisClassDualWield();
mob:CanThisClassParry();
mob:CanThisClassRiposte();
mob:CastSpell(int spell_id, int target_id);
mob:CastSpell(int spell_id, int target_id, int slot, int cast_time, int mana_cost, int item_slot, int timer, );
mob:CastSpell(int spell_id, int target_id, int slot, int cast_time, int mana_cost, int item_slot);
mob:CastSpell(int spell_id, int target_id, int slot, int cast_time, int mana_cost);
mob:CastSpell(int spell_id, int target_id, int slot, int cast_time);
mob:CastSpell(int spell_id, int target_id, int slot);
mob:CastSpell(int spell_id, int target_id, int slot, int cast_time, int mana_cost, int item_slot, int timer, );
mob:ChangeBeard(int in);
mob:ChangeBeardColor(int in);
mob:ChangeDrakkinDetails(int in);
mob:ChangeDrakkinHeritage(int in);
mob:ChangeDrakkinTattoo(int in);
mob:ChangeEyeColor1(int in);
mob:ChangeEyeColor2(int in);
mob:ChangeGender(int in);
mob:ChangeHairColor(int in);
mob:ChangeHairStyle(int in);
mob:ChangeHelmTexture(int in);
mob:ChangeLuclinFace(int in);
mob:ChangeRace(int in);
mob:ChangeSize(double in_size);
mob:ChangeSize(double in_size, bool unrestricted);
mob:ChangeTexture(int in);
mob:Charmed();
mob:CheckAggro(Mob other);
mob:CheckAggroAmount(spell_id);
mob:CheckAggroAmount(spell_id, bool is_proc);
mob:CheckHealAggroAmount(spell_id, uint32 heal_possible);
mob:CheckHealAggroAmount(spell_id);
mob:CheckLoS(Mob other);
mob:CheckLoSToLoc(double x, double y, double z);
mob:CheckLoSToLoc(double x, double y, double z, double mob_size);
mob:CheckNumHitsRemaining(int type, int32 buff_slot, uint16 spell_id);
mob:ClearEntityVariables();
mob:ClearSpecialAbilities();
mob:CloneAppearance(Mob other, bool clone_name);
mob:CloneAppearance(Mob other);
mob:CombatRange(Mob other);
mob:CopyHateList(Mob to);
mob:Damage(Mob from, int64 damage, int spell_id, int attack_skill);
mob:Damage(Mob from, int64 damage, int spell_id, int attack_skill, bool avoidable, int buffslot, bool buff_tic);
mob:Damage(Mob from, int64 damage, int spell_id, int attack_skill, bool avoidable, int buffslot);
mob:Damage(Mob from, int64 damage, int spell_id, int attack_skill, bool avoidable);
mob:DamageArea(int64 damage, uint32 distance);
mob:DamageArea(int64 damage);
mob:DamageAreaBots(int64 damage);
mob:DamageAreaBots(int64 damage, uint32 distance);
mob:DamageAreaBotsPercentage(int64 damage, uint32 distance);
mob:DamageAreaBotsPercentage(int64 damage);
mob:DamageAreaClients(int64 damage, uint32 distance);
mob:DamageAreaClients(int64 damage);
mob:DamageAreaClientsPercentage(int64 damage);
mob:DamageAreaClientsPercentage(int64 damage, uint32 distance);
mob:DamageAreaNPCs(int64 damage, uint32 distance);
mob:DamageAreaNPCs(int64 damage);
mob:DamageAreaNPCsPercentage(int64 damage);
mob:DamageAreaNPCsPercentage(int64 damage, uint32 distance);
mob:DamageAreaPercentage(int64 damage, uint32 distance);
mob:DamageAreaPercentage(int64 damage);
mob:DamageHateList(int64 damage, uint32 distance);
mob:DamageHateList(int64 damage);
mob:DamageHateListBotsPercentage(int64 damage);
mob:DamageHateListBotsPercentage(int64 damage, uint32 distance);
mob:DamageHateListBotsPercentage(int64 damage, uint32 distance);
mob:DamageHateListBotsPercentage(int64 damage);
mob:DamageHateListClients(int64 damage, uint32 distance);
mob:DamageHateListClients(int64 damage);
mob:DamageHateListClientsPercentage(int64 damage);
mob:DamageHateListClientsPercentage(int64 damage, uint32 distance);
mob:DamageHateListNPCs(int64 damage, uint32 distance);
mob:DamageHateListNPCs(int64 damage);
mob:DamageHateListNPCsPercentage(int64 damage, uint32 distance);
mob:DamageHateListNPCsPercentage(int64 damage);
mob:DamageHateListPercentage(int64 damage, uint32 distance);
mob:DamageHateListPercentage(int64 damage);
mob:DelGlobal(string varname);
mob:DeleteBucket(string bucket_name);
mob:DeleteEntityVariable(string variable_name);
mob:Depop();
mob:Depop(bool start_spawn_timer);
mob:DivineAura();
mob:DoAnim(int animation_id, int animation_speed, bool ackreq);
mob:DoAnim(int animation_id, int animation_speed);
mob:DoAnim(int animation_id, int animation_speed, bool ackreq, int filter);
mob:DoAnim(int animation_id);
mob:DoArcheryAttackDmg(Mob other, ItemInst range_weapon);
mob:DoArcheryAttackDmg(Mob other);
mob:DoArcheryAttackDmg(Mob other, ItemInst range_weapon, ItemInst ammo, int weapon_damage, int chance_mod, );
mob:DoArcheryAttackDmg(Mob other, ItemInst range_weapon, ItemInst ammo, int weapon_damage, int chance_mod);
mob:DoArcheryAttackDmg(Mob other, ItemInst range_weapon, ItemInst ammo, int weapon_damage);
mob:DoArcheryAttackDmg(Mob other, ItemInst range_weapon, ItemInst ammo);
mob:DoKnockback(Mob caster, uint32 push_back, uint32 push_up);
mob:DoMeleeSkillAttackDmg(Mob other, int weapon_damage, int skill, int chance_mod, int focus);
mob:DoMeleeSkillAttackDmg(Mob other, int weapon_damage, int skill);
mob:DoMeleeSkillAttackDmg(Mob other, int weapon_damage, int skill, int chance_mod);
mob:DoMeleeSkillAttackDmg(Mob other, int weapon_damage, int skill, int chance_mod, int focus, bool can_riposte);
mob:DoSpecialAttackDamage(Mob other, int skill, int max_damage, int min_damage, int hate_override, int reuse_time);
mob:DoSpecialAttackDamage(Mob other, int skill, int max_damage);
mob:DoSpecialAttackDamage(Mob other, int skill, int max_damage, int min_damage);
mob:DoSpecialAttackDamage(Mob other, int skill, int max_damage, int min_damage, int hate_override);
mob:DoThrowingAttackDmg(Mob other);
mob:DoThrowingAttackDmg(Mob other, ItemInst range_weapon, Item item, int weapon_damage, int chance_mod);
mob:DoThrowingAttackDmg(Mob other, ItemInst range_weapon, Item item, int weapon_damage);
mob:DoThrowingAttackDmg(Mob other, ItemInst range_weapon, Item item, int weapon_damage, int chance_mod, );
mob:DoThrowingAttackDmg(Mob other, ItemInst range_weapon, Item item);
mob:DoThrowingAttackDmg(Mob other, ItemInst range_weapon);
mob:DoubleAggro(Mob other);
mob:Emote(string message);
mob:EntityVariableExists(string variable_name);
mob:FaceTarget(Mob target);
mob:FindBuff(uint16 spell_id);
mob:FindBuff(uint16 spell_id, uint16 caster_id);
mob:FindBuffBySlot(int slot);
mob:FindGroundZ(x, y);
mob:FindGroundZ(x, y, z);
mob:FindType(int type, offensive);
mob:FindType(int type, offensive, int threshold);
mob:FindType(int type);
mob:GMMove(double x, double y, double z, double heading);
mob:GMMove(double x, double y, double z, double heading, bool save_guard_spot);
mob:GMMove(double x, double y, double z);
mob:Gate();
mob:GetAA(id);
mob:GetAABonuses();
mob:GetAAByAAID(id);
mob:GetAC();
mob:GetAGI();
mob:GetATK();
mob:GetActDoTDamage(uint16 spell_id, value, Mob target);
mob:GetActDoTDamage(uint16 spell_id, value, Mob target, bool from_buff_tic);
mob:GetActReflectedSpellDamage(uint16 spell_id, value, int effectiveness);
mob:GetActSpellCasttime(uint16 spell_id, uint32 cast_time);
mob:GetActSpellCost(uint16 spell_id, cost);
mob:GetActSpellDamage(uint16 spell_id, value);
mob:GetActSpellDamage(uint16 spell_id, value, Mob target);
mob:GetActSpellDuration(uint16 spell_id, duration);
mob:GetActSpellHealing(uint16 spell_id, value);
mob:GetActSpellHealing(uint16 spell_id, value, Mob target);
mob:GetActSpellHealing(uint16 spell_id, value, Mob target, bool from_buff_tic);
mob:GetActSpellRange(uint16 spell_id, range);
mob:GetAggroRange();
mob:GetAllowBeneficial();
mob:GetAppearance();
mob:GetArchetypeName();
mob:GetAssistRange();
mob:GetBaseGender();
mob:GetBaseRace();
mob:GetBaseRaceName();
mob:GetBaseSize();
mob:GetBeard();
mob:GetBeardColor();
mob:GetBodyType();
mob:GetBucket(bucket_name);
mob:GetBucketExpires(bucket_name);
mob:GetBucketKey();
mob:GetBucketRemaining(bucket_name);
mob:GetBuffSlotFromType(slot);
mob:GetBuffSpellIDs();
mob:GetBuffStatValueBySlot(uint8 slot, string identifier);
mob:GetBuffStatValueBySpell(spell_id, string identifier);
mob:GetCHA();
mob:GetCR();
mob:GetCasterLevel(spell_id);
mob:GetClass();
mob:GetClassName();
mob:GetClassPlural();
mob:GetCleanName();
mob:GetCloseMobList();
mob:GetCloseMobList(float distance);
mob:GetCloseMobList(float distance, bool ignore_self);
mob:GetConsiderColor(uint8 other_level);
mob:GetConsiderColor(Mob other);
mob:GetCorruption();
mob:GetDEX();
mob:GetDR();
mob:GetDamageAmount(Mob target);
mob:GetDefaultRaceSize(int race_id);
mob:GetDefaultRaceSize();
mob:GetDefaultRaceSize(int race_id, int gender_id);
mob:GetDeity();
mob:GetDeityName();
mob:GetDisplayAC();
mob:GetDrakkinDetails();
mob:GetDrakkinHeritage();
mob:GetDrakkinTattoo();
mob:GetEntityVariable(variable_name);
mob:GetEntityVariables();
mob:GetExtraHaste();
mob:GetEyeColor1();
mob:GetEyeColor2();
mob:GetFR();
mob:GetFcDamageAmtIncoming(Mob caster, int32 spell_id);
mob:GetFlurryChance();
mob:GetGender();
mob:GetGlobal(string varname);
mob:GetHP();
mob:GetHPRatio();
mob:GetHairColor();
mob:GetHairStyle();
mob:GetHandToHandDamage();
mob:GetHandToHandDelay();
mob:GetHaste();
mob:GetHateAmount(Mob target, bool is_damage);
mob:GetHateAmount(Mob target);
mob:GetHateClosest();
mob:GetHateClosest(bool skip_mezzed);
mob:GetHateClosestBot();
mob:GetHateClosestBot(bool skip_mezzed);
mob:GetHateClosestClient();
mob:GetHateClosestClient(bool skip_mezzed);
mob:GetHateClosestNPC();
mob:GetHateClosestNPC(bool skip_mezzed);
mob:GetHateDamageTop(other);
mob:GetHateList();
mob:GetHateListBotCount();
mob:GetHateListBots();
mob:GetHateListBots(uint32 distance);
mob:GetHateListByDistance(uint32 distance);
mob:GetHateListByDistance();
mob:GetHateListClientCount();
mob:GetHateListClients(uint32 distance);
mob:GetHateListClients();
mob:GetHateListCount();
mob:GetHateListNPCCount();
mob:GetHateListNPCs();
mob:GetHateListNPCs(uint32 distance);
mob:GetHateRandom();
mob:GetHateRandomBot();
mob:GetHateRandomClient();
mob:GetHateRandomNPC();
mob:GetHateTop();
mob:GetHateTopBot();
mob:GetHateTopClient();
mob:GetHateTopNPC();
mob:GetHeading();
mob:GetHelmTexture();
mob:GetHeroicStrikethrough();
mob:GetHerosForgeModel(uint8 material_slot);
mob:GetINT();
mob:GetInvisibleLevel();
mob:GetInvisibleUndeadLevel();
mob:GetInvul();
mob:GetItemBonuses();
mob:GetItemHPBonuses();
mob:GetLastName();
mob:GetLevel();
mob:GetLevelCon(int my, int other);
mob:GetLevelCon(int other);
mob:GetLuclinFace();
mob:GetMR();
mob:GetMana();
mob:GetManaRatio();
mob:GetMaxAGI();
mob:GetMaxCHA();
mob:GetMaxDEX();
mob:GetMaxHP();
mob:GetMaxINT();
mob:GetMaxMana();
mob:GetMaxSTA();
mob:GetMaxSTR();
mob:GetMaxWIS();
mob:GetMeleeDamageMod_SE(uskill);
mob:GetMeleeMinDamageMod_SE(uskill);
mob:GetMeleeMitigation();
mob:GetMobTypeIdentifier();
mob:GetModSkillDmgTaken(skill);
mob:GetModVulnerability(resist);
mob:GetNPCTypeID();
mob:GetName();
mob:GetNimbusEffect1();
mob:GetNimbusEffect2();
mob:GetNimbusEffect3();
mob:GetOrigBodyType();
mob:GetOwner();
mob:GetOwnerID();
mob:GetPR();
mob:GetPet();
mob:GetPetOrder();
mob:GetPhR();
mob:GetRace();
mob:GetRaceName();
mob:GetRacePlural();
mob:GetRemainingTimeMS(string timer_name);
mob:GetResist(type);
mob:GetReverseFactionCon(Mob other);
mob:GetRunspeed();
mob:GetSTA();
mob:GetSTR();
mob:GetShuffledHateList();
mob:GetSize();
mob:GetSkill(skill);
mob:GetSkillDmgAmt(skill_id);
mob:GetSkillDmgTaken(skill);
mob:GetSpecialAbility(ability);
mob:GetSpecialAbilityParam(ability, param);
mob:GetSpecializeSkillValue(spell_id);
mob:GetSpellBonuses();
mob:GetSpellHPBonuses();
mob:GetTarget();
mob:GetTexture();
mob:GetTimerDurationMS(string timer_name);
mob:GetUltimateOwner();
mob:GetWIS();
mob:GetWalkspeed();
mob:GetWaypointH();
mob:GetWaypointID();
mob:GetWaypointPause();
mob:GetWaypointX();
mob:GetWaypointY();
mob:GetWaypointZ();
mob:GetWeaponDamage(Mob against, ItemInst weapon);
mob:GetWeaponDamageBonus(Item weapon, bool offhand);
mob:GetX();
mob:GetY();
mob:GetZ();
mob:GotoBind();
mob:HalveAggro(Mob other);
mob:HasNPCSpecialAtk(string parse);
mob:HasOwner();
mob:HasPet();
mob:HasProcs();
mob:HasShieldEquipped();
mob:HasSpellEffect(int effect_id);
mob:HasTimer(string timer_name);
mob:HasTwoHandBluntEquipped();
mob:HasTwoHanderEquipped();
mob:HealDamage(uint64 amount);
mob:HealDamage(uint64 amount, Mob other);
mob:InterruptSpell();
mob:InterruptSpell(int spell_id);
mob:IsAIControlled();
mob:IsAlwaysAggro();
mob:IsAmnesiad();
mob:IsAnimation();
mob:IsAttackAllowed(Mob target, is_spell_attack);
mob:IsAttackAllowed(Mob target);
mob:IsBeneficialAllowed(Mob target);
mob:IsBerserk();
mob:IsBlind();
mob:IsBoat();
mob:IsCasting();
mob:IsCharmed();
mob:IsControllableBoat();
mob:IsDestructibleObject();
mob:IsEliteMaterialItem(uint8 material_slot);
mob:IsEngaged();
mob:IsEnraged();
mob:IsFamiliar();
mob:IsFeared();
mob:IsFindable();
mob:IsHorse();
mob:IsImmuneToSpell(int spell_id, Mob caster);
mob:IsIntelligenceCasterClass();
mob:IsInvisible(Mob other);
mob:IsInvisible();
mob:IsMeleeDisabled();
mob:IsMezzed();
mob:IsMoving();
mob:IsPausedTimer(string timer_name);
mob:IsPet();
mob:IsPetOwnerBot();
mob:IsPetOwnerClient();
mob:IsPetOwnerNPC();
mob:IsPureMeleeClass();
mob:IsRoamer();
mob:IsRooted();
mob:IsRunning();
mob:IsSilenced();
mob:IsStunned();
mob:IsTargetLockPet();
mob:IsTargetable();
mob:IsTargeted();
mob:IsTemporaryPet();
mob:IsTrackable();
mob:IsWarriorClass();
mob:IsWisdomCasterClass();
mob:Kill();
mob:MassGroupBuff(Mob center, uint16 spell_id);
mob:MassGroupBuff(Mob center, uint16 spell_id, bool affect_caster);
mob:Mesmerize();
mob:Message(uint32 type, string message);
mob:Message_StringID(uint32 type, uint32 string_id, uint32 distance);
mob:ModSkillDmgTaken(int skill, int value);
mob:ModVulnerability(int resist, int value);
mob:NPCSpecialAttacks(string parse, int perm, bool reset, bool remove);
mob:NPCSpecialAttacks(string parse, int perm, bool reset);
mob:NPCSpecialAttacks(string parse, int perm);
mob:NavigateTo(double x, double y, double z);
mob:PauseTimer(string timer_name);
mob:ProcessSpecialAbilities(string str);
mob:ProjectileAnimation(Mob to, int item_id);
mob:ProjectileAnimation(Mob to, int item_id, bool is_arrow);
mob:ProjectileAnimation(Mob to, int item_id, bool is_arrow, double speed, double angle, double tilt, double arc);
mob:ProjectileAnimation(Mob to, int item_id, bool is_arrow, double speed);
mob:ProjectileAnimation(Mob to, int item_id, bool is_arrow, double speed, double angle);
mob:ProjectileAnimation(Mob to, int item_id, bool is_arrow, double speed, double angle, double tilt);
mob:QuestSay(Client client, string message);
mob:QuestSay(Client client, string message, object opts);
mob:RandomizeFeatures(send_illusion, save_variables);
mob:RandomizeFeatures(send_illusion);
mob:RandomizeFeatures();
mob:RangedAttack(Mob other);
mob:RemoveAllNimbusEffects();
mob:RemoveNimbusEffect(int effect_id);
mob:RemovePet();
mob:ResistSpell(int resist_type, int spell_id, Mob caster);
mob:ResistSpell(int resist_type, int spell_id, Mob caster, bool use_resist_override);
mob:ResistSpell(int resist_type, int spell_id, Mob caster, bool use_resist_override, int resist_override);
mob:ResistSpell(int resist_type, int spell_id, Mob caster, bool use_resist_override, int resist_override, );
mob:RestoreEndurance();
mob:RestoreHealth();
mob:RestoreMana();
mob:ResumeTimer(string timer_name);
mob:RunTo(double x, double y, double z);
mob:Say(string message);
mob:Say(string message, uint8 language_id);
mob:SeeHide();
mob:SeeImprovedHide();
mob:SeeInvisible();
mob:SeeInvisibleUndead();
mob:SendAppearanceEffect(uint32 parm1, uint32 parm2, uint32 parm3, uint32 parm4, uint32 parm5, Client specific_target);
mob:SendAppearanceEffect(uint32 parm1, uint32 parm2, uint32 parm3, uint32 parm4, uint32 parm5);
mob:SendBeginCast(int spell_id, int cast_time);
mob:SendIllusionPacket(object illusion);
mob:SendPayload(int payload_id);
mob:SendPayload(int payload_id, string payload_value);
mob:SendSpellEffect(uint32 effect_id, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk020);
mob:SendSpellEffect(uint32 effect_id, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk020, bool perm_effect);
mob:SendSpellEffect(uint32 effect_id, uint32 duration, uint32 finish_delay, bool zone_wide, uint32 unk020, bool perm_effect, );
mob:SendTo(double x, double y, double z);
mob:SendToFixZ(double x, double y, double z);
mob:SendWearChange(uint8 material_slot);
mob:SetAA(int rank_id, int new_value);
mob:SetAA(int rank_id, int new_value, int charges);
mob:SetAllowBeneficial(bool value);
mob:SetAppearance(int app, bool ignore_self);
mob:SetAppearance(int app);
mob:SetBodyType(uint8 new_body, bool overwrite_orig);
mob:SetBucket(string bucket_name, string bucket_value);
mob:SetBucket(string bucket_name, string bucket_value, string expiration);
mob:SetBuffDuration(int spell_id, int duration, int level);
mob:SetBuffDuration(int spell_id);
mob:SetBuffDuration(int spell_id, int duration);
mob:SetCurrentWP(int wp);
mob:SetDestructibleObject(bool set);
mob:SetDisableMelee(bool disable);
mob:SetEntityVariable(string variable_name, string variable_value);
mob:SetExtraHaste(int haste, bool need_to_save);
mob:SetExtraHaste(int haste);
mob:SetFlurryChance(int value);
mob:SetFlyMode(int in);
mob:SetGender(uint8 gender_id);
mob:SetGlobal(string varname, string newvalue, int options, string duration, Mob other);
mob:SetGlobal(string varname, string newvalue, int options, string duration);
mob:SetHP(int64 hp);
mob:SetHate(Mob other, int64 hate, int64 damage);
mob:SetHate(Mob other, int64 hate);
mob:SetHate(Mob other);
mob:SetHeading(double in);
mob:SetInvisible(int state);
mob:SetInvul(bool value);
mob:SetLevel(int level, bool command);
mob:SetLevel(int level);
mob:SetMana(mana);
mob:SetOOCRegen(int64 new_ooc_regen);
mob:SetPet(Mob new_pet);
mob:SetPetOrder(int order);
mob:SetPseudoRoot(bool in);
mob:SetRace(uint16 race_id);
mob:SetRunning(bool running);
mob:SetSeeInvisibleLevel(uint8 invisible_level);
mob:SetSeeInvisibleUndeadLevel(uint8 invisible_level);
mob:SetSlotTint(int material_slot, int red_tint, int green_tint, int blue_tint);
mob:SetSpecialAbility(int ability, int level);
mob:SetSpecialAbilityParam(int ability, int param, int value);
mob:SetTarget(Mob t);
mob:SetTargetable(bool on);
mob:SetTexture(uint8 texture);
mob:SetTimer(string timer_name, int seconds);
mob:SetTimerMS(string timer_name, int milliseconds);
mob:Shout(string message, uint8 language_id);
mob:Shout(string message);
mob:Signal(int signal_id);
mob:SpellEffect(Mob caster, int spell_id, double partial);
mob:SpellFinished(int spell_id, Mob target, int slot, int mana_used);
mob:SpellFinished(int spell_id, Mob target, int slot);
mob:SpellFinished(int spell_id, Mob target);
mob:SpellFinished(int spell_id, Mob target, int slot, int mana_used, uint32 inventory_slot);
mob:SpellFinished(int spell_id, Mob target, int slot, int mana_used, uint32 inventory_slot, int resist_adjust);
mob:SpellFinished(int spell_id, Mob target, int slot, int mana_used, uint32 inventory_slot, int resist_adjust, proc);
mob:Spin();
mob:StopAllTimers();
mob:StopNavigation();
mob:StopTimer(string timer_name);
mob:Stun(int duration);
mob:TarGlobal(string varname, string value, string duration, int npc_id, int char_id, int zone_id);
mob:TempName(string newname);
mob:TempName();
mob:ThrowingAttack(Mob other);
mob:TryFinishingBlow(Mob defender, int64 &damage);
mob:TryMoveAlong(float distance, float angle, bool send);
mob:TryMoveAlong(float distance, float angle);
mob:UnStun();
mob:WalkTo(double x, double y, double z);
mob:WearChange(uint8 material_slot, uint32 texture, uint32 color);
mob:WearChange(uint8 material_slot, uint32 texture, uint32 color, uint32 heros_forge_model);
mob:WearChange(uint8 material_slot, uint32 texture);
mob:WipeHateList();
`
```

---

## MySQLPreparedStmt

*Source: quest-api/methods/mysqlpreparedstmt/index.html*

# MySQLPreparedStmt

Lua (6)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`mysqlpreparedstmt:close();
mysqlpreparedstmt:execute();
mysqlpreparedstmt:insert_id();
mysqlpreparedstmt:num_fields();
mysqlpreparedstmt:num_rows();
mysqlpreparedstmt:rows_affected();
`
```

---

## NPC

*Source: quest-api/methods/npc/index.html*

# NPC

Perl (147)Lua (157)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$npc->AI_SetRoambox(float distance, float max_x, float min_x, float max_y, float min_y);
$npc->AI_SetRoambox(float distance, float max_x, float min_x, float max_y, float min_y, uint32 max_delay);
$npc->AI_SetRoambox(float distance, float max_x, float min_x, float max_y, float min_y, uint32 max_delay, uint32 min_delay);
$npc->AddAISpellEffect(int spell_effect_id, int base_value, int limit_value, int max_value);
$npc->AddDefensiveProc(uint16_t spell_id, uint16_t chance);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1, uint32 aug2);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1, uint32 aug2, uint32 aug3);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6);
$npc->AddItem(uint32 item_id);
$npc->AddItem(uint32 item_id, uint16 charges);
$npc->AddItem(uint32 item_id, uint16 charges, bool equip_item, uint32 aug1);
$npc->AddLootTable(uint32 loottable_id);
$npc->AddLootTable();
$npc->AddMeleeProc(uint16_t spell_id, uint16_t chance);
$npc->AddRangedProc(uint16_t spell_id, uint16_t chance);
$npc->AssignWaypoints(uint32 grid_id);
$npc->CalculateNewWaypoint();
$npc->ChangeLastName(string name);
$npc->CheckNPCFactionAlly(int32 faction_id);
$npc->ClearLastName();
$npc->CountItem(uint32 item_id);
$npc->CountLoot();
$npc->DescribeSpecialAbilities(Client* c);
$npc->DisplayWaypointInfo(Client* client);
$npc->DoClassAttacks(Mob* target);
$npc->GetAccuracyRating();
$npc->GetAttackDelay();
$npc->GetAttackSpeed();
$npc->GetAvoidanceRating();
$npc->GetCombatState();
$npc->GetCopper();
$npc->GetGold();
$npc->GetGrid();
$npc->GetGuardPointX();
$npc->GetGuardPointY();
$npc->GetGuardPointZ();
$npc->GetHealScale();
$npc->GetKeepsSoldItems();
$npc->GetLDoNLockedSkill();
$npc->GetLDoNTrapSpellID();
$npc->GetLDoNTrapType();
$npc->GetLootList();
$npc->GetLoottableID();
$npc->GetMaxDMG();
$npc->GetMaxDamage(uint8 target_level);
$npc->GetMaxWp();
$npc->GetMinDMG();
$npc->GetNPCAggro();
$npc->GetNPCFactionID();
$npc->GetNPCHate(Mob* mob);
$npc->GetNPCSpellsEffectsID();
$npc->GetNPCSpellsID();
$npc->GetNPCStat(string stat);
$npc->GetPetSpellID();
$npc->GetPlatinum();
$npc->GetPrimSkill();
$npc->GetPrimaryFaction();
$npc->GetScore();
$npc->GetSecSkill();
$npc->GetSilver();
$npc->GetSlowMitigation();
$npc->GetSp2();
$npc->GetSpawnKillCount();
$npc->GetSpawnPointH();
$npc->GetSpawnPointID();
$npc->GetSpawnPointX();
$npc->GetSpawnPointY();
$npc->GetSpawnPointZ();
$npc->GetSpellFocusDMG();
$npc->GetSpellFocusHeal();
$npc->GetSpellScale();
$npc->GetSwarmOwner();
$npc->GetSwarmTarget();
$npc->GetWaypointMax();
$npc->HasAISpellEffect(int spell_effect_id);
$npc->HasItem(uint32 item_id);
$npc->HasSpecialAbilities();
$npc->IsAnimal();
$npc->IsGuarding();
$npc->IsLDoNLocked();
$npc->IsLDoNTrapped();
$npc->IsOnHatelist(Mob* mob);
$npc->IsRaidTarget();
$npc->IsRareSpawn();
$npc->IsTaunting();
$npc->IsUnderwaterOnly();
$npc->MerchantCloseShop();
$npc->MerchantOpenShop();
$npc->ModifyNPCStat(string stat, string value);
$npc->MoveTo(float x, float y, float z, float h, bool save);
$npc->MoveTo(float x, float y, float z);
$npc->MoveTo(float x, float y, float z, float h);
$npc->NextGuardPosition();
$npc->PauseWandering(int pause_time);
$npc->PickPocket(Client* thief);
$npc->RecalculateSkills();
$npc->ReloadSpells();
$npc->RemoveAISpellEffect(int spell_effect_id);
$npc->RemoveDefensiveProc(uint16_t spell_id);
$npc->RemoveFromHateList(Mob* mob);
$npc->RemoveItem(uint32 item_id);
$npc->RemoveItem(uint32 item_id, uint16 quantity);
$npc->RemoveItem(uint32 item_id, uint16 quantity, uint16 slot_id);
$npc->RemoveMeleeProc(uint16_t spell_id);
$npc->RemoveRangedProc(uint16_t spell_id);
$npc->ResumeWandering();
$npc->SaveGuardSpot(bool clear);
$npc->SaveGuardSpot();
$npc->SaveGuardSpot(float x, float y, float z, float heading);
$npc->ScaleNPC(uint8 npc_level);
$npc->ScaleNPC(uint8 npc_level, bool override_special_abilities);
$npc->SendPayload(int payload_id);
$npc->SendPayload(int payload_id, string payload_value);
$npc->SetCopper(uint32 amt);
$npc->SetGold(uint32 amt);
$npc->SetGrid(int grid);
$npc->SetKeepsSoldItems(bool keeps_sold_items);
$npc->SetLDoNLocked(bool is_locked);
$npc->SetLDoNLockedSkill(uint16 skill_value);
$npc->SetLDoNTrapDetected(bool is_detected);
$npc->SetLDoNTrapSpellID(uint16 spell_id);
$npc->SetLDoNTrapType(uint8 trap_type);
$npc->SetLDoNTrapped(bool is_trapped);
$npc->SetNPCAggro(bool in_npc_aggro);
$npc->SetNPCFactionID(int faction_id);
$npc->SetPetSpellID(uint16 amount);
$npc->SetPlatinum(uint32 amt);
$npc->SetPrimSkill(int skill_id);
$npc->SetSaveWaypoint(uint16 wp);
$npc->SetSecSkill(int skill_id);
$npc->SetSilver(uint32 amt);
$npc->SetSimpleRoamBox(float box_size);
$npc->SetSimpleRoamBox(float box_size, float move_distance, int move_delay);
$npc->SetSimpleRoamBox(float box_size, float move_distance);
$npc->SetSp2(uint32 set_spawn_group_id);
$npc->SetSpellFocusDMG(int new_spell_focus_dmg);
$npc->SetSpellFocusHeal(int new_spell_focus_heal);
$npc->SetSwarmTarget(int target_id);
$npc->SetTaunting(bool on);
$npc->SetWaypointPause();
$npc->SignalNPC(int signal_id);
$npc->StartSwarmTimer(uint32 duration);
$npc->StopWandering();
$npc->UpdateWaypoint(int wp_index);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`npc:AI_SetRoambox(float dist, float max_x, float min_x, float max_y, float min_y, uint32 delay, uint32 mindelay);
npc:AI_SetRoambox(float dist, float max_x, float min_x, float max_y, float min_y);
npc:AddAISpell(int priority, int spell_id, int type, int mana_cost, int recast_delay, int resist_adjust, int min_hp, int max_hp);
npc:AddAISpell(int priority, int spell_id, int type, int mana_cost, int recast_delay, int resist_adjust);
npc:AddAISpellEffect(int spell_effect_id, int base_value, int limit_value, int max_value);
npc:AddCash(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
npc:AddItem(int item_id, int charges, bool equip, int aug1, int aug2, int aug3);
npc:AddItem(int item_id, int charges, bool equip, int aug1, int aug2, int aug3, int aug4, int aug5);
npc:AddItem(int item_id, int charges, bool equip, int aug1);
npc:AddItem(int item_id, int charges, bool equip, int aug1, int aug2, int aug3, int aug4, int aug5, int aug6);
npc:AddItem(int item_id, int charges);
npc:AddItem(int item_id, int charges, bool equip);
npc:AddItem(int item_id, int charges, bool equip, int aug1, int aug2);
npc:AddItem(int item_id, int charges, bool equip, int aug1, int aug2, int aug3, int aug4);
npc:AddLootTable();
npc:AddLootTable(int id);
npc:AssignWaypoints(int grid);
npc:CalculateNewWaypoint();
npc:ChangeLastName(string last_name);
npc:CheckNPCFactionAlly(faction);
npc:ClearItemList();
npc:ClearLastName();
npc:CountItem(uint32 item_id);
npc:CountLoot();
npc:DeleteBucket(string bucket_name);
npc:DescribeSpecialAbilities(Client c);
npc:DisplayWaypointInfo(Client client);
npc:DoClassAttacks(Mob target);
npc:GetAccuracyRating();
npc:GetAttackDelay();
npc:GetAttackSpeed();
npc:GetAvoidanceRating();
npc:GetBucket(bucket_name);
npc:GetBucketExpires(bucket_name);
npc:GetBucketRemaining(bucket_name);
npc:GetCopper();
npc:GetFirstSlotByItemID(uint32 item_id);
npc:GetFollowCanRun();
npc:GetFollowDistance();
npc:GetFollowID();
npc:GetGold();
npc:GetGrid();
npc:GetGuardPointX();
npc:GetGuardPointY();
npc:GetGuardPointZ();
npc:GetHealScale();
npc:GetItemIDBySlot(uint16 loot_slot);
npc:GetKeepsSoldItems();
npc:GetLDoNLockedSkill();
npc:GetLDoNTrapSpellID();
npc:GetLDoNTrapType();
npc:GetLootList();
npc:GetLoottableID();
npc:GetMaxDMG();
npc:GetMaxDamage(int level);
npc:GetMaxWp();
npc:GetMinDMG();
npc:GetNPCAggro();
npc:GetNPCFactionID();
npc:GetNPCHate(Mob ent);
npc:GetNPCSpellsEffectsID();
npc:GetNPCSpellsID();
npc:GetNPCStat(string stat);
npc:GetPetSpellID();
npc:GetPlatinum();
npc:GetPrimSkill();
npc:GetPrimaryFaction();
npc:GetRawAC();
npc:GetScore();
npc:GetSecSkill();
npc:GetSilver();
npc:GetSlowMitigation();
npc:GetSp2();
npc:GetSpawnKillCount();
npc:GetSpawnPointH();
npc:GetSpawnPointID();
npc:GetSpawnPointX();
npc:GetSpawnPointY();
npc:GetSpawnPointZ();
npc:GetSpellFocusDMG();
npc:GetSpellFocusHeal();
npc:GetSpellScale();
npc:GetSwarmOwner();
npc:GetSwarmTarget();
npc:GetWaypointMax();
npc:HasAISpellEffect(int spell_effect_id);
npc:HasItem(uint32 item_id);
npc:HasSpecialAbilities();
npc:IsAnimal();
npc:IsGuarding();
npc:IsLDoNLocked();
npc:IsLDoNTrapDetected();
npc:IsLDoNTrapped();
npc:IsOnHatelist(Mob ent);
npc:IsRaidTarget();
npc:IsRareSpawn();
npc:IsTaunting();
npc:IsUnderwaterOnly();
npc:MerchantCloseShop();
npc:MerchantOpenShop();
npc:ModifyNPCStat(string stat, string value);
npc:MoveTo(float x, float y, float z, float h, bool save);
npc:NextGuardPosition();
npc:PauseWandering(int pause_time);
npc:PickPocket(Client thief);
npc:RecalculateSkills();
npc:ReloadSpells();
npc:RemoveAISpell(int spell_id);
npc:RemoveAISpellEffect(int spell_effect_id);
npc:RemoveCash();
npc:RemoveItem(int item_id, int quantity);
npc:RemoveItem(int item_id, int quantity, int slot);
npc:RemoveItem(int item_id);
npc:ResumeWandering();
npc:SaveGuardSpot(bool clear);
npc:SaveGuardSpot();
npc:SaveGuardSpot(float x, float y, float z, float heading);
npc:ScaleNPC(uint8 npc_level, bool override_special_abilities);
npc:ScaleNPC(uint8 npc_level);
npc:SendPayload(int payload_id);
npc:SendPayload(int payload_id, string payload_value);
npc:SetBucket(string bucket_name, string bucket_value, string expiration);
npc:SetBucket(string bucket_name, string bucket_value);
npc:SetCopper(uint32 amt);
npc:SetFollowCanRun(bool v);
npc:SetFollowDistance(int dist);
npc:SetFollowID(int id);
npc:SetGold(uint32 amt);
npc:SetGrid(int grid);
npc:SetKeepsSoldItems(bool keeps_sold_items);
npc:SetLDoNLocked(bool is_locked);
npc:SetLDoNLockedSkill(uint16 skill_value);
npc:SetLDoNTrapDetected(bool is_detected);
npc:SetLDoNTrapSpellID(uint16 spell_id);
npc:SetLDoNTrapType(uint8 trap_type);
npc:SetLDoNTrapped(bool is_trapped);
npc:SetNPCAggro(bool in_npc_aggro);
npc:SetNPCFactionID(int id);
npc:SetPetSpellID(int id);
npc:SetPlatinum(uint32 amt);
npc:SetPrimSkill(int skill_id);
npc:SetSaveWaypoint(int wp);
npc:SetSecSkill(int skill_id);
npc:SetSilver(uint32 amt);
npc:SetSimpleRoamBox(float box_size, float move_distance, int move_delay);
npc:SetSimpleRoamBox(float box_size, float move_distance);
npc:SetSimpleRoamBox(float box_size);
npc:SetSp2(int sg2);
npc:SetSpellFocusDMG(int focus);
npc:SetSpellFocusHeal(int focus);
npc:SetSwarmTarget(int target);
npc:SetTaunting(bool t);
npc:SetWaypointPause();
npc:Signal(int signal_id);
npc:StartSwarmTimer(uint32 duration);
npc:StopWandering();
npc:UpdateWaypoint(int wp);
`
```

---

## Object

*Source: quest-api/methods/object/index.html*

# Object

Perl (46)Lua (37)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$object->ClearEntityVariables();
$object->ClearUser();
$object->Close();
$object->Delete();
$object->Delete(bool reset_state);
$object->DeleteEntityVariable(string variable_name);
$object->DeleteItem(uint8_t index);
$object->Depop();
$object->EntityVariableExists(string variable_name);
$object->GetDBID();
$object->GetEntityVariable(variable_name);
$object->GetEntityVariables();
$object->GetHeading();
$object->GetID();
$object->GetIcon();
$object->GetItemID();
$object->GetModelName();
$object->GetSize();
$object->GetSolidType();
$object->GetTiltX();
$object->GetTiltY();
$object->GetType();
$object->GetX();
$object->GetY();
$object->GetZ();
$object->IsGroundSpawn();
$object->IsObject();
$object->Repop();
$object->Save();
$object->SetEntityVariable(string variable_name, string variable_value);
$object->SetHeading(float heading);
$object->SetID(uint16_t set_id);
$object->SetIcon(uint32_t icon);
$object->SetItemID(uint32_t itemid);
$object->SetLocation(float x, float y, float z);
$object->SetModelName(string name);
$object->SetSize(float size);
$object->SetSolidType(uint16_t type);
$object->SetTiltX(float tilt_x);
$object->SetTiltY(float tilt_y);
$object->SetType(uint32_t type);
$object->SetX(float x);
$object->SetY(float y);
$object->SetZ(float z);
$object->StartDecay();
$object->VarSave();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`object:ClearEntityVariables();
object:ClearUser();
object:Close();
object:Delete();
object:Delete(bool reset_state);
object:DeleteEntityVariable(string variable_name);
object:DeleteItem(int index);
object:Depop();
object:EntityVariableExists(string variable_name);
object:GetDBID();
object:GetEntityVariable(variable_name);
object:GetEntityVariables();
object:GetHeading();
object:GetID();
object:GetIcon();
object:GetItemID();
object:GetModelName();
object:GetType();
object:GetX();
object:GetY();
object:GetZ();
object:IsGroundSpawn();
object:Repop();
object:Save();
object:SetEntityVariable(string variable_name, string variable_value);
object:SetHeading(float h);
object:SetID(int user);
object:SetIcon(uint32 icon);
object:SetItemID(uint32 item_id);
object:SetLocation(float x, float y, float z);
object:SetModelName(string name);
object:SetType(uint32 type);
object:SetX(float x);
object:SetY(float y);
object:SetZ(float z);
object:StartDecay();
object:VarSave();
`
```

---

## Packet

*Source: quest-api/methods/packet/index.html*

# Packet

Lua (33)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`packet:GetOpcode();
packet:GetProtocolOpcode();
packet:GetRawOpcode();
packet:GetSize();
packet:GetWritePosition();
packet:ReadDouble(int offset);
packet:ReadFixedLengthString(int offset, int string_length);
packet:ReadFloat(int offset);
packet:ReadInt16(offset);
packet:ReadInt32(offset);
packet:ReadInt64(int offset);
packet:ReadInt8(offset);
packet:ReadString(int offset);
packet:SetOpcode(int op);
packet:SetRawOpcode(int op);
packet:SetWritePosition(int offset);
packet:WriteDouble(double value);
packet:WriteDouble(int offset, double value);
packet:WriteFixedLengthString(int offset, string value, int string_length);
packet:WriteFixedLengthString(string value);
packet:WriteFloat(float value);
packet:WriteFloat(int offset, float value);
packet:WriteInt16(int value);
packet:WriteInt16(int offset, int value);
packet:WriteInt32(int offset, int value);
packet:WriteInt32(int value);
packet:WriteInt64(int offset, int64 value);
packet:WriteInt64(int64 value);
packet:WriteInt8(int offset, int value);
packet:WriteInt8(int value);
packet:WriteString(int offset, string value);
packet:WriteString(string value);
packet:operator=(const o);
`
```

---

## PerlPacket

*Source: quest-api/methods/perlpacket/index.html*

# PerlPacket

Perl (21)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$perlpacket->DESTROY();
$perlpacket->FromArray(reference avref, uint32_t length);
$perlpacket->GetByte(uint32_t pos);
$perlpacket->GetFloat(uint32_t pos);
$perlpacket->GetLong(pos);
$perlpacket->GetShort(uint32_t pos);
$perlpacket->Resize(uint32_t len);
$perlpacket->SendTo(Client* who);
$perlpacket->SendToAll();
$perlpacket->SetByte(uint32_t pos, uint8_t val);
$perlpacket->SetEQ1319(uint32_t pos, float part13, float part19);
$perlpacket->SetEQ1913(uint32_t pos, float part19, float part13);
$perlpacket->SetFloat(uint32_t pos, float val);
$perlpacket->SetLong(uint32_t pos, uint32_t val);
$perlpacket->SetOpcode(string opcode);
$perlpacket->SetShort(uint32_t pos, uint16_t val);
$perlpacket->SetString(uint32_t pos, char* str);
$perlpacket->Zero();
$perlpacket->new(string class_name);
$perlpacket->new(string class_name, string opcode, uint32_t len);
$perlpacket->new(string class_name, string opcode);
`
```

---

## quest

*Source: quest-api/methods/quest/index.html*

# quest

Perl (989)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`quest::AssignGroupToInstance(uint16 instance_id);
quest::AssignRaidToInstance(uint16 instance_id);
quest::AssignToInstance(uint16 instance_id);
quest::AssignToInstanceByCharID(uint16 instance_id, uint32 character_id);
quest::CalculateCorruptionCounters(uint16 spell_id);
quest::CalculateCounters(uint16 spell_id);
quest::CalculateCurseCounters(uint16 spell_id);
quest::CalculateDiseaseCounters(uint16 spell_id);
quest::CalculatePoisonCounters(uint16 spell_id);
quest::CheckInstanceByCharID(uint16 instance_id, uint32 character_id);
quest::ChooseRandom(array options);
quest::CreateInstance(string zone_name, int16 version, int32 duration);
quest::DestroyInstance(uint16 id);
quest::FlagInstanceByGroupLeader(uint32 zone, uint16 version);
quest::FlagInstanceByRaidLeader(uint32 zone, uint16 version);
quest::FlyMode(GravityBehavior flymode);
quest::GetAutoLoginCharacterNameByAccountID(uint32 account_id);
quest::GetBotClassByID(uint32 bot_id);
quest::GetBotGenderByID(uint32 bot_id);
quest::GetBotIDsByCharacterID(uint32 character_id, uint8 class_id);
quest::GetBotIDsByCharacterID(uint32 character_id);
quest::GetBotLevelByID(uint32 bot_id);
quest::GetBotNameByID(uint32 bot_id);
quest::GetBotRaceByID(uint32 bot_id);
quest::GetCharactersInInstance(uint16 instance_id);
quest::GetInstanceID(string zone_name, uint16 version);
quest::GetInstanceIDByCharID(string zone_name, int16 version, uint32 character_id);
quest::GetInstanceIDs(string zone_name);
quest::GetInstanceIDsByCharID(string zone_name, uint32 character_id);
quest::GetInstanceTimer();
quest::GetInstanceTimerByID(uint16 instance_id);
quest::GetInstanceVersionByID(uint16 instance_id);
quest::GetInstanceZoneIDByID(uint16 instance_id);
quest::GetSpellEffectDescriptionNumber(uint16 spell_id);
quest::GetSpellEffectIndex(uint16 spell_id, effect_id);
quest::GetSpellFuriousBash(uint16 spell_id);
quest::GetSpellMinimumLevel(uint16 spell_id);
quest::GetSpellNimbusEffect(uint16 spell_id);
quest::GetSpellPartialMagicRuneAmount(uint16 spell_id);
quest::GetSpellPartialMagicRuneReduction(uint16 spell_id);
quest::GetSpellPartialMeleeRuneAmount(uint16 spell_id);
quest::GetSpellPartialMeleeRuneReduction(uint16 spell_id);
quest::GetSpellProcLimitTimer(uint16 spell_id, proc_type);
quest::GetSpellResistType(uint16 spell_id);
quest::GetSpellResurrectionSicknessCheck(uint16 spell_id_one, uint16 spell_id_two);
quest::GetSpellTargetType(uint16 spell_id);
quest::GetSpellTriggerSpellID(spell_id, int effect_id);
quest::GetSpellViralMaximumSpreadTime(uint16 spell_id);
quest::GetSpellViralMinimumSpreadTime(uint16 spell_id);
quest::GetSpellViralSpreadRange(uint16 spell_id);
quest::GetTimeSeconds();
quest::GetZoneBypassExpansionCheck(uint32 zone_id);
quest::GetZoneBypassExpansionCheck(uint32 zone_id, int version);
quest::GetZoneCanBind(uint32 zone_id, int version);
quest::GetZoneCanBind(uint32 zone_id);
quest::GetZoneCanCombat(uint32 zone_id);
quest::GetZoneCanCombat(uint32 zone_id, int version);
quest::GetZoneCanLevitate(uint32 zone_id);
quest::GetZoneCanLevitate(uint32 zone_id, int version);
quest::GetZoneCastOutdoor(uint32 zone_id, int version);
quest::GetZoneCastOutdoor(uint32 zone_id);
quest::GetZoneContentFlags(uint32 zone_id);
quest::GetZoneContentFlags(uint32 zone_id, int version);
quest::GetZoneContentFlagsDisabled(uint32 zone_id, int version);
quest::GetZoneContentFlagsDisabled(uint32 zone_id);
quest::GetZoneExpansion(uint32 zone_id);
quest::GetZoneExpansion(uint32 zone_id, int version);
quest::GetZoneExperienceMultiplier(uint32 zone_id, int version);
quest::GetZoneExperienceMultiplier(uint32 zone_id);
quest::GetZoneFastRegenEndurance(uint32 zone_id, version);
quest::GetZoneFastRegenEndurance(uint32 zone_id);
quest::GetZoneFastRegenHP(uint32 zone_id, version);
quest::GetZoneFastRegenHP(uint32 zone_id);
quest::GetZoneFastRegenMana(uint32 zone_id);
quest::GetZoneFastRegenMana(uint32 zone_id, version);
quest::GetZoneFlagNeeded(uint32 zone_id);
quest::GetZoneFlagNeeded(uint32 zone_id, int version);
quest::GetZoneFogBlue(uint32 zone_id, slot, int version);
quest::GetZoneFogBlue(uint32 zone_id, slot);
quest::GetZoneFogBlue(uint32 zone_id);
quest::GetZoneFogDensity(uint32 zone_id);
quest::GetZoneFogDensity(uint32 zone_id, int version);
quest::GetZoneFogGreen(uint32 zone_id);
quest::GetZoneFogGreen(uint32 zone_id, slot, int version);
quest::GetZoneFogGreen(uint32 zone_id, slot);
quest::GetZoneFogMaximumClip(uint32 zone_id, uint8 slot, int version);
quest::GetZoneFogMaximumClip(uint32 zone_id);
quest::GetZoneFogMaximumClip(uint32 zone_id, uint8 slot);
quest::GetZoneFogMinimumClip(uint32 zone_id, uint8 slot, int version);
quest::GetZoneFogMinimumClip(uint32 zone_id, uint8 slot);
quest::GetZoneFogMinimumClip(uint32 zone_id);
quest::GetZoneFogRed(uint32 zone_id);
quest::GetZoneFogRed(uint32 zone_id, slot);
quest::GetZoneFogRed(uint32 zone_id, slot, int version);
quest::GetZoneGraveyardID(uint32 zone_id, int version);
quest::GetZoneGraveyardID(uint32 zone_id);
quest::GetZoneGravity(uint32 zone_id, int version);
quest::GetZoneGravity(uint32 zone_id);
quest::GetZoneHotzone(uint32 zone_id);
quest::GetZoneHotzone(uint32 zone_id, int version);
quest::GetZoneID(string zone);
quest::GetZoneIDByLongName(string zone_long_name);
quest::GetZoneIdleWhenEmpty(uint32 zone_id, int version);
quest::GetZoneIdleWhenEmpty(uint32 zone_id);
quest::GetZoneInstanceType(uint32 zone_id, int version);
quest::GetZoneInstanceType(uint32 zone_id);
quest::GetZoneLavaDamage(uint32 zone_id, version);
quest::GetZoneLavaDamage(uint32 zone_id);
quest::GetZoneLongName(zone);
quest::GetZoneLongNameByID(uint32 zone_id);
quest::GetZoneMaximumClip(uint32 zone_id);
quest::GetZoneMaximumClip(uint32 zone_id, int version);
quest::GetZoneMaximumExpansion(uint32 zone_id);
quest::GetZoneMaximumExpansion(uint32 zone_id, int version);
quest::GetZoneMaximumLevel(uint32 zone_id, int version);
quest::GetZoneMaximumLevel(uint32 zone_id);
quest::GetZoneMaximumMovementUpdateRange(zone_id, int version);
quest::GetZoneMaximumMovementUpdateRange(zone_id);
quest::GetZoneMaximumPlayers(uint32 zone_id, version);
quest::GetZoneMaximumPlayers(uint32 zone_id);
quest::GetZoneMinimumClip(uint32 zone_id, int version);
quest::GetZoneMinimumClip(uint32 zone_id);
quest::GetZoneMinimumExpansion(uint32 zone_id);
quest::GetZoneMinimumExpansion(uint32 zone_id, int version);
quest::GetZoneMinimumLavaDamage(uint32 zone_id);
quest::GetZoneMinimumLavaDamage(uint32 zone_id, version);
quest::GetZoneMinimumLevel(uint32 zone_id, int version);
quest::GetZoneMinimumLevel(uint32 zone_id);
quest::GetZoneMinimumStatus(uint32 zone_id, int version);
quest::GetZoneMinimumStatus(uint32 zone_id);
quest::GetZoneNPCMaximumAggroDistance(uint32 zone_id);
quest::GetZoneNPCMaximumAggroDistance(uint32 zone_id, version);
quest::GetZoneNote(uint32 zone_id);
quest::GetZoneNote(uint32 zone_id, int version);
quest::GetZonePEQZone(uint32 zone_id, int version);
quest::GetZonePEQZone(uint32 zone_id);
quest::GetZoneRainChance(uint32 zone_id, uint8 slot);
quest::GetZoneRainChance(uint32 zone_id);
quest::GetZoneRainChance(uint32 zone_id, uint8 slot, version);
quest::GetZoneRainDuration(uint32 zone_id, uint8 slot);
quest::GetZoneRainDuration(uint32 zone_id);
quest::GetZoneRainDuration(uint32 zone_id, uint8 slot, version);
quest::GetZoneRuleSet(zone_id);
quest::GetZoneRuleSet(zone_id, int version);
quest::GetZoneSafeHeading(uint32 zone_id);
quest::GetZoneSafeHeading(uint32 zone_id, int version);
quest::GetZoneSafeX(uint32 zone_id, int version);
quest::GetZoneSafeX(uint32 zone_id);
quest::GetZoneSafeY(uint32 zone_id, int version);
quest::GetZoneSafeY(uint32 zone_id);
quest::GetZoneSafeZ(uint32 zone_id, int version);
quest::GetZoneSafeZ(uint32 zone_id);
quest::GetZoneSecondsBeforeIdle(zone_id);
quest::GetZoneSecondsBeforeIdle(zone_id, int version);
quest::GetZoneShortName(uint32 zone_id);
quest::GetZoneShortNameByLongName(zone_long_name);
quest::GetZoneShutdownDelay(uint32 zone_id);
quest::GetZoneShutdownDelay(uint32 zone_id, int version);
quest::GetZoneSky(uint32 zone_id, int version);
quest::GetZoneSky(uint32 zone_id);
quest::GetZoneSkyLock(uint32 zone_id, int version);
quest::GetZoneSkyLock(uint32 zone_id);
quest::GetZoneSnowChance(uint32 zone_id);
quest::GetZoneSnowChance(uint32 zone_id, uint8 slot, version);
quest::GetZoneSnowChance(uint32 zone_id, uint8 slot);
quest::GetZoneSnowDuration(uint32 zone_id, uint8 slot);
quest::GetZoneSnowDuration(uint32 zone_id, uint8 slot, version);
quest::GetZoneSnowDuration(uint32 zone_id);
quest::GetZoneSuspendBuffs(uint32 zone_id);
quest::GetZoneSuspendBuffs(uint32 zone_id, int version);
quest::GetZoneTimeType(uint32 zone_id);
quest::GetZoneTimeType(uint32 zone_id, int version);
quest::GetZoneTimeZone(uint32 zone_id);
quest::GetZoneTimeZone(uint32 zone_id, version);
quest::GetZoneType(uint32 zone_id, version);
quest::GetZoneType(uint32 zone_id);
quest::GetZoneUnderworld(uint32 zone_id);
quest::GetZoneUnderworld(uint32 zone_id, int version);
quest::GetZoneUnderworldTeleportIndex(uint32 zone_id);
quest::GetZoneUnderworldTeleportIndex(uint32 zone_id, version);
quest::GetZoneWalkSpeed(uint32 zone_id);
quest::GetZoneWalkSpeed(uint32 zone_id, int version);
quest::GetZoneZType(uint32 zone_id, int version);
quest::GetZoneZType(uint32 zone_id);
quest::IsAEDurationSpell(uint16 spell_id);
quest::IsAENukeSpell(uint16 spell_id);
quest::IsAERainNukeSpell(uint16 spell_id);
quest::IsAllianceSpell(uint16 spell_id);
quest::IsBardOnlyStackEffect(int effect_id);
quest::IsBardSong(uint16 spell_id);
quest::IsBeneficialSpell(uint16 spell_id);
quest::IsBlankSpellEffect(uint16 spell_id, int effect_index);
quest::IsBlindSpell(uint16 spell_id);
quest::IsBuffSpell(uint16 spell_id);
quest::IsCastNotStandingSpell(uint16 spell_id);
quest::IsCastOnFadeDurationSpell(uint16 spell_id);
quest::IsCastRestrictedSpell(uint16 spell_id);
quest::IsCastTimeReductionSpell(uint16 spell_id);
quest::IsCastWhileInvisibleSpell(uint16 spell_id);
quest::IsCharmSpell(uint16 spell_id);
quest::IsCombatSkill(uint16 spell_id);
quest::IsCompleteHealDurationSpell(uint16 spell_id);
quest::IsCompleteHealSpell(uint16 spell_id);
quest::IsCureSpell(uint16 spell_id);
quest::IsDamageSpell(uint16 spell_id);
quest::IsDeathSaveSpell(uint16 spell_id);
quest::IsDebuffSpell(uint16 spell_id);
quest::IsDetrimentalSpell(uint16 spell_id);
quest::IsDiscipline(uint16 spell_id);
quest::IsDisciplineBuff(uint16 spell_id);
quest::IsDiseaseCounterSpell(uint16 spell_id);
quest::IsDistanceModifierSpell(uint16 spell_id);
quest::IsEffectIgnoredInStacking(int effect_id);
quest::IsEffectInSpell(uint16 spell_id, int effect_id);
quest::IsFastHealSpell(uint16 spell_id);
quest::IsFearSpell(uint16 spell_id);
quest::IsFocusLimit(int effect_id);
quest::IsFullDeathSaveSpell(uint16 spell_id);
quest::IsGateSpell(uint16 spell_id);
quest::IsGroupCompleteHealSpell(uint16 spell_id);
quest::IsGroupHealOverTimeSpell(uint16 spell_id);
quest::IsGroupOnlySpell(uint16 spell_id);
quest::IsGroupSpell(uint16 spell_id);
quest::IsHarmonySpell(uint16 spell_id);
quest::IsHasteSpell(uint16 spell_id);
quest::IsHealOverTimeSpell(uint16 spell_id);
quest::IsHealthSpell(uint16 spell_id);
quest::IsIllusionSpell(uint16 spell_id);
quest::IsImprovedDamageSpell(uint16 spell_id);
quest::IsImprovedHealingSpell(uint16 spell_id);
quest::IsIncreaseDurationSpell(uint16 spell_id);
quest::IsIncreaseRangeSpell(uint16 spell_id);
quest::IsInstrumentModifierAppliedToSpellEffect(uint16 spell_id, int effect_id);
quest::IsInvisibleSpell(uint16 spell_id);
quest::IsInvulnerabilitySpell(uint16 spell_id);
quest::IsLDoNObjectSpell(uint16 spell_id);
quest::IsLifetapSpell(uint16 spell_id);
quest::IsMagicRuneSpell(uint16 spell_id);
quest::IsManaCostReductionSpell(uint16 spell_id);
quest::IsManaTapSpell(uint16 spell_id);
quest::IsMesmerizeSpell(uint16 spell_id);
quest::IsNoDetrimentalSpellAggroSpell(uint16 spell_id);
quest::IsPBAENukeSpell(uint16 spell_id);
quest::IsPartialDeathSaveSpell(uint16 spell_id);
quest::IsPartialResistableSpell(uint16 spell_id);
quest::IsPercentalHealSpell(uint16 spell_id);
quest::IsPersistDeathSpell(uint16 spell_id);
quest::IsPetSpell(uint16 spell_id);
quest::IsPoisonCounterSpell(uint16 spell_id);
quest::IsPulsingBardSong(uint16 spell_id);
quest::IsPureNukeSpell(uint16 spell_id);
quest::IsRaining();
quest::IsRegularGroupHealSpell(uint16 spell_id);
quest::IsRegularSingleTargetHealSpell(uint16 spell_id);
quest::IsResistDebuffSpell(uint16 spell_id);
quest::IsResistableSpell(uint16 spell_id);
quest::IsRestAllowedSpell(uint16 spell_id);
quest::IsResurrectionEffects(uint16 spell_id);
quest::IsRuneSpell(uint16 spell_id);
quest::IsRunning();
quest::IsSacrificeSpell(uint16 spell_id);
quest::IsSelfConversionSpell(uint16 spell_id);
quest::IsShadowStepSpell(uint16 spell_id);
quest::IsShortDurationBuff(uint16 spell_id);
quest::IsSnowing();
quest::IsSpellUsableInThisZoneType(uint16 spell_id, uint8 zone_type);
quest::IsSpellUsableInThisZoneType(uint16 spell_id);
quest::IsStackableDOT(uint16 spell_id);
quest::IsStunSpell(uint16 spell_id);
quest::IsSuccorSpell(uint16 spell_id);
quest::IsSummonItemSpell(uint16 spell_id);
quest::IsSummonPCSpell(uint16 spell_id);
quest::IsSummonPetSpell(uint16 spell_id);
quest::IsSummonSkeletonSpell(uint16 spell_id);
quest::IsSummonSpell(uint16 spell_id);
quest::IsSuspendableSpell(uint16 spell_id);
quest::IsTGBCompatibleSpell(uint16 spell_id);
quest::IsTargetRequiredForSpell(uint16 spell_id);
quest::IsTargetableAESpell(uint16 spell_id);
quest::IsTeleportSpell(uint16 spell_id);
quest::IsTranslocateSpell(uint16 spell_id);
quest::IsValidSpell(uint16 spell_id);
quest::IsVeryFastHealSpell(uint16 spell_id);
quest::IsVirusSpell(uint16 spell_id);
quest::LearnRecipe(int recipe_id);
quest::MerchantCountItem(uint32 npc_id, uint32 item_id);
quest::MerchantSetItem(uint32 npc_id, uint32 item_id);
quest::MerchantSetItem(uint32 npc_id, uint32 item_id, uint32 quantity);
quest::MovePCInstance(int zone_id, int instance_id, float x, float y, float z, float heading);
quest::MovePCInstance(int zone_id, int instance_id, float x, float y, float z);
quest::RemoveAllFromInstance(uint16 instance_id);
quest::RemoveFromInstance(uint16 instance_id);
quest::RemoveFromInstanceByCharID(uint16 instance_id, uint32 character_id);
quest::SendMail(string to, string from, string subject, string message);
quest::SetAutoLoginCharacterNameByAccountID(uint32 account_id, string character_name);
quest::SetRunning(bool is_running);
quest::SpawnCircle(uint32 npc_id, float x, float y, float z, float heading, float radius, uint32 points);
quest::SpawnGrid(uint32 npc_id, float x, float y, float z, float heading, float spacing, uint32 spawn_count);
quest::UpdateInstanceTimer(int16 instance_id, uint32 duration);
quest::UpdateZoneHeader(string key, string value);
quest::activespeakactivity(task_id);
quest::activespeaktask();
quest::activetasksinset(task_set);
quest::add_expedition_lockout_all_clients(string expedition_name, string event_name, uint32 seconds, string uuid);
quest::add_expedition_lockout_all_clients(string expedition_name, string event_name, uint32 seconds);
quest::add_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name, uint32 seconds, string uuid);
quest::add_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name, uint32 seconds);
quest::addldonloss(uint32 theme_id);
quest::addldonpoints(uint32 theme_id, int points);
quest::addldonwin(uint32 theme_id);
quest::addloot(int item_id);
quest::addloot(int item_id, int charges);
quest::addloot(int item_id, int charges, bool equip_item);
quest::addskill(int skill_id, int value);
quest::aretaskscompleted(array task_ids);
quest::assigntask(int task_id, bool enforce_level_requirement);
quest::assigntask(int task_id);
quest::attack(string client_name);
quest::attacknpc(int npc_entity_id);
quest::attacknpctype(int npc_type_id);
quest::botquest();
quest::buryplayercorpse(uint32 char_id);
quest::castspell(uint16 spell_id, uint16 target_id);
quest::changedeity(uint32 deity_id);
quest::checknamefilter(string name);
quest::checktitle(int title_set);
quest::clear_npctype_cache(int npc_type_id);
quest::clear_proximity();
quest::clear_zone_flag(int zone_id);
quest::clearspawntimers();
quest::collectitems(uint32_t item_id, bool remove_item);
quest::commify(scalar number);
quest::completedtasksinset(task_set);
quest::convert_money_to_string(hash table);
quest::countitem(uint32_t item_id);
quest::countspawnednpcs(array npc_id_array);
quest::createBot(string firstname, string lastname, int level, int race_id, int class_id, int gender_id);
quest::createbotcount();
quest::createbotcount(uint8 class_id);
quest::createdoor(string modelname, float x, float y, float z, float heading, uint8_t object_type, uint16_t size);
quest::createdoor(string modelname, float x, float y, float z, float heading, uint8_t object_type);
quest::createdoor(string modelname, float x, float y, float z, float heading);
quest::creategroundobject(uint32_t item_id, float x, float y, float z, float heading, uint32_t decay_time_ms);
quest::creategroundobject(uint32_t item_id, float x, float y, float z, float heading);
quest::creategroundobjectfrommodel(string modelname, float x, float y, float z, float heading);
quest::creategroundobjectfrommodel(string modelname, float x, float y, float z, float heading, uint8_t object_type);
quest::creategroundobjectfrommodel(string modelname, float x, float y, float z, float heading, uint8_t object_type, uint32_t decay_time_ms);
quest::createguild(string guild_name, string leader_name);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four, uint32 augment_five);
quest::createitem(uint32 item_id, int16 charges);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four, uint32 augment_five, uint32 augment_six, bool attuned);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four, uint32 augment_five, uint32 augment_six);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two, uint32 augment_three, uint32 augment_four);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two, uint32 augment_three);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one, uint32 augment_two);
quest::createitem(uint32 item_id, int16 charges, uint32 augment_one);
quest::createitem(uint32 item_id);
quest::crosszoneaddldonlossbycharid(int character_id, uint32 theme_id);
quest::crosszoneaddldonlossbyclientname(string client_name, uint32 theme_id);
quest::crosszoneaddldonlossbyexpeditionid(uint32 expedition_id, uint32 theme_id);
quest::crosszoneaddldonlossbygroupid(int group_id, uint32 theme_id);
quest::crosszoneaddldonlossbyguildid(int guild_id, uint32 theme_id);
quest::crosszoneaddldonlossbyraidid(int raid_id, uint32 theme_id);
quest::crosszoneaddldonpointsbycharid(int character_id, uint32 theme_id, int points);
quest::crosszoneaddldonpointsbyclientname(string client_name, uint32 theme_id, int points);
quest::crosszoneaddldonpointsbyexpeditionid(uint32 expedition_id, uint32 theme_id, int points);
quest::crosszoneaddldonpointsbygroupid(int group_id, uint32 theme_id, int points);
quest::crosszoneaddldonpointsbyguildid(int guild_id, uint32 theme_id, int points);
quest::crosszoneaddldonpointsbyraidid(int raid_id, uint32 theme_id, int points);
quest::crosszoneaddldonwinbycharid(int character_id, uint32 theme_id);
quest::crosszoneaddldonwinbyclientname(string client_name, uint32 theme_id);
quest::crosszoneaddldonwinbyexpeditionid(uint32 expedition_id, uint32 theme_id);
quest::crosszoneaddldonwinbygroupid(int group_id, uint32 theme_id);
quest::crosszoneaddldonwinbyguildid(int guild_id, uint32 theme_id);
quest::crosszoneaddldonwinbyraidid(int raid_id, uint32 theme_id);
quest::crosszoneassigntaskbycharid(int character_id, uint32 task_id, bool enforce_level_requirement);
quest::crosszoneassigntaskbycharid(int character_id, uint32 task_id);
quest::crosszoneassigntaskbyclientname(string client_name, uint32 task_id, bool enforce_level_requirement);
quest::crosszoneassigntaskbyclientname(string client_name, uint32 task_id);
quest::crosszoneassigntaskbyexpeditionid(uint32 expedition_id, uint32 task_id, bool enforce_level_requirement);
quest::crosszoneassigntaskbyexpeditionid(uint32 expedition_id, uint32 task_id);
quest::crosszoneassigntaskbygroupid(int group_id, uint32 task_id, bool enforce_level_requirement);
quest::crosszoneassigntaskbygroupid(int group_id, uint32 task_id);
quest::crosszoneassigntaskbyguildid(int guild_id, uint32 task_id);
quest::crosszoneassigntaskbyguildid(int guild_id, uint32 task_id, bool enforce_level_requirement);
quest::crosszoneassigntaskbyraidid(int raid_id, uint32 task_id);
quest::crosszoneassigntaskbyraidid(int raid_id, uint32 task_id, bool enforce_level_requirement);
quest::crosszonecastspellbycharid(int character_id, uint32 spell_id);
quest::crosszonecastspellbyclientname(string client_name, uint32 spell_id);
quest::crosszonecastspellbyexpeditionid(uint32 expedition_id, uint32 spell_id);
quest::crosszonecastspellbygroupid(int group_id, uint32 spell_id);
quest::crosszonecastspellbyguildid(int guild_id, uint32 spell_id);
quest::crosszonecastspellbyraidid(int raid_id, uint32 spell_id);
quest::crosszonedialoguewindowbycharid(int character_id, string message);
quest::crosszonedialoguewindowbyclientname(string client_name, string message);
quest::crosszonedialoguewindowbyexpeditionid(uint32 expedition_id, string message);
quest::crosszonedialoguewindowbygroupid(int group_id, string message);
quest::crosszonedialoguewindowbyguildid(int guild_id, string message);
quest::crosszonedialoguewindowbyraidid(int raid_id, string message);
quest::crosszonedisabletaskbycharid(int character_id, uint32 task_id);
quest::crosszonedisabletaskbyclientname(string client_name, uint32 task_id);
quest::crosszonedisabletaskbyexpeditionid(uint32 expedition_id, uint32 task_id);
quest::crosszonedisabletaskbygroupid(int group_id, uint32 task_id);
quest::crosszonedisabletaskbyguildid(int guild_id, uint32 task_id);
quest::crosszonedisabletaskbyraidid(int raid_id, uint32 task_id);
quest::crosszoneenabletaskbycharid(int character_id, uint32 task_id);
quest::crosszoneenabletaskbyclientname(string client_name, uint32 task_id);
quest::crosszoneenabletaskbyexpeditionid(uint32 expedition_id, uint32 task_id);
quest::crosszoneenabletaskbygroupid(int group_id, uint32 task_id);
quest::crosszoneenabletaskbyguildid(int guild_id, uint32 task_id);
quest::crosszoneenabletaskbyraidid(int raid_id, uint32 task_id);
quest::crosszonefailtaskbycharid(int character_id, uint32 task_id);
quest::crosszonefailtaskbyclientname(string client_name, uint32 task_id);
quest::crosszonefailtaskbyexpeditionid(uint32 expedition_id, uint32 task_id);
quest::crosszonefailtaskbygroupid(int group_id, uint32 task_id);
quest::crosszonefailtaskbyguildid(int guild_id, uint32 task_id);
quest::crosszonefailtaskbyraidid(int raid_id, uint32 task_id);
quest::crosszonemarqueebycharid(int character_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemarqueebyclientname(string client_name, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemarqueebyexpeditionid(uint32 expedition_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemarqueebygroupid(int group_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemarqueebyguildid(int guild_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemarqueebyraidid(int raid_id, uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::crosszonemessageplayerbycharid(int character_id, uint32 type, string message);
quest::crosszonemessageplayerbyexpeditionid(uint32 expedition_id, uint32 type, string message);
quest::crosszonemessageplayerbygroupid(int group_id, uint32 type, string message);
quest::crosszonemessageplayerbyguildid(int guild_id, uint32 type, string message);
quest::crosszonemessageplayerbyname(string client_name, uint32 type, string message);
quest::crosszonemessageplayerbyraidid(int raid_id, uint32 type, string message);
quest::crosszonemoveinstancebycharid(uint32 character_id, uint16 instance_id);
quest::crosszonemoveinstancebycharid(uint32 character_id, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebycharid(uint32 character_id, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveinstancebyclientname(string client_name, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveinstancebyclientname(string client_name, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebyclientname(string client_name, uint16 instance_id);
quest::crosszonemoveinstancebyexpeditionid(uint32 expedition_id, uint16 instance_id);
quest::crosszonemoveinstancebyexpeditionid(uint32 expedition_id, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebyexpeditionid(uint32 expedition_id, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveinstancebygroupid(uint32 group_id, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebygroupid(uint32 group_id, uint16 instance_id);
quest::crosszonemoveinstancebygroupid(uint32 group_id, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveinstancebyguildid(uint32 guild_id, uint16 instance_id);
quest::crosszonemoveinstancebyguildid(uint32 guild_id, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebyguildid(uint32 guild_id, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveinstancebyraidid(uint32 raid_id, uint16 instance_id);
quest::crosszonemoveinstancebyraidid(uint32 raid_id, uint16 instance_id, float x, float y, float z);
quest::crosszonemoveinstancebyraidid(uint32 raid_id, uint16 instance_id, float x, float y, float z, float heading);
quest::crosszonemoveplayerbycharid(uint32 character_id, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbycharid(uint32 character_id, string zone_short_name);
quest::crosszonemoveplayerbycharid(uint32 character_id, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbyexpeditionid(uint32 expedition_id, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbyexpeditionid(uint32 expedition_id, string zone_short_name);
quest::crosszonemoveplayerbyexpeditionid(uint32 expedition_id, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbygroupid(uint32 group_id, string zone_short_name);
quest::crosszonemoveplayerbygroupid(uint32 group_id, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbygroupid(uint32 group_id, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbyguildid(uint32 guild_id, string zone_short_name);
quest::crosszonemoveplayerbyguildid(uint32 guild_id, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbyguildid(uint32 guild_id, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbyname(string client_name, string zone_short_name);
quest::crosszonemoveplayerbyname(string client_name, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbyname(string client_name, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbyraidid(uint32 raid_id, string zone_short_name, float x, float y, float z, float heading);
quest::crosszonemoveplayerbyraidid(uint32 raid_id, string zone_short_name, float x, float y, float z);
quest::crosszonemoveplayerbyraidid(uint32 raid_id, string zone_short_name);
quest::crosszoneremoveldonlossbycharid(int character_id, uint32 theme_id);
quest::crosszoneremoveldonlossbyclientname(string client_name, uint32 theme_id);
quest::crosszoneremoveldonlossbyexpeditionid(uint32 expedition_id, uint32 theme_id);
quest::crosszoneremoveldonlossbygroupid(int group_id, uint32 theme_id);
quest::crosszoneremoveldonlossbyguildid(int guild_id, uint32 theme_id);
quest::crosszoneremoveldonlossbyraidid(int raid_id, uint32 theme_id);
quest::crosszoneremoveldonwinbycharid(int character_id, uint32 theme_id);
quest::crosszoneremoveldonwinbyclientname(string client_name, uint32 theme_id);
quest::crosszoneremoveldonwinbyexpeditionid(uint32 expedition_id, uint32 theme_id);
quest::crosszoneremoveldonwinbygroupid(int group_id, uint32 theme_id);
quest::crosszoneremoveldonwinbyguildid(int guild_id, uint32 theme_id);
quest::crosszoneremoveldonwinbyraidid(int raid_id, uint32 theme_id);
quest::crosszoneremovespellbycharid(int character_id, uint32 spell_id);
quest::crosszoneremovespellbyclientname(string client_name, uint32 spell_id);
quest::crosszoneremovespellbyexpeditionid(uint32 expedition_id, uint32 spell_id);
quest::crosszoneremovespellbygroupid(int group_id, uint32 spell_id);
quest::crosszoneremovespellbyguildid(int guild_id, uint32 spell_id);
quest::crosszoneremovespellbyraidid(int raid_id, uint32 spell_id);
quest::crosszoneremovetaskbycharid(int character_id, uint32 task_id);
quest::crosszoneremovetaskbyclientname(string client_name, uint32 task_id);
quest::crosszoneremovetaskbyexpeditionid(uint32 expedition_id, uint32 task_id);
quest::crosszoneremovetaskbygroupid(int group_id, uint32 task_id);
quest::crosszoneremovetaskbyguildid(int guild_id, uint32 task_id);
quest::crosszoneremovetaskbyraidid(int raid_id, uint32 task_id);
quest::crosszoneresetactivitybycharid(int character_id, uint32 task_id, int activity_id);
quest::crosszoneresetactivitybyclientname(string client_name, uint32 task_id, int activity_id);
quest::crosszoneresetactivitybyexpeditionid(uint32 expedition_id, uint32 task_id, int activity_id);
quest::crosszoneresetactivitybygroupid(int group_id, uint32 task_id, int activity_id);
quest::crosszoneresetactivitybyguildid(int guild_id, uint32 task_id, int activity_id);
quest::crosszoneresetactivitybyraidid(int raid_id, uint32 task_id, int activity_id);
quest::crosszonesetentityvariablebycharid(int character_id, string variable_name, string variable_value);
quest::crosszonesetentityvariablebyclientname(string client_name, string variable_name, string variable_value);
quest::crosszonesetentityvariablebyexpeditionid(uint32 expedition_id, string variable_name, string variable_value);
quest::crosszonesetentityvariablebygroupid(int group_id, string variable_name, string variable_value);
quest::crosszonesetentityvariablebyguildid(int guild_id, string variable_name, string variable_value);
quest::crosszonesetentityvariablebynpctypeid(int npc_id, string variable_name, string variable_value);
quest::crosszonesetentityvariablebyraidid(int raid_id, string variable_name, string variable_value);
quest::crosszonesignalclientbycharid(int character_id, int signal_id);
quest::crosszonesignalclientbyexpeditionid(uint32 expedition_id, int signal_id);
quest::crosszonesignalclientbygroupid(int group_id, int signal_id);
quest::crosszonesignalclientbyguildid(int guild_id, int signal_id);
quest::crosszonesignalclientbyname(string client_name, int signal_id);
quest::crosszonesignalclientbyraidid(int raid_id, int signal_id);
quest::crosszonesignalnpcbynpctypeid(uint32 npc_id, int signal_id);
quest::crosszoneupdateactivitybycharid(int character_id, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybycharid(int character_id, uint32 task_id, int activity_id);
quest::crosszoneupdateactivitybyclientname(string client_name, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybyclientname(string client_name, uint32 task_id, int activity_id);
quest::crosszoneupdateactivitybyexpeditionid(uint32 expedition_id, uint32 task_id, int activity_id);
quest::crosszoneupdateactivitybyexpeditionid(uint32 expedition_id, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybygroupid(int group_id, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybygroupid(int group_id, uint32 task_id, int activity_id);
quest::crosszoneupdateactivitybyguildid(int guild_id, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybyguildid(int guild_id, uint32 task_id, int activity_id);
quest::crosszoneupdateactivitybyraidid(int raid_id, uint32 task_id, int activity_id, int update_count);
quest::crosszoneupdateactivitybyraidid(int raid_id, uint32 task_id, int activity_id);
quest::debug(string message);
quest::debug(string message, int level);
quest::delete_data(string bucket_key);
quest::delglobal(string key);
quest::depop();
quest::depop(int npc_type_id);
quest::depop_withtimer();
quest::depop_withtimer(int npc_type_id);
quest::depopall();
quest::depopall(int npc_type_id);
quest::depopzone(bool start_spawn_status);
quest::ding();
quest::disable_proximity_say();
quest::disable_spawn2(uint32_t spawn2_id);
quest::disablerecipe(uint32 recipe_id);
quest::disabletask(array task_ids);
quest::discordsend(string webhook_name, string message);
quest::do_augment_slots_match(uint32 item_one, uint32 item_two);
quest::doanim(int animation_id, int animation_speed, bool ackreq, int filter);
quest::doanim(int animation_id, int animation_speed, bool ackreq);
quest::doanim(int animation_id, int animation_speed);
quest::doanim(int animation_id);
quest::does_augment_fit(EQ::ItemInstance* inst, uint32 augment_id);
quest::does_augment_fit_slot(EQ::ItemInstance* inst, uint32 augment_id, uaugment_slot);
quest::echo(int emote_color_id, string message);
quest::emote(string message);
quest::enable_proximity_say();
quest::enable_spawn2(uint32_t spawn2_id);
quest::enabledtaskcount(task_set);
quest::enablerecipe(uint32 recipe_id);
quest::enabletask(array task_ids);
quest::enabletitle(int title_set);
quest::end_dz_task(bool send_fail);
quest::end_dz_task();
quest::exp(int amount);
quest::faction(int faction_id, int value, int temp);
quest::faction(int faction_id, int value);
quest::factionvalue();
quest::failtask(int task_id);
quest::firsttaskinset(task_set);
quest::follow(int entity_id);
quest::follow(int entity_id, int distance);
quest::forcedoorclose(uint32 door_id, bool alt_mode);
quest::forcedoorclose(uint32 door_id);
quest::forcedooropen(uint32 door_id);
quest::forcedooropen(uint32 door_id, bool alt_mode);
quest::get_class_bitmask(uint8 class_id);
quest::get_data(bucket_key);
quest::get_data_expires(bucket_key);
quest::get_data_remaining(bucket_name);
quest::get_deity_bitmask(deity_id);
quest::get_dz_task_id();
quest::get_expedition();
quest::get_expedition_by_char_id(uint32 char_id);
quest::get_expedition_by_dz_id(uint32 dz_id);
quest::get_expedition_by_zone_instance(uint32 zone_id, uint32 instance_id);
quest::get_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name);
quest::get_expedition_lockouts_by_char_id(uint32 char_id, string expedition_name);
quest::get_expedition_lockouts_by_char_id(uint32 char_id);
quest::get_race_bitmask(race_id);
quest::get_recipe_component_count(uint32 recipe_id, uint32 item_id);
quest::get_recipe_component_item_ids(uint32 recipe_id);
quest::get_recipe_container_item_ids(uint32 recipe_id);
quest::get_recipe_fail_count(uint32 recipe_id, uint32 item_id);
quest::get_recipe_fail_item_ids(uint32 recipe_id);
quest::get_recipe_salvage_count(uint32 recipe_id, uint32 item_id);
quest::get_recipe_salvage_item_ids(uint32 recipe_id);
quest::get_recipe_success_count(uint32 recipe_id, uint32 item_id);
quest::get_recipe_success_item_ids(uint32 recipe_id);
quest::get_rule(string rule_name);
quest::get_spawn_condition(string zone_short, uint32 instance_id, uint16 condition_id);
quest::get_spawn_condition(string zone_short, uint16 condition_id);
quest::get_spell_level(uint16 spell_id, class_id);
quest::getaaexpmodifierbycharid(uint32 character_id, uint32 zone_id, int16 instance_version);
quest::getaaexpmodifierbycharid(uint32 character_id, uint32 zone_id);
quest::getaaname(int aa_id);
quest::getbodytypename(uint8 body_type_id);
quest::getcharidbyname(string name);
quest::getcharnamebyid(uint32 char_id);
quest::getclassname(uint8 class_id, uint8 level);
quest::getclassname(uint8 class_id);
quest::getcleannpcnamebyid(uint32 npc_id);
quest::getconsiderlevelname(uint8 consider_level);
quest::getcurrencyid(item_id);
quest::getcurrencyitemid(currency_id);
quest::getdeityname(uint32 deity_id);
quest::getenvironmentaldamagename(uint8 damage_type);
quest::getexpmodifierbycharid(uint32 character_id, uint32 zone_id);
quest::getexpmodifierbycharid(uint32 character_id, uint32 zone_id, int16 instance_version);
quest::getfactionname(int faction_id);
quest::getgendername(uint32 gender_id);
quest::getgroupidbycharid(uint32 char_id);
quest::getguildidbycharid(uint32 char_id);
quest::getguildnamebyid(int guild_id);
quest::gethexcolorcode(color_name);
quest::getinventoryslotid(string identifier);
quest::getinventoryslotname(int16 slot_id);
quest::getitemcomment(uint32 item_id);
quest::getitemlore(uint32 item_id);
quest::getitemname(uint32 item_id);
quest::getitemstat(uint32 item_id, string identifier);
quest::getlanguagename(uint8 language_id);
quest::getldonthemename(uint32 theme_id);
quest::getlevel(uint8 type);
quest::getnpcnamebyid(uint32 npc_id);
quest::getplayerburiedcorpsecount(uint32 char_id);
quest::getplayercorpsecount(uint32 character_id);
quest::getplayercorpsecountbyzoneid(uint32 character_id, uint32 zone_id);
quest::getracename(uint16 race_id);
quest::getraididbycharid(uint32 char_id);
quest::getrecipemadecount(uint32 recipe_id);
quest::getrecipename(uint32 recipe_id);
quest::getremainingtimeMS(string timer_name);
quest::getskillname(int skill_id);
quest::getspell(uint32 spell_id);
quest::getspellname(uint32 spell_id);
quest::getspellstat(uint32 spell_id, string stat_identifier);
quest::getspellstat(uint32 spell_id, string stat_identifier, uint8 slot);
quest::gettaskactivitydonecount(task_id, activity_id);
quest::gettaskname(uint32 task_id);
quest::gettimerdurationMS(string timer_name);
quest::givecash(uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
quest::givecash(uint32 copper, uint32 silver, uint32 gold);
quest::givecash(uint32 copper, uint32 silver);
quest::givecash(uint32 copper);
quest::gmmove(float x, float y, float z);
quest::gmsay(string message, int color_id, bool send_to_world, int to_guilddbid);
quest::gmsay(string message, int color_id);
quest::gmsay(string message);
quest::gmsay(string message, int color_id, bool send_to_world);
quest::gmsay(string message, int color_id, bool send_to_world, int to_guilddbid, int to_minstatus);
quest::has_zone_flag(int zone_id);
quest::hasrecipelearned(uint32 recipe_id);
quest::hastimer(string timer_name);
quest::incstat(int stat_id, int int_value);
quest::is_call_of_the_forsaken_enabled();
quest::is_classic_enabled();
quest::is_content_flag_enabled(string flag_name);
quest::is_current_expansion_call_of_the_forsaken();
quest::is_current_expansion_classic();
quest::is_current_expansion_depths_of_darkhollow();
quest::is_current_expansion_dragons_of_norrath();
quest::is_current_expansion_empires_of_kunark();
quest::is_current_expansion_gates_of_discord();
quest::is_current_expansion_house_of_thule();
quest::is_current_expansion_lost_dungeons_of_norrath();
quest::is_current_expansion_omens_of_war();
quest::is_current_expansion_prophecy_of_ro();
quest::is_current_expansion_rain_of_fear();
quest::is_current_expansion_ring_of_scale();
quest::is_current_expansion_secrets_of_faydwer();
quest::is_current_expansion_seeds_of_destruction();
quest::is_current_expansion_the_broken_mirror();
quest::is_current_expansion_the_buried_sea();
quest::is_current_expansion_the_burning_lands();
quest::is_current_expansion_the_darkened_sea();
quest::is_current_expansion_the_legacy_of_ykesha();
quest::is_current_expansion_the_planes_of_power();
quest::is_current_expansion_the_ruins_of_kunark();
quest::is_current_expansion_the_scars_of_velious();
quest::is_current_expansion_the_serpents_spine();
quest::is_current_expansion_the_shadows_of_luclin();
quest::is_current_expansion_torment_of_velious();
quest::is_current_expansion_underfoot();
quest::is_current_expansion_veil_of_alaris();
quest::is_depths_of_darkhollow_enabled();
quest::is_dragons_of_norrath_enabled();
quest::is_empires_of_kunark_enabled();
quest::is_gates_of_discord_enabled();
quest::is_house_of_thule_enabled();
quest::is_lost_dungeons_of_norrath_enabled();
quest::is_omens_of_war_enabled();
quest::is_prophecy_of_ro_enabled();
quest::is_rain_of_fear_enabled();
quest::is_ring_of_scale_enabled();
quest::is_secrets_of_faydwer_enabled();
quest::is_seeds_of_destruction_enabled();
quest::is_the_broken_mirror_enabled();
quest::is_the_buried_sea_enabled();
quest::is_the_burning_lands_enabled();
quest::is_the_darkened_sea_enabled();
quest::is_the_legacy_of_ykesha_enabled();
quest::is_the_planes_of_power_enabled();
quest::is_the_ruins_of_kunark_enabled();
quest::is_the_scars_of_velious_enabled();
quest::is_the_serpents_spine_enabled();
quest::is_the_shadows_of_luclin_enabled();
quest::is_torment_of_velious_enabled();
quest::is_underfoot_enabled();
quest::is_veil_of_alaris_enabled();
quest::isdisctome(int item_id);
quest::isdooropen(uint32 door_id);
quest::ishotzone();
quest::isnpcspawned(array npc_id_array);
quest::ispausedtimer(string timer_name);
quest::istaskactive(int task_id);
quest::istaskactivityactive(int task_id, int activity_id);
quest::istaskappropriate(int task_id);
quest::istaskcompleted(int task_id);
quest::istaskenabled(int task_id);
quest::itemlink(int item_id);
quest::lasttaskinset(task_set);
quest::level(int new_level);
quest::log(int category, string message);
quest::log_combat(string message);
quest::marquee(uint32 type, string message);
quest::marquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::marquee(uint32 type, string message, uint32 duration);
quest::me(string message);
quest::message(int color, string message);
quest::modifynpcstat(string key, string value);
quest::movegrp(int zone_id, float x, float y, float z);
quest::movepc(int zone_id, float x, float y, float z);
quest::movepc(int zone_id, float x, float y, float z, float heading);
quest::moveto(float x, float y, float z);
quest::moveto(float x, float y, float z, float h, bool save_guard_location);
quest::moveto(float x, float y, float z, float h);
quest::nexttaskinset(task_set, task_id);
quest::npcfeature(string feature, int value);
quest::npcgender(uint8 gender_id);
quest::npcrace(uint16 race_id);
quest::npcsize(float size);
quest::npctexture(uint8 texture_id);
quest::pause(int duration_ms);
quest::pausetimer(string timer_name);
quest::permaclass(int class_id);
quest::permagender(int gender_id);
quest::permarace(int race_id);
quest::playerfeature(string feature, int value);
quest::playergender(uint8 gender_id);
quest::playerrace(uint16 race_id);
quest::playersize(float size);
quest::playertexture(uint8 texture_id);
quest::popup(string window_title, string message);
quest::popup(string window_title, string message, int popup_id);
quest::popup(string window_title, string message, int popup_id, int buttons);
quest::popup(string window_title, string message, int popup_id, int buttons, int duration);
quest::popupbreak();
quest::popupbreak(uint32 break_count);
quest::popupcentermessage(message);
quest::popupcolormessage(color, message);
quest::popupindent(uint32 indent_count);
quest::popupindent();
quest::popuplink(link, message);
quest::popuplink(link);
quest::popuptable(message);
quest::popuptablecell();
quest::popuptablecell(message);
quest::popuptablerow(message);
quest::processmobswhilezoneempty(bool on);
quest::pvp(string mode);
quest::qs_player_event(int char_id, string message);
quest::qs_send_query(string query);
quest::rain(int weather);
quest::rebind(int zone_id, float x, float y, float z, float heading);
quest::rebind(int zone_id, float x, float y, float z);
quest::reloadzonestaticdata();
quest::remove_all_expedition_lockouts_by_char_id(uint32 char_id);
quest::remove_all_expedition_lockouts_by_char_id(uint32 char_id, string expedition_name);
quest::remove_expedition_lockout_by_char_id(uint32 char_id, string expedition_name, string event_name);
quest::removeitem(uint32_t item_id);
quest::removeitem(uint32_t item_id, int quantity);
quest::removeldonloss(uint32 theme_id);
quest::removeldonwin(uint32 theme_id);
quest::removetitle(int title_set);
quest::rename(string name);
quest::repopzone(bool is_forced);
quest::repopzone();
quest::resettaskactivity(int task_id, int activity_id);
quest::respawn(int npc_type_id, int grid_id);
quest::resume();
quest::resumetimer(string timer_name);
quest::rewardfaction(int faction_id, int value);
quest::safemove();
quest::save();
quest::say(string message, uint8 language_id);
quest::say(string message, uint8 language_id, int message_type);
quest::say(string message);
quest::say(string message, uint8 language_id, int message_type, int speak_mode);
quest::say(string message, uint8 language_id, int message_type, int speak_mode, int journal_mode);
quest::saylink(text);
quest::saylink(text, bool silent, link_name);
quest::saylink(text, bool silent);
quest::scribespells(max_level, min_level);
quest::scribespells(max_level);
quest::secondstotime(int duration);
quest::selfcast(uint16 spell_id);
quest::send_channel_message(Client* from, uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
quest::send_channel_message(uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
quest::send_channel_message(Client* from, string to, uint8 channel_number, uint32 guild_id, uint8 language_id, uint8 language_skill, string message);
quest::send_parcel(reference table_ref);
quest::send_player_handin_event();
quest::set_content_flag(string flag_name, bool enabled);
quest::set_data(string key, string value);
quest::set_data(string key, string value, string expires_at);
quest::set_proximity(float min_x, float max_x, float min_y, float max_y, float min_z, float max_z, bool enable_say);
quest::set_proximity(float min_x, float max_x, float min_y, float max_y, float min_z, float max_z);
quest::set_proximity(float min_x, float max_x, float min_y, float max_y);
quest::set_proximity_range(float x_range, float y_range, float z_range);
quest::set_proximity_range(float x_range, float y_range, float z_range, bool enable_say);
quest::set_proximity_range(float x_range, float y_range);
quest::set_rule(string rule_name, string rule_value);
quest::set_zone_flag(int zone_id);
quest::setaaexpmodifierbycharid(uint32 character_id, uint32 zone_id, double aa_modifier, int16 instance_version);
quest::setaaexpmodifierbycharid(uint32 character_id, uint32 zone_id, double aa_modifier);
quest::setallskill(int value);
quest::setanim(int npc_type_id, int appearance_number);
quest::setexpmodifierbycharid(uint32 character_id, uint32 zone_id, double exp_modifier);
quest::setexpmodifierbycharid(uint32 character_id, uint32 zone_id, double exp_modifier, int16 instance_version);
quest::setglobal(string key, string value, int options, string duration);
quest::setguild(uint32_t guild_id, uint8_t guild_rank_id);
quest::sethotzone(bool is_hotzone);
quest::sethp(int mob_health_percentage);
quest::setlanguage(uint8 language_id, uint8 language_skill);
quest::setnexthpevent(int at_mob_percentage);
quest::setnextinchpevent(int at_mob_percentage);
quest::setskill(int skill_id, int value);
quest::setsky(uint8 new_sky);
quest::setstat(int stat_id, int int_value);
quest::settarget(string target_enum, int target_id);
quest::settime(int new_hour, int new_min, bool update_world);
quest::settime(int new_hour, int new_min);
quest::settimer(string timer_name, uint32 seconds, EQ::ItemInstance* inst);
quest::settimer(string timer_name, uint32 seconds, Mob* m);
quest::settimer(string timer_name, uint32 seconds);
quest::settimerMS(string timer_name, uint32 milliseconds, EQ::ItemInstance* inst);
quest::settimerMS(string timer_name, uint32 milliseconds);
quest::settimerMS(string timer_name, uint32 milliseconds, Mob* m);
quest::sfollow();
quest::shout(string message);
quest::shout2(string message);
quest::showgrid(int grid_id);
quest::signal(int npc_id);
quest::signal(int npc_id, int wait_ms);
quest::signalwith(int npc_id, int signal_id);
quest::signalwith(int npc_id, int signal_id, int wait_ms);
quest::silent_saylink(text);
quest::silent_saylink(text, link_name);
quest::snow(int weather);
quest::spawn(npc_type_id, grid_id, unused, float x, float y, float z);
quest::spawn2(npc_type_id, grid_id, unused, float x, float y, float z, float heading);
quest::spawn_condition(string zone_short, uint32_t instance_id, uint16 condition_id, int16 value);
quest::spawn_condition(string zone_short, uint16 condition_id, int16 value);
quest::spawn_from_spawn2(uint32_t spawn2_id);
quest::spawnbotcount(uint8 class_id);
quest::spawnbotcount();
quest::start(int waypoint);
quest::stop();
quest::stopalltimers();
quest::stoptimer(string timer_name);
quest::summonallplayercorpses(uint32 char_id, float dest_x, float dest_y, float dest_z, float dest_heading);
quest::summonburiedplayercorpse(uint32 char_id, float dest_x, float dest_y, float dest_z, float dest_heading);
quest::summonitem(int item_id);
quest::summonitem(int item_id, int charges);
quest::surname(string last_name);
quest::targlobal(string key, string value, string duration, int npc_id, int char_id, int zone_id);
quest::task_setselector(int task_set_id, bool ignore_cooldown);
quest::task_setselector(int task_set_id);
quest::taskselector(array task_ids);
quest::taskselector_nocooldown(array task_ids);
quest::tasktimeleft(task_id);
quest::timetoseconds(string time_string);
quest::toggle_spawn_event(int event_id, bool is_enabled, bool is_strict, bool reset_base);
quest::toggledoorstate(uint32 door_id);
quest::tracknpc(uint32 entity_id);
quest::traindisc(int tome_item_id);
quest::traindiscs(max_level, min_level);
quest::traindiscs(max_level);
quest::unique_spawn(npc_type_id, grid_id, unused, float x, float y, float z, float heading);
quest::unique_spawn(npc_type_id, grid_id, unused, float x, float y, float z);
quest::unscribespells();
quest::untraindiscs();
quest::updatespawntimer(uint32 id, uint32 new_time);
quest::updatetaskactivity(int task_id, int activity_id, int count, bool ignore_quest_update);
quest::updatetaskactivity(int task_id, int activity_id, int count);
quest::updatetaskactivity(int task_id, int activity_id);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6, bool attuned);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5, uint32 aug6);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4, uint32 aug5);
quest::varlink(EQ::ItemInstance* inst);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3, uint32 aug4);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2, uint32 aug3);
quest::varlink(uint32 item_id, int16 charges, uint32 aug1, uint32 aug2);
quest::varlink(uint32 item_id);
quest::varlink(uint32 item_id, int16 charges);
quest::voicetell(string client_name, int macro_id, int race_id, int gender_id);
quest::we(int emote_color_id, string message);
quest::wearchange(uint8 slot, uint32 texture_id);
quest::wearchange(uint8 slot, uint32 texture_id, uint32 hero_forge_model_id);
quest::wearchange(uint8 slot, uint32 texture_id, uint32 hero_forge_model_id, uint32 elite_material_id);
quest::whisper(string message);
quest::worldwideaddldonloss(uint32 theme_id);
quest::worldwideaddldonloss(uint32 theme_id, uint8 min_status);
quest::worldwideaddldonloss(uint32 theme_id, uint8 min_status, uint8 max_status);
quest::worldwideaddldonpoints(uint32 theme_id, int points, uint8 min_status, uint8 max_status);
quest::worldwideaddldonpoints(uint32 theme_id);
quest::worldwideaddldonpoints(uint32 theme_id, int points);
quest::worldwideaddldonpoints(uint32 theme_id, int points, uint8 min_status);
quest::worldwideaddldonwin(uint32 theme_id, uint8 min_status);
quest::worldwideaddldonwin(uint32 theme_id);
quest::worldwideaddldonwin(uint32 theme_id, uint8 min_status, uint8 max_status);
quest::worldwideassigntask(uint32 task_id, bool enforce_level_requirement);
quest::worldwideassigntask(uint32 task_id);
quest::worldwideassigntask(uint32 task_id, bool enforce_level_requirement, uint8 min_status, uint8 max_status);
quest::worldwideassigntask(uint32 task_id, bool enforce_level_requirement, uint8 min_status);
quest::worldwidecastspell(uint32 spell_id, uint8 min_status);
quest::worldwidecastspell(uint32 spell_id, uint8 min_status, uint8 max_status);
quest::worldwidecastspell(uint32 spell_id);
quest::worldwidedialoguewindow(string message, uint8 min_status, uint8 max_status);
quest::worldwidedialoguewindow(string message, uint8 min_status);
quest::worldwidedialoguewindow(string message);
quest::worldwidedisabletask(uint32 task_id);
quest::worldwidedisabletask(uint32 task_id, uint8 min_status);
quest::worldwidedisabletask(uint32 task_id, uint8 min_status, uint8 max_status);
quest::worldwideenabletask(uint32 task_id);
quest::worldwideenabletask(uint32 task_id, uint8 min_status, uint8 max_status);
quest::worldwideenabletask(uint32 task_id, uint8 min_status);
quest::worldwidefailtask(uint32 task_id);
quest::worldwidefailtask(uint32 task_id, uint8 min_status);
quest::worldwidefailtask(uint32 task_id, uint8 min_status, uint8 max_status);
quest::worldwidemarquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message, uint8 min_status, uint8 max_status);
quest::worldwidemarquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message, uint8 min_status);
quest::worldwidemarquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::worldwidemessage(uint32 type, string message, uint8 min_status);
quest::worldwidemessage(uint32 type, string message);
quest::worldwidemessage(uint32 type, string message, uint8 min_status, uint8 max_status);
quest::worldwidemove(string zone_short_name);
quest::worldwidemove(string zone_short_name, uint8 min_status);
quest::worldwidemove(string zone_short_name, uint8 min_status, uint8 max_status);
quest::worldwidemoveinstance(uint16 instance_id);
quest::worldwidemoveinstance(uint16 instance_id, uint8 min_status);
quest::worldwidemoveinstance(uint16 instance_id, uint8 min_status, uint8 max_status);
quest::worldwideremoveldonloss(uint32 theme_id, uint8 min_status);
quest::worldwideremoveldonloss(uint32 theme_id, uint8 min_status, uint8 max_status);
quest::worldwideremoveldonloss(uint32 theme_id);
quest::worldwideremoveldonwin(uint32 theme_id);
quest::worldwideremoveldonwin(uint32 theme_id, uint8 min_status);
quest::worldwideremoveldonwin(uint32 theme_id, uint8 min_status, uint8 max_status);
quest::worldwideremovespell(uint32 spell_id);
quest::worldwideremovespell(uint32 spell_id, uint8 min_status);
quest::worldwideremovespell(uint32 spell_id, uint8 min_status, uint8 max_status);
quest::worldwideremovetask(uint32 task_id, uint8 min_status, uint8 max_status);
quest::worldwideremovetask(uint32 task_id);
quest::worldwideremovetask(uint32 task_id, uint8 min_status);
quest::worldwideresetactivity(uint32 task_id, int activity_id, uint8 min_status, uint8 max_status);
quest::worldwideresetactivity(uint32 task_id, int activity_id);
quest::worldwideresetactivity(uint32 task_id, int activity_id, uint8 min_status);
quest::worldwidesetentityvariableclient(string variable_name, string variable_value, uint8 min_status);
quest::worldwidesetentityvariableclient(string variable_name, string variable_value, uint8 min_status, uint8 max_status);
quest::worldwidesetentityvariableclient(string variable_name, string variable_value);
quest::worldwidesetentityvariablenpc(string variable_name, string variable_value);
quest::worldwidesignalclient(int signal_id);
quest::worldwidesignalclient(int signal_id, uint8 min_status);
quest::worldwidesignalclient(int signal_id, uint8 min_status, uint8 max_status);
quest::worldwidesignalnpc(int signal_id);
quest::worldwideupdateactivity(uint32 task_id, int activity_id, int update_count, uint8 min_status);
quest::worldwideupdateactivity(uint32 task_id, int activity_id);
quest::worldwideupdateactivity(uint32 task_id, int activity_id, int update_count);
quest::worldwideupdateactivity(uint32 task_id, int activity_id, int update_count, uint8 min_status, uint8 max_status);
quest::write(string file, string message);
quest::ze(int emote_color_id, string message);
quest::zone(string zone_name);
quest::zonegroup(string zone_name);
quest::zonemarquee(uint32 type, string message);
quest::zonemarquee(uint32 type, string message, uint32 duration);
quest::zonemarquee(uint32 type, uint32 priority, uint32 fade_in, uint32 fade_out, uint32 duration, string message);
quest::zoneraid(string zone_name);
`
```

---

## QuestItem

*Source: quest-api/methods/questitem/index.html*

# QuestItem

Perl (57)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$questitem->AddEXP(uint32 exp);
$questitem->ClearTimers();
$questitem->Clone();
$questitem->ContainsAugmentByID(uint32_t item_id);
$questitem->CountAugmentByID(uint32_t item_id);
$questitem->DeleteCustomData(string identifier);
$questitem->GetAugment(uint8 slot_id);
$questitem->GetAugmentIDs();
$questitem->GetAugmentItemID(uint8 slot_id);
$questitem->GetAugmentType();
$questitem->GetCharges();
$questitem->GetColor();
$questitem->GetComment();
$questitem->GetCustomData(identifier);
$questitem->GetCustomDataString();
$questitem->GetEXP();
$questitem->GetID();
$questitem->GetItem(uint8 slot_id);
$questitem->GetItem();
$questitem->GetItemID(uint8 slot_id);
$questitem->GetItemLink();
$questitem->GetItemScriptID();
$questitem->GetKillsNeeded(uint8 current_level);
$questitem->GetMaxEvolveLevel();
$questitem->GetName();
$questitem->GetPrice();
$questitem->GetTaskDeliveredCount();
$questitem->GetTotalItemCount();
$questitem->GetUnscaledItem();
$questitem->IsAmmo();
$questitem->IsAttuned();
$questitem->IsAugmentable();
$questitem->IsAugmented();
$questitem->IsEquipable(int16 slot_id);
$questitem->IsEquipable(uint16 race_bitmask, uint16 class_bitmask);
$questitem->IsExpendable();
$questitem->IsInstanceNoDrop();
$questitem->IsStackable();
$questitem->IsType(int type);
$questitem->IsWeapon();
$questitem->ItemSay(string text);
$questitem->ItemSay(string text, uint8 language_id);
$questitem->RemoveTaskDeliveredItems();
$questitem->SetAttuned(bool is_attuned);
$questitem->SetCharges(int16_t charges);
$questitem->SetColor(uint32 color);
$questitem->SetCustomData(string identifier, bool value);
$questitem->SetCustomData(string identifier, string value);
$questitem->SetCustomData(string identifier, int value);
$questitem->SetCustomData(string identifier, float value);
$questitem->SetEXP(uint32 exp);
$questitem->SetInstanceNoDrop(bool is_attuned);
$questitem->SetPrice(uint32 price);
$questitem->SetScale(float scale_multiplier);
$questitem->SetScaling(bool is_scaling);
$questitem->SetTimer(string timer_name, uint32 timer);
$questitem->StopTimer(string timer_name);
`
```

---

## QuestItemData

*Source: quest-api/methods/questitemdata/index.html*

# QuestItemData

Perl (175)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$questitemdata->GetAC();
$questitemdata->GetAGI();
$questitemdata->GetAWis();
$questitemdata->GetAccuracy();
$questitemdata->GetArtifactFlag();
$questitemdata->GetAttack();
$questitemdata->GetAttuneable();
$questitemdata->GetAugmentDistiller();
$questitemdata->GetAugmentRestrict();
$questitemdata->GetAugmentSlotType(uint8 slot_id);
$questitemdata->GetAugmentSlotUnk2(uint8 slot_id);
$questitemdata->GetAugmentSlotVisible(uint8 slot_id);
$questitemdata->GetAugmentType();
$questitemdata->GetAvoidance();
$questitemdata->GetBackstabDamage();
$questitemdata->GetBagSize();
$questitemdata->GetBagSlots();
$questitemdata->GetBagType();
$questitemdata->GetBagWeightReduction();
$questitemdata->GetBaneDamageAmount();
$questitemdata->GetBaneDamageBody();
$questitemdata->GetBaneDamageRace();
$questitemdata->GetBaneDamageRaceAmount();
$questitemdata->GetBardEffect();
$questitemdata->GetBardLevel();
$questitemdata->GetBardLevel2();
$questitemdata->GetBardSkillType();
$questitemdata->GetBardSkillValue();
$questitemdata->GetBardType();
$questitemdata->GetBenefitFlag();
$questitemdata->GetBook();
$questitemdata->GetBookType();
$questitemdata->GetCHA();
$questitemdata->GetCR();
$questitemdata->GetCastTime();
$questitemdata->GetCastTime_();
$questitemdata->GetCharmFile();
$questitemdata->GetCharmFileID();
$questitemdata->GetClairvoyance();
$questitemdata->GetClasses();
$questitemdata->GetClickEffect();
$questitemdata->GetClickLevel();
$questitemdata->GetClickLevel2();
$questitemdata->GetClickName();
$questitemdata->GetClickType();
$questitemdata->GetColor();
$questitemdata->GetCombatEffects();
$questitemdata->GetCorruption();
$questitemdata->GetDEX();
$questitemdata->GetDOTShielding();
$questitemdata->GetDR();
$questitemdata->GetDSMitigation();
$questitemdata->GetDamage();
$questitemdata->GetDamageShield();
$questitemdata->GetDeity();
$questitemdata->GetDelay();
$questitemdata->GetElementalDamageAmount();
$questitemdata->GetElementalDamageType();
$questitemdata->GetEliteMaterial();
$questitemdata->GetEndurance();
$questitemdata->GetEnduranceRegen();
$questitemdata->GetExpendableArrow();
$questitemdata->GetExtraDamageAmount();
$questitemdata->GetExtraDamageSkill();
$questitemdata->GetFR();
$questitemdata->GetFVNoDrop();
$questitemdata->GetFactionAmount1();
$questitemdata->GetFactionAmount2();
$questitemdata->GetFactionAmount3();
$questitemdata->GetFactionAmount4();
$questitemdata->GetFactionModifier1();
$questitemdata->GetFactionModifier2();
$questitemdata->GetFactionModifier3();
$questitemdata->GetFactionModifier4();
$questitemdata->GetFavor();
$questitemdata->GetFilename();
$questitemdata->GetFocusEffect();
$questitemdata->GetFocusLevel();
$questitemdata->GetFocusLevel2();
$questitemdata->GetFocusName();
$questitemdata->GetFocusType();
$questitemdata->GetFulfilment();
$questitemdata->GetGuildFavor();
$questitemdata->GetHP();
$questitemdata->GetHaste();
$questitemdata->GetHealAmount();
$questitemdata->GetHeroicAGI();
$questitemdata->GetHeroicCHA();
$questitemdata->GetHeroicCR();
$questitemdata->GetHeroicCorruption();
$questitemdata->GetHeroicDEX();
$questitemdata->GetHeroicDR();
$questitemdata->GetHeroicFR();
$questitemdata->GetHeroicINT();
$questitemdata->GetHeroicMR();
$questitemdata->GetHeroicPR();
$questitemdata->GetHeroicSTA();
$questitemdata->GetHeroicSTR();
$questitemdata->GetHeroicWIS();
$questitemdata->GetID();
$questitemdata->GetIDFile();
$questitemdata->GetINT();
$questitemdata->GetIcon();
$questitemdata->GetItemClass();
$questitemdata->GetItemType();
$questitemdata->GetLDoNPrice();
$questitemdata->GetLDoNSellBackRate();
$questitemdata->GetLDoNSold();
$questitemdata->GetLDoNTheme();
$questitemdata->GetLight();
$questitemdata->GetLore();
$questitemdata->GetLoreFlag();
$questitemdata->GetLoreGroup();
$questitemdata->GetMR();
$questitemdata->GetMagic();
$questitemdata->GetMana();
$questitemdata->GetManaRegen();
$questitemdata->GetMaterial();
$questitemdata->GetMaximumCharges();
$questitemdata->GetMinimumStatus();
$questitemdata->GetName();
$questitemdata->GetNoDrop();
$questitemdata->GetNoPet();
$questitemdata->GetNoRent();
$questitemdata->GetNoTransfer();
$questitemdata->GetPR();
$questitemdata->GetPendingLoreFlag();
$questitemdata->GetPointType();
$questitemdata->GetPotionBelt();
$questitemdata->GetPotionBeltSlots();
$questitemdata->GetPrice();
$questitemdata->GetProcEffect();
$questitemdata->GetProcLevel();
$questitemdata->GetProcLevel2();
$questitemdata->GetProcName();
$questitemdata->GetProcRate();
$questitemdata->GetProcType();
$questitemdata->GetPurity();
$questitemdata->GetQuestItemFlag();
$questitemdata->GetRaces();
$questitemdata->GetRange();
$questitemdata->GetRecLevel();
$questitemdata->GetRecSkill();
$questitemdata->GetRecastDelay();
$questitemdata->GetRecastType();
$questitemdata->GetRegen();
$questitemdata->GetReqLevel();
$questitemdata->GetSTA();
$questitemdata->GetSTR();
$questitemdata->GetScriptFileID();
$questitemdata->GetScrollEffect();
$questitemdata->GetScrollLevel();
$questitemdata->GetScrollLevel2();
$questitemdata->GetScrollName();
$questitemdata->GetScrollType();
$questitemdata->GetSellRate();
$questitemdata->GetShielding();
$questitemdata->GetSize();
$questitemdata->GetSkillModifierType();
$questitemdata->GetSkillModifierValue();
$questitemdata->GetSlots();
$questitemdata->GetSpellDamage();
$questitemdata->GetSpellShield();
$questitemdata->GetStackSize();
$questitemdata->GetStackable();
$questitemdata->GetStrikeThrough();
$questitemdata->GetStunResist();
$questitemdata->GetSummonedFlag();
$questitemdata->GetTradeskills();
$questitemdata->GetWeight();
$questitemdata->GetWornEffect();
$questitemdata->GetWornLevel();
$questitemdata->GetWornLevel2();
$questitemdata->GetWornName();
$questitemdata->GetWornType();
`
```

---

## Raid

*Source: quest-api/methods/raid/index.html*

# Raid

Perl (28)Lua (28)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$raid->BalanceHP(int32_t penalty, uint32_t group_id);
$raid->CastGroupSpell(Mob* caster, uint16 spell_id, uint32 group_id);
$raid->DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count);
$raid->DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name);
$raid->GetClientByIndex(uint16_t member_index);
$raid->GetGroup(string name);
$raid->GetGroup(Client* client);
$raid->GetGroupNumber(member_index);
$raid->GetHighestLevel();
$raid->GetID();
$raid->GetLeader();
$raid->GetLeaderName();
$raid->GetLowestLevel();
$raid->GetMember(int member_index);
$raid->GetTotalRaidDamage(Mob* other);
$raid->GroupCount(uint32_t group_id);
$raid->IsGroupLeader(string who);
$raid->IsGroupLeader(Client* c);
$raid->IsLeader(Client* c);
$raid->IsLeader(string name);
$raid->IsRaidMember(string name);
$raid->IsRaidMember(Client* c);
$raid->RaidCount();
$raid->SplitExp(uint32 experience, Mob* other);
$raid->SplitMoney(uint32 gid, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, Client* splitter);
$raid->SplitMoney(uint32 gid, uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
$raid->TeleportGroup(Mob* sender, uint32 zone_id, float x, float y, float z, float heading, uint32 group_id);
$raid->TeleportRaid(Mob* sender, uint32 zone_id, float x, float y, float z, float heading);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`raid:BalanceHP(int penalty, uint32 group_id);
raid:CastGroupSpell(Mob caster, int spell_id, uint32 group_id);
raid:DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count);
raid:DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name);
raid:GetClientByIndex(int member_index);
raid:GetGroup(string c);
raid:GetGroup(Client c);
raid:GetGroupNumber(member_index);
raid:GetHighestLevel();
raid:GetID();
raid:GetLeader();
raid:GetLeaderName();
raid:GetLowestLevel();
raid:GetMember(int member_index);
raid:GetTotalRaidDamage(Mob other);
raid:GroupCount(uint32 group_id);
raid:IsGroupLeader(string name);
raid:IsGroupLeader(Client c);
raid:IsLeader(string c);
raid:IsLeader(Client c);
raid:IsRaidMember(Client c);
raid:IsRaidMember(string name);
raid:RaidCount();
raid:SplitExp(uint64 exp, Mob other);
raid:SplitMoney(uint32 gid, uint32 copper, uint32 silver, uint32 gold, uint32 platinum, Client splitter);
raid:SplitMoney(uint32 gid, uint32 copper, uint32 silver, uint32 gold, uint32 platinum);
raid:TeleportGroup(Mob sender, uint32 zone_id, uint32 instance_id, float x, float y, float z, float h, uint32 group_id);
raid:TeleportRaid(Mob sender, uint32 zone_id, uint32 instance_id, float x, float y, float z, float h);
`
```

---

## Spawn

*Source: quest-api/methods/spawn/index.html*

# Spawn

Perl (26)Lua (26)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$spawn->Depop();
$spawn->Disable();
$spawn->Enable();
$spawn->ForceDespawn();
$spawn->GetCurrentNPCID();
$spawn->GetHeading();
$spawn->GetID();
$spawn->GetKillCount();
$spawn->GetRespawnTimer();
$spawn->GetSpawnCondition();
$spawn->GetSpawnGroupID();
$spawn->GetVariance();
$spawn->GetX();
$spawn->GetY();
$spawn->GetZ();
$spawn->IsEnabled();
$spawn->IsNPCPointerValid();
$spawn->LoadGrid();
$spawn->Repop();
$spawn->Repop(uint32 delay);
$spawn->Reset();
$spawn->SetCurrentNPCID(uint32 npc_id);
$spawn->SetNPCPointer(NPC* n);
$spawn->SetRespawnTimer(uint32 new_respawn_time);
$spawn->SetTimer(uint32 duration);
$spawn->SetVariance(uint32 new_variance);
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`spawn:CurrentNPCID();
spawn:Depop();
spawn:Disable();
spawn:Enable();
spawn:Enabled();
spawn:ForceDespawn();
spawn:GetHeading();
spawn:GetID();
spawn:GetKillCount();
spawn:GetSpawnCondition();
spawn:GetVariance();
spawn:GetX();
spawn:GetY();
spawn:GetZ();
spawn:LoadGrid();
spawn:NPCPointerValid();
spawn:Repop();
spawn:Repop(uint32 delay);
spawn:Reset();
spawn:RespawnTimer();
spawn:SetCurrentNPCID(uint32 nid);
spawn:SetNPCPointer(NPC n);
spawn:SetRespawnTimer(uint32 newrespawntime);
spawn:SetTimer(uint32 duration);
spawn:SetVariance(uint32 newvariance);
spawn:SpawnGroupID();
`
```

---

## Spell

*Source: quest-api/methods/spell/index.html*

# Spell

Perl (109)Lua (85)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$spell->GetAOEDuration();
$spell->GetAOEMaxTargets();
$spell->GetAOERange();
$spell->GetActivated();
$spell->GetAllowRest();
$spell->GetBaseDifficulty();
$spell->GetBaseValue(uint8_t slot);
$spell->GetBonusHate();
$spell->GetBuffDuration();
$spell->GetBuffDurationFormula();
$spell->GetCanCastInCombat();
$spell->GetCanCastOutOfCombat();
$spell->GetCanMGB();
$spell->GetCastNotStanding();
$spell->GetCastOnOther();
$spell->GetCastOnYou();
$spell->GetCastRestriction();
$spell->GetCastTime();
$spell->GetCasterRequirementID();
$spell->GetCastingAnimation();
$spell->GetClasses(uint8_t slot);
$spell->GetComponent(uint8_t slot);
$spell->GetComponentCount(uint8_t slot);
$spell->GetDeities(uint8_t slot);
$spell->GetDeityAgnostic();
$spell->GetDescriptionID();
$spell->GetDirectionalEnd();
$spell->GetDirectionalStart();
$spell->GetDisallowSit();
$spell->GetDispelFlag();
$spell->GetEffectDescriptionID();
$spell->GetEffectID(uint8_t slot);
$spell->GetEnduranceCost();
$spell->GetEnduranceUpkeep();
$spell->GetEnvironmentType();
$spell->GetFeedbackable();
$spell->GetFormula(uint8_t slot);
$spell->GetGoodEffect();
$spell->GetHateAdded();
$spell->GetHitNumber();
$spell->GetHitNumberType();
$spell->GetID();
$spell->GetIsDiscipline();
$spell->GetLDoNTrap();
$spell->GetLimitValue(uint8_t slot);
$spell->GetMana();
$spell->GetMaxDistance();
$spell->GetMaxDistanceMod();
$spell->GetMaxResist();
$spell->GetMaxValue(uint8_t slot);
$spell->GetMinDistance();
$spell->GetMinDistanceMod();
$spell->GetMinRange();
$spell->GetMinResist();
$spell->GetNPCNoLOS();
$spell->GetName();
$spell->GetNewIcon();
$spell->GetNimbusEffect();
$spell->GetNoBlock();
$spell->GetNoDetrimentalSpellAggro();
$spell->GetNoExpendReagent(uint8_t slot);
$spell->GetNoHealDamageItemMod();
$spell->GetNoPartialResist();
$spell->GetNoRemove();
$spell->GetNoResist();
$spell->GetNotFocusable();
$spell->GetOtherCasts();
$spell->GetOverrideCritChance();
$spell->GetPCNPCOnlyFlag();
$spell->GetPVPDuration();
$spell->GetPVPDurationCap();
$spell->GetPVPResistBase();
$spell->GetPVPResistCap();
$spell->GetPVPResistPerLevel();
$spell->GetPersistDeath();
$spell->GetPlayer_1();
$spell->GetPushBack();
$spell->GetPushUp();
$spell->GetRange();
$spell->GetRank();
$spell->GetRecastTime();
$spell->GetRecourseLink();
$spell->GetRecoveryTime();
$spell->GetReflectable();
$spell->GetResistDifficulty();
$spell->GetResistType();
$spell->GetShortBuffBox();
$spell->GetSkill();
$spell->GetSneak();
$spell->GetSongCap();
$spell->GetSpellAffectIndex();
$spell->GetSpellCategory();
$spell->GetSpellClass();
$spell->GetSpellFades();
$spell->GetSpellGroup();
$spell->GetSpellSubclass();
$spell->GetSuspendable();
$spell->GetTargetType();
$spell->GetTeleportZone();
$spell->GetTimeOfDay();
$spell->GetTimerID();
$spell->GetTypeDescriptionID();
$spell->GetUninterruptable();
$spell->GetUnstackableDOT();
$spell->GetViralRange();
$spell->GetViralTargets();
$spell->GetViralTimer();
$spell->GetYouCast();
$spell->GetZoneType();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`spell:AEDuration();
spell:AEMaxTargets();
spell:Activated();
spell:AllowRest();
spell:AoeRange();
spell:Base(i);
spell:Base2(i);
spell:BaseDiff();
spell:BonusHate();
spell:BuffDuration();
spell:BuffdurationFormula();
spell:CanMGB();
spell:CastOnOther();
spell:CastOnYou();
spell:CastRestriction();
spell:CastTime();
spell:CastingAnim();
spell:Classes(i);
spell:ComponentCounts(i);
spell:Components(i);
spell:DamageShieldType();
spell:Deities(i);
spell:DescNum();
spell:DirectionalEnd();
spell:DirectionalStart();
spell:DisallowSit();
spell:DispelFlag();
spell:EffectDescNum();
spell:EffectID(i);
spell:EndurCost();
spell:EndurTimerIndex();
spell:EndurUpkeep();
spell:EnvironmentType();
spell:Formula(i);
spell:GetZoneType();
spell:GoodEffect();
spell:HateAdded();
spell:ID();
spell:InCombat();
spell:Mana();
spell:Max(i);
spell:MaxDist();
spell:MaxDistMod();
spell:MaxResist();
spell:MaxTargets();
spell:MinDist();
spell:MinDistMod();
spell:MinRange();
spell:MinResist();
spell:Name();
spell:NimbusEffect();
spell:NoexpendReagent(i);
spell:NumHits();
spell:OtherCasts();
spell:OutOfCombat();
spell:PVPDuration();
spell:PVPDurationCap();
spell:PVPResistBase();
spell:PVPResistCalc();
spell:PVPResistCap();
spell:PersistDeath();
spell:Player1();
spell:PowerfulFlag();
spell:PushBack();
spell:PushUp();
spell:Range();
spell:Rank();
spell:RecastTime();
spell:RecourseLink();
spell:RecoveryTime();
spell:ResistDiff();
spell:ResistType();
spell:ShortBuffBox();
spell:Skill();
spell:SpellAffectIndex();
spell:SpellCategory();
spell:SpellFades();
spell:SpellGroup();
spell:TargetType();
spell:TeleportZone();
spell:TimeOfDay();
spell:Uninterruptable();
spell:ViralTargets();
spell:ViralTimer();
spell:YouCast();
`
```

---

## StatBonuses

*Source: quest-api/methods/statbonuses/index.html*

# StatBonuses

Perl (256)Lua (257)

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`$statbonuses->GetAC();
$statbonuses->GetAGI();
$statbonuses->GetAGICapModifier();
$statbonuses->GetAStacker(int slot);
$statbonuses->GetATK();
$statbonuses->GetAbsorbMagicAttack(int slot);
$statbonuses->GetAccuracy(int slot);
$statbonuses->GetAdjustedCastingSkill();
$statbonuses->GetAggroRange();
$statbonuses->GetAlterNPCLevel();
$statbonuses->GetAmbidexterity();
$statbonuses->GetAmplification();
$statbonuses->GetAntiGate();
$statbonuses->GetArcheryDamageModifier();
$statbonuses->GetAssassinate(int slot);
$statbonuses->GetAssassinateLevel(int slot);
$statbonuses->GetAssistRange();
$statbonuses->GetAvoidMeleeChance();
$statbonuses->GetAvoidMeleeChanceEffect();
$statbonuses->GetBStacker(int slot);
$statbonuses->GetBaseMovementSpeed();
$statbonuses->GetBerserkSPA();
$statbonuses->GetBindWound();
$statbonuses->GetBlockBehind();
$statbonuses->GetBrassModifier();
$statbonuses->GetBuffSlotIncrease();
$statbonuses->GetCHA();
$statbonuses->GetCHACapModifier();
$statbonuses->GetCR();
$statbonuses->GetCRCapModifier();
$statbonuses->GetCStacker(int slot);
$statbonuses->GetChannelChanceItems();
$statbonuses->GetChannelChanceSpells();
$statbonuses->GetCharmBreakChance();
$statbonuses->GetClairvoyance();
$statbonuses->GetCombatStability();
$statbonuses->GetConsumeProjectile();
$statbonuses->GetCorruption();
$statbonuses->GetCorruptionCapModifier();
$statbonuses->GetCripplingBlowChance();
$statbonuses->GetCriticalDOTChance();
$statbonuses->GetCriticalDOTDecay();
$statbonuses->GetCriticalDamageModifier(int slot);
$statbonuses->GetCriticalHealChance();
$statbonuses->GetCriticalHealDecay();
$statbonuses->GetCriticalHealOverTime();
$statbonuses->GetCriticalHitChance(int slot);
$statbonuses->GetCriticalMend();
$statbonuses->GetCriticalRegenDecay();
$statbonuses->GetCriticalSpellChance();
$statbonuses->GetDEX();
$statbonuses->GetDEXCapModifier();
$statbonuses->GetDOTCriticalDamageIncrease();
$statbonuses->GetDOTShielding();
$statbonuses->GetDR();
$statbonuses->GetDRCapModifier();
$statbonuses->GetDSMitigation();
$statbonuses->GetDSMitigationOffHand();
$statbonuses->GetDStacker(int slot);
$statbonuses->GetDamageModifier(int slot);
$statbonuses->GetDamageModifier2(int slot);
$statbonuses->GetDamageShield();
$statbonuses->GetDamageShieldSpellID();
$statbonuses->GetDamageShieldType();
$statbonuses->GetDeathSave(int slot);
$statbonuses->GetDelayDeath();
$statbonuses->GetDistanceRemoval();
$statbonuses->GetDivineAura();
$statbonuses->GetDivineSaveChance(int slot);
$statbonuses->GetDodgeChance();
$statbonuses->GetDoubleAttackChance();
$statbonuses->GetDoubleRangedAttack();
$statbonuses->GetDoubleRiposte();
$statbonuses->GetDoubleSpecialAttack();
$statbonuses->GetDualWieldChance();
$statbonuses->GetEffectiveCastingLevel();
$statbonuses->GetEndurance();
$statbonuses->GetEndurancePercentCAp(slot);
$statbonuses->GetEnduranceReduction();
$statbonuses->GetEnduranceRegen();
$statbonuses->GetExtraAttackChance();
$statbonuses->GetExtraXTargets();
$statbonuses->GetFR();
$statbonuses->GetFRCapModifier();
$statbonuses->GetFactionModifierPercent();
$statbonuses->GetFearless();
$statbonuses->GetFeignedCastOnChance();
$statbonuses->GetFinishingBlow(int slot);
$statbonuses->GetFinishingBlowLevel(int slot);
$statbonuses->GetFlatMaxHPChange();
$statbonuses->GetFlurryChance();
$statbonuses->GetFocusEffects(int slot);
$statbonuses->GetFocusEffectsWorn(int slot);
$statbonuses->GetForageAdditionalItems();
$statbonuses->GetFrenziedDevastation();
$statbonuses->GetFrontalBackstabChance();
$statbonuses->GetFrontalBackstabMinimumDamage();
$statbonuses->GetFrontalStunResist();
$statbonuses->GetGiveDoubleAttack();
$statbonuses->GetGiveDoubleRiposte(int slot);
$statbonuses->GetGivePetGroupTarget();
$statbonuses->GetGravityEffect();
$statbonuses->GetHP();
$statbonuses->GetHPPercentCap(slot);
$statbonuses->GetHPRegen();
$statbonuses->GetHPToManaConvert();
$statbonuses->GetHaste();
$statbonuses->GetHasteType2();
$statbonuses->GetHasteType3();
$statbonuses->GetHateModifier();
$statbonuses->GetHeadShot(int slot);
$statbonuses->GetHeadShotLevel(int slot);
$statbonuses->GetHealAmt();
$statbonuses->GetHealRate();
$statbonuses->GetHeroicAGI();
$statbonuses->GetHeroicCHA();
$statbonuses->GetHeroicCR();
$statbonuses->GetHeroicCorrup();
$statbonuses->GetHeroicDEX();
$statbonuses->GetHeroicDR();
$statbonuses->GetHeroicFR();
$statbonuses->GetHeroicINT();
$statbonuses->GetHeroicMR();
$statbonuses->GetHeroicPR();
$statbonuses->GetHeroicSTA();
$statbonuses->GetHeroicSTR();
$statbonuses->GetHeroicWIS();
$statbonuses->GetHitChance();
$statbonuses->GetHitChanceEffect(int slot);
$statbonuses->GetHundredHands();
$statbonuses->GetINT();
$statbonuses->GetINTCapModifier();
$statbonuses->GetIllusionPersistence();
$statbonuses->GetImmuneToFlee();
$statbonuses->GetImprovedReclaimEnergy();
$statbonuses->GetImprovedTaunt(int slot);
$statbonuses->GetIncreaseBlockChance();
$statbonuses->GetIncreaseChanceMemoryWipe();
$statbonuses->GetIncreaseRunSpeedCap();
$statbonuses->GetInhibitMelee();
$statbonuses->GetIsBlind();
$statbonuses->GetIsFeared();
$statbonuses->GetItemATKCap();
$statbonuses->GetItemHPRegenCap();
$statbonuses->GetItemManaRegenCap();
$statbonuses->GetLimitToSkill(int slot);
$statbonuses->GetMR();
$statbonuses->GetMRCapModifier();
$statbonuses->GetMagicWeapon();
$statbonuses->GetMana();
$statbonuses->GetManaAbsorbPercentDamage(int slot);
$statbonuses->GetManaPercentCap(slot);
$statbonuses->GetManaRegen();
$statbonuses->GetMasteryOfPast();
$statbonuses->GetMaxBindWound();
$statbonuses->GetMaxHP();
$statbonuses->GetMaxHPChange();
$statbonuses->GetMeleeLifetap();
$statbonuses->GetMeleeMitigation();
$statbonuses->GetMeleeMitigationEffect();
$statbonuses->GetMeleeRune(int slot);
$statbonuses->GetMeleeSkillCheck();
$statbonuses->GetMeleeSkillCheckSkill();
$statbonuses->GetMeleeThresholdGuard(int slot);
$statbonuses->GetMetabolism();
$statbonuses->GetMinimumDamageModifier(int slot);
$statbonuses->GetMitigateDOTRune(int slot);
$statbonuses->GetMitigateMeleeRune(int slot);
$statbonuses->GetMitigateSpellRune(int slot);
$statbonuses->GetMovementSpeed();
$statbonuses->GetNegateAttacks(int slot);
$statbonuses->GetNegateEffects();
$statbonuses->GetNegateIfCombat();
$statbonuses->GetNoBreakAESneak();
$statbonuses->GetOffhandRiposteFail();
$statbonuses->GetPCPetFlurry();
$statbonuses->GetPCPetRampage(int slot);
$statbonuses->GetPR();
$statbonuses->GetPRCapModifier();
$statbonuses->GetPackrat();
$statbonuses->GetParryChance();
$statbonuses->GetPercussionModifier();
$statbonuses->GetPersistentCasting();
$statbonuses->GetPetAvoidance();
$statbonuses->GetPetCriticalHit();
$statbonuses->GetPetFlurry();
$statbonuses->GetPetMaxHP();
$statbonuses->GetPetMeleeMitigation();
$statbonuses->GetProcChance();
$statbonuses->GetProcChanceSPA();
$statbonuses->GetRaiseSkillCap(int slot);
$statbonuses->GetReduceFallDamage();
$statbonuses->GetReduceTradeskillFail(int slot);
$statbonuses->GetReflectChance();
$statbonuses->GetResistFearChance();
$statbonuses->GetResistSpellChance();
$statbonuses->GetReverseDamageShield();
$statbonuses->GetReverseDamageShieldSpellID();
$statbonuses->GetReverseDamageShieldType();
$statbonuses->GetRiposteChance();
$statbonuses->GetRoot(int slot);
$statbonuses->GetRootBreakChance();
$statbonuses->GetSEResist(int slot);
$statbonuses->GetSTA();
$statbonuses->GetSTACapModifier();
$statbonuses->GetSTR();
$statbonuses->GetSTRCapModifier();
$statbonuses->GetSalvageChance();
$statbonuses->GetSanctuary();
$statbonuses->GetScreech();
$statbonuses->GetSecondaryDamageIncrease();
$statbonuses->GetSeeInvis();
$statbonuses->GetShieldBlock();
$statbonuses->GetShieldEquipDamageModifier();
$statbonuses->GetShroudOfStealth();
$statbonuses->GetSingingModifier();
$statbonuses->GetSkillAttackProc(int slot);
$statbonuses->GetSkillDamageAmount(int slot);
$statbonuses->GetSkillDamageAmount2(int slot);
$statbonuses->GetSkillDamageTaken(int slot);
$statbonuses->GetSkillModifier(int slot);
$statbonuses->GetSkillModifierMax(int slot);
$statbonuses->GetSkillProc(int slot);
$statbonuses->GetSkillProcSuccess(int slot);
$statbonuses->GetSkillReuseTime(int slot);
$statbonuses->GetSlayUndead(int slot);
$statbonuses->GetSongModifierCap();
$statbonuses->GetSongRange();
$statbonuses->GetSpellCriticalDamageIncrease();
$statbonuses->GetSpellCriticalDamageIncreaseNoStack();
$statbonuses->GetSpellDamage();
$statbonuses->GetSpellDamageShield();
$statbonuses->GetSpellOnDeath(int slot);
$statbonuses->GetSpellOnKill(int slot);
$statbonuses->GetSpellProcChance();
$statbonuses->GetSpellShield();
$statbonuses->GetSpellThresholdGuard(int slot);
$statbonuses->GetSpellTriggers(int slot);
$statbonuses->GetStrikeThrough();
$statbonuses->GetStringedModifier();
$statbonuses->GetStunBashChance();
$statbonuses->GetStunResist();
$statbonuses->GetTradeSkillMastery();
$statbonuses->GetTriggerMeleeThreshold();
$statbonuses->GetTriggerOnValueAmount();
$statbonuses->GetTriggerSpellThreshold();
$statbonuses->GetTripleAttackChance();
$statbonuses->GetTripleBackstab();
$statbonuses->GetTwoHandBluntBlock();
$statbonuses->GetUnfailingDivinity();
$statbonuses->GetVampirism();
$statbonuses->GetVoiceGraft();
$statbonuses->GetWIS();
$statbonuses->GetWISCapModifier();
$statbonuses->GetWindModifier();
$statbonuses->GetXPRateModifier();
`
```

Info

Also see Spire Quest API Explorer for latest definitions and Quest examples

```
`statbonuses:AC();
statbonuses:AGI();
statbonuses:AGICapMod();
statbonuses:AStacker(int idx);
statbonuses:ATK();
statbonuses:AbsorbMagicAtt(int idx);
statbonuses:Accuracy(int idx);
statbonuses:AggroRange();
statbonuses:AlterNPCLevel();
statbonuses:Ambidexterity();
statbonuses:Amplification();
statbonuses:AntiGate();
statbonuses:ArcheryDamageModifier();
statbonuses:Assassinate(int idx);
statbonuses:AssassinateLevel(int idx);
statbonuses:AssistRange();
statbonuses:AvoidMeleeChance();
statbonuses:AvoidMeleeChanceEffect();
statbonuses:BStacker(int idx);
statbonuses:BaseMovementSpeed();
statbonuses:BerserkSPA();
statbonuses:BindWound();
statbonuses:BlockBehind();
statbonuses:BlockNextSpell();
statbonuses:BuffSlotIncrease();
statbonuses:CHA();
statbonuses:CHACapMod();
statbonuses:CR();
statbonuses:CRCapMod();
statbonuses:CStacker(int idx);
statbonuses:ChannelChanceItems();
statbonuses:ChannelChanceSpells();
statbonuses:CharmBreakChance();
statbonuses:Clairvoyance();
statbonuses:CombatStability();
statbonuses:ConsumeProjectile();
statbonuses:Corrup();
statbonuses:CorrupCapMod();
statbonuses:CrippBlowChance();
statbonuses:CritDmgMod(int idx);
statbonuses:CriticalDoTChance();
statbonuses:CriticalDotDecay();
statbonuses:CriticalHealChance();
statbonuses:CriticalHealDecay();
statbonuses:CriticalHealOverTime();
statbonuses:CriticalHitChance(int idx);
statbonuses:CriticalMend();
statbonuses:CriticalRegenDecay();
statbonuses:CriticalSpellChance();
statbonuses:DEX();
statbonuses:DEXCapMod();
statbonuses:DR();
statbonuses:DRCapMod();
statbonuses:DSMitigation();
statbonuses:DSMitigationOffHand();
statbonuses:DStacker(int idx);
statbonuses:DamageModifier(int idx);
statbonuses:DamageModifier2(int idx);
statbonuses:DamageShield();
statbonuses:DamageShieldSpellID();
statbonuses:DamageShieldType();
statbonuses:DeathSave(int idx);
statbonuses:DelayDeath();
statbonuses:DistanceRemoval();
statbonuses:DivineAura();
statbonuses:DivineSaveChance(int idx);
statbonuses:DoTShielding();
statbonuses:DodgeChance();
statbonuses:DotCritDmgIncrease();
statbonuses:DoubleAttackChance();
statbonuses:DoubleRangedAttack();
statbonuses:DoubleRiposte();
statbonuses:DoubleSpecialAttack();
statbonuses:DualWieldChance();
statbonuses:EndPercCap(idx);
statbonuses:Endurance();
statbonuses:EnduranceReduction();
statbonuses:EnduranceRegen();
statbonuses:ExtraAttackChance();
statbonuses:FR();
statbonuses:FRCapMod();
statbonuses:FactionModPct();
statbonuses:Fearless();
statbonuses:FeignedCastOnChance();
statbonuses:FinishingBlow(int idx);
statbonuses:FinishingBlowLvl(int idx);
statbonuses:FlatMaxHPChange();
statbonuses:FlurryChance();
statbonuses:FocusEffects(int idx);
statbonuses:FocusEffectsWorn(int idx);
statbonuses:ForageAdditionalItems();
statbonuses:FrenziedDevastation();
statbonuses:FrontalBackstabChance();
statbonuses:FrontalBackstabMinDmg();
statbonuses:FrontalStunResist();
statbonuses:GetXPRateMod();
statbonuses:GiveDoubleAttack();
statbonuses:GiveDoubleRiposte(int idx);
statbonuses:GivePetGroupTarget();
statbonuses:GravityEffect();
statbonuses:HP();
statbonuses:HPPercCap(idx);
statbonuses:HPRegen();
statbonuses:HPToManaConvert();
statbonuses:HSLevel(int idx);
statbonuses:HeadShot(int idx);
statbonuses:HealAmt();
statbonuses:HealRate();
statbonuses:HeroicAGI();
statbonuses:HeroicCHA();
statbonuses:HeroicCR();
statbonuses:HeroicCorrup();
statbonuses:HeroicDEX();
statbonuses:HeroicDR();
statbonuses:HeroicFR();
statbonuses:HeroicINT();
statbonuses:HeroicMR();
statbonuses:HeroicPR();
statbonuses:HeroicSTA();
statbonuses:HeroicSTR();
statbonuses:HeroicWIS();
statbonuses:HitChance();
statbonuses:HitChanceEffect(int idx);
statbonuses:HundredHands();
statbonuses:INT();
statbonuses:INTCapMod();
statbonuses:IllusionPersistence();
statbonuses:ImmuneToFlee();
statbonuses:ImprovedReclaimEnergy();
statbonuses:ImprovedTaunt(int idx);
statbonuses:IncreaseBlockChance();
statbonuses:IncreaseChanceMemwipe();
statbonuses:IncreaseRunSpeedCap();
statbonuses:IsBlind();
statbonuses:IsFeared();
statbonuses:ItemATKCap();
statbonuses:ItemHPRegenCap();
statbonuses:ItemManaRegenCap();
statbonuses:LimitToSkill(int idx);
statbonuses:MR();
statbonuses:MRCapMod();
statbonuses:MagicWeapon();
statbonuses:Mana();
statbonuses:ManaAbsorbPercentDamage(int idx);
statbonuses:ManaPercCap(idx);
statbonuses:ManaRegen();
statbonuses:MasteryofPast();
statbonuses:MaxBindWound();
statbonuses:MaxHP();
statbonuses:MaxHPChange();
statbonuses:MeleeLifetap();
statbonuses:MeleeMitigation();
statbonuses:MeleeMitigationEffect();
statbonuses:MeleeRune(int idx);
statbonuses:MeleeSkillCheck();
statbonuses:MeleeSkillCheckSkill();
statbonuses:MeleeThresholdGuard(int idx);
statbonuses:Metabolism();
statbonuses:MinDamageModifier(int idx);
statbonuses:MitigateDotRune(int idx);
statbonuses:MitigateMeleeRune(int idx);
statbonuses:MitigateSpellRune(int idx);
statbonuses:NegateAttacks(int idx);
statbonuses:NegateEffects();
statbonuses:NegateIfCombat();
statbonuses:NoBreakAESneak();
statbonuses:OffhandRiposteFail();
statbonuses:PC_Pet_Flurry();
statbonuses:PC_Pet_Rampage(int idx);
statbonuses:PR();
statbonuses:PRCapMod();
statbonuses:Packrat();
statbonuses:ParryChance();
statbonuses:PersistantCasting();
statbonuses:PetAvoidance();
statbonuses:PetCriticalHit();
statbonuses:PetFlurry();
statbonuses:PetMaxHP();
statbonuses:PetMeleeMitigation();
statbonuses:ProcChance();
statbonuses:ProcChanceSPA();
statbonuses:RaiseSkillCap(int idx);
statbonuses:ReduceFallDamage();
statbonuses:ReduceTradeskillFail(int idx);
statbonuses:ResistFearChance();
statbonuses:ResistSpellChance();
statbonuses:ReverseDamageShield();
statbonuses:ReverseDamageShieldSpellID();
statbonuses:ReverseDamageShieldType();
statbonuses:RiposteChance();
statbonuses:Root(int idx);
statbonuses:RootBreakChance();
statbonuses:SEResist(int idx);
statbonuses:STA();
statbonuses:STACapMod();
statbonuses:STR();
statbonuses:STRCapMod();
statbonuses:SalvageChance();
statbonuses:Sanctuary();
statbonuses:Screech();
statbonuses:SecondaryDmgInc();
statbonuses:SeeInvis();
statbonuses:ShieldBlock();
statbonuses:ShieldEquipDmgMod();
statbonuses:ShroudofStealth();
statbonuses:SkillAttackProc(int idx);
statbonuses:SkillDamageAmount(int idx);
statbonuses:SkillDamageAmount2(int idx);
statbonuses:SkillDmgTaken(int idx);
statbonuses:SkillProc(int idx);
statbonuses:SkillProcSuccess(int idx);
statbonuses:SkillReuseTime(int idx);
statbonuses:SlayUndead(int idx);
statbonuses:SongRange();
statbonuses:SpellCritDmgIncNoStack();
statbonuses:SpellCritDmgIncrease();
statbonuses:SpellDamageShield();
statbonuses:SpellDmg();
statbonuses:SpellOnDeath(int idx);
statbonuses:SpellOnKill(int idx);
statbonuses:SpellProcChance();
statbonuses:SpellShield();
statbonuses:SpellThresholdGuard(int idx);
statbonuses:SpellTriggers(int idx);
statbonuses:StrikeThrough();
statbonuses:StunBashChance();
statbonuses:StunResist();
statbonuses:TradeSkillMastery();
statbonuses:TriggerMeleeThreshold();
statbonuses:TriggerOnValueAmount();
statbonuses:TriggerSpellThreshold();
statbonuses:TripleAttackChance();
statbonuses:TripleBackstab();
statbonuses:TwoHandBluntBlock();
statbonuses:UnfailingDivinity();
statbonuses:Vampirism();
statbonuses:VoiceGraft();
statbonuses:WIS();
statbonuses:WISCapMod();
statbonuses:adjusted_casting_skill();
statbonuses:brassMod();
statbonuses:effective_casting_level();
statbonuses:extra_xtargets();
statbonuses:haste();
statbonuses:hastetype2();
statbonuses:hastetype3();
statbonuses:hatemod();
statbonuses:inhibitmelee();
statbonuses:movementspeed();
statbonuses:percussionMod();
statbonuses:reflect_chance();
statbonuses:singingMod();
statbonuses:skillmod(int idx);
statbonuses:skillmodmax(int idx);
statbonuses:songModCap();
statbonuses:stringedMod();
statbonuses:windMod();
`
```

---

## Item Hand-In

*Source: quest-api/npc-item-handin/index.html*

# Item Hand-In

Info

Examples are top of page for quick accessibility, more information on the hand-in system can be found below

## Examples

Simple Hand-inMoneyMoney (All)Item + MoneyHand-In TableItem StacksItem Stacks (Looped)Multi-Questing

LuaPerl

```
`function event_trade(e)
 if (eq.handin({[1001] = 1})) then -- Cloth Cap (1001)
 e.self:Say("Thank you for the cloth cap!");
 end
end
`
```

```
`sub EVENT_ITEM {
 if (quest::handin({1001 => 1})) { # Cloth Cap (1001)
 quest::say("Thank you for the cloth cap!");
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 if (eq.handin({platinum = 1000})) then
 e.self:Say("Thank you for the platinum!");
 end
end
`
```

```
`sub EVENT_ITEM {
 if (quest::handin({"platinum" => 1000})) {
 quest::say("Thank you for the platinum!");
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 if (eq.handin({platinum = 1000, gold = 100, silver = 100, copper = 100})) then
 e.self:Say("Thank you for the platinum, gold, silver and copper!");
 end
end
`
```

```
`sub EVENT_ITEM {
 if (quest::handin({"platinum" => 1000, "gold" => 100, "silver" => 100, "copper" => 100})) {
 quest::say("Thank you for the platinum, gold, silver and copper!");
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 if (eq.handin({[1001] = 1, platinum = 1000})) then -- Cloth Cap (1001)
 e.self:Say("Thank you for the cloth cap and platinum!");
 end
end
`
```

```
`sub EVENT_ITEM {
 if (quest::handin({1001 => 1, "platinum" => 1000})) { # Cloth Cap (1001)
 quest::say("Thank you for the cloth cap and platinum!");
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 local handin_requirements = {
 { 
 required_handin = { [1001] = 1, [13005] = 4 }, -- Cloth cap, Iron ration (4)
 exp = 100,
 result_item = 2300, -- Journeyman's Boots
 message = "Thank you!"
 },
 { 
 required_handin = { platinum = 10000 },
 exp = 100,
 result_item = 13401, -- Manastone
 message = "Thank you!"
 }
 }

 for _, handin in ipairs(handin_requirements) do
 if eq.handin(handin.required_handin) then
 if handin.message then e.self:Say(handin.message) end
 if handin.result_item then e.other:SummonItem(handin.result_item) end
 if handin.exp then e.other:AddEXP(handin.exp) end
 return
 end
 end
end
`
```

```
`sub EVENT_ITEM {
 my @handin_requirements = (
 { 
 required_handin => { 1001 => 1, 13005 => 4 }, # cloth cap, iron ration (4)
 exp => 100,
 result_item => 2300, # Journeyman's Boots
 message => "Thank you!"
 },
 { 
 required_handin => { "platinum" => 10000 },
 exp => 100,
 result_item => 13401, # Manastone
 message => "Thank you!"
 }
 );

 foreach my $handin (@handin_requirements) {
 if (quest::handin($handin->{required_handin})) {
 quest::say($handin->{message}) if $handin->{message};
 quest::summonitem($handin->{result_item}) if $handin->{result_item};
 quest::exp($handin->{exp}) if $handin->{exp};
 return;
 }
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 if (eq.handin({[13005] = 20})) then -- Iron Rations (13005) (20 count)
 e.self:Say("Thank you for all of the rations! I was SO hungry.");
 end
end
`
```

```
`sub EVENT_ITEM {
 if (quest::handin({13005 => 20})) { # Iron Rations (13005) (20 count)
 quest::say("Thank you for all of the rations! I was SO hungry.");
 }
}
`
```

LuaPerl

```
`function event_trade(e)
 local count = 0
 while (eq.handin({[13005] = 1})) do
 count = count + 1
 end
 if count > 0 then
 e.self:Say("Thank you for the " .. count .. " rations! We could feed a village!")
 end
end
`
```

```
`sub EVENT_ITEM {
 my $count = 0;
 while (quest::handin({13005 => 1})) {
 $count++;
 }
 if ($count > 0) {
 quest::say("Thank you for the $count rations! We could feed a village!");
 }
}
`
```

Info

Scenario 1) Player hands in a stack of 1,000 iron rations, they get processed one for each in the stack handed in

NPC says, 'Thank you for the 1000 rations! We could feed a village!'

Info

Scenario 2) Player hands in multiple different stacks equalling 1,055 rations.

NPC says, 'Thank you for the 1055 rations! We could feed a village!'

Info

**MultiQuestEnable** must be set on spawn or set on the npc_types field **multiquest_enabled**

LuaPerl

```
`function event_spawn(e)
 e.self:MultiQuestEnable();
end

function event_trade(e)
 if (eq.handin({[12268] = 1, [7100] = 1, platinum = 325})) then
 e.self:Say("The time to trade has come!! I am now rich and you are now fast. Take the Journeyman Boots and run like the wind.");
 e.other:QuestReward(e.self, 0, 0, 0, 0, 2300, 1250);
 end
end
`
```

```
`sub EVENT_SPAWN {
 $npc->MultiQuestEnable();
}

sub EVENT_ITEM {
 if (quest::handin({12268 => 1, 7100 => 1, "platinum" => 325})) {
 quest::say("The time to trade has come!! I am now rich and you are now fast. Take the Journeyman Boots and run like the wind.");
 quest::summonitem(2300);
 quest::exp(1250);
 }
}
`
```

## Overhaul Overview

Info

This overhaul simplifies item hand-ins, unifies handling across scripting languages, prevents item loss, improves logging for debugging, and adds multi-quest support. Users and developers can expect a more stable and predictable experience when handling items in quests.

### Improvements (Why)

| 

Feature 
| Improvement Summary 

| **Unified Hand-in Handling** 
| Standardized item/money hand-ins across Lua & Perl. 

| **Item Loss Prevention** 
| Ensures items aren't lost due to missing scripts or errors. 

| **Full Item Instance Return** 
| Returns handed-in items with augments, serials, and properties intact. 

| **Multi-Quest Support** 
| NPCs can handle multiple valid hand-in combinations. 

| **Stacked Item Processing** 
| Supports large stack hand-ins without loss. 

| **Improved Event Tracking** 
| Captures all hand-ins for better debugging. 

| **Enhanced Logging** 
| Introduced **Logs::NpcHandin** for real-time tracking. 

| **Pet Hand-in Safety** 
| Prevents accidental item loss to pets. 

| **Better Quest Consistency** 
| Centralized logic reduces discrepancies between scripting languages. 

| **Catch-All Disable Option** 
| Configurable rule to return unhandled items. 

### Unified Handling Across Perl and Lua

- Previously, hand-in logic was separately maintained in both Perl and Lua.

- Now, both scripting languages pass through existing plugins and are handled directly in the source.

- This reduces potential defects, simplifies feature additions, and ensures consistent behavior.

### Improved Player Event Tracking

- Ensures that every item hand-in is captured, even if the quest does not explicitly handle it.

- Provides better player event records for debugging and tracking purposes.

### Consistent Handling of Hand-ins

- Item hand-ins are now processed the same way in both Perl and Lua.

- Money hand-ins follow the same process in both scripting languages.

- NPCs that support multiple simultaneous quests are now handled natively in the source.

- The hand-in logic has been simplified for better maintainability.

- Comprehensive logging allows for deeper debugging of hand-in issues.

### Multi-Quest NPC Support

- A new `multiquest_enabled` column has been added to the `npc_types` database table.

- This allows NPCs to accept multiple quest item combinations natively without requiring external script logic.

- The system ensures the correct quest is matched, and items are not lost due to ambiguous hand-ins.

- NPCs that can accept multiple different item sets will now function correctly.

- If a valid hand-in combination is found, the NPC will proceed as expected.

- If no valid combination is found, all handed-in items are returned.

- The feature is turned on per-NPC either through the `npc_types` field `multiquest_enabled` or by calling **MultiQuestEnable()** via NPC method

## Logging Enhancements

- A new logging category **Logs::NpcHandin** has been introduced.

- This captures all item hand-ins, making it easier to debug and track player transactions.

- Logs can be output to both the console and GM chat for real-time monitoring.

## Always Return Items

Part of the fundamental change in the new system is that instead of only conditionally returning items, sometimes in scripts, sometimes in the source, we **always** return items unless the script or source specifically **consumed** the item handed in.

Warning

This can sometimes create issues if you wrote your own way of handling items. If you want to disable this behavior (not recommended) you can do so with rule **Items:AlwaysReturnHandins**

## Related Plugin Changes

This update includes corresponding changes to quest plugins. See the associated plugin update: ProjectEQ Quest Plugin Changes #1403

---

## Quest Loading

*Source: quest-api/quest-loading/index.html*

# Quest Loading

Info

This page outlines how quests are loaded by the server

## Notes

The `[ext]` refers to file extension--either .pl or .lua. 

It should be noted that a .lua file takes precedence over a .pl file of the same name.

## Global Scripts

Global scripts were designed to run on top of the scripts mentioned above, meaning if you have a player script in a zone directory and a global player script, they will both execute and not interfere with each other

| 

Type 
| Script Name 

| Bots 
| quests/global/global_bot.ext 

| Mercenaries 
| quests/global/global_merc.ext 

| NPCs 
| quests/global/global_npc.ext 

| Players 
| quests/global/global_player.ext 

The `global_npc.ext` scripts run in a zone wide context. All NPCs in the same zone can see variables, modify them, and see changes made by the others

## Bots

In order of operations, a Bot's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zoneshortname/v[instance_version]/bot.[ext] 
| quests/qeynos/v0/bot.pl 

| quests/zoneshortname/bot_v[instance_version].[ext] 
| quests/qeynos/bot_v1.pl 

| quests/zoneshortname/bot.[ext] 
| quests/qeynos/bot.lua 

| quests/global/bot.[ext] 
| quests/global/bot.pl 

## Encounters

Encounters will load a script on the first event that triggers them and will load one and only one from the following location.

In order of operations, an Encounter's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zone/v[instance_version]/encounters/name.[ext] 
| quests/qeynos/v0/encounters/name.pl 

| quests/zone/encounters/name.[ext] 
| quests/qeynos/encounters/name.lua 

| quests/global/encounters/name.[ext] 
| quests/global/encounters/name.pl 

## Items

Items will load a script on the first event that triggers them and will load one and only one from the following location.

In order of operations, an Item's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zone/v[instance_version]/items/item_script.[ext] 
| quests/qeynos/v0/items/script_30057.pl 

| quests/zone/items/item_script.[ext] 
| quests/qeynos/items/script_30057.pl 

| quests/global/items/item_script.[ext] 
| quests/global/items/script_30057.lua 

| quests/zone/items/default.[ext] 
| quests/qeynos/items/default.lua 

| quests/global/items/default.[ext] 
| quests/global/items/default.pl 

## Mercenaries

In order of operations, a Mercenary's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zoneshortname/v[instance_version]/merc.[ext] 
| quests/qeynos/v0/merc.pl 

| quests/zoneshortname/merc_v[instance_version].[ext] 
| quests/qeynos/merc_v1.pl 

| quests/zoneshortname/merc.[ext] 
| quests/qeynos/merc.lua 

| quests/global/merc.[ext] 
| quests/global/merc.pl 

## NPCs

These scripts run in a context based on NPC ID or NPC name.

All NPCs with the same NPC ID or name can see variables, modify them, and see changes made by the others.

If you need variables that are specific to each instance of an NPC ID or name, data buckets or entity variables can be used.

In order of operations, an NPC's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zoneshortname/v[instance_version]/npc_id.[ext] 
| quests/qeynos/v0/1173.lua 

| quests/zoneshortname/v[instance_version]/npc_name.[ext] 
| quests/qeynos/v0/Trumpy_Irontoe.pl 

| quests/zoneshortname/npc_id.[ext] 
| quests/qeynos/1173.lua 

| quests/zoneshortname/npc_name.[ext] 
| quests/qeynos/Trumpy_Irontoe.pl 

| quests/global/npc_id.[ext] 
| quests/global/1234.pl 

| quests/global/npc_name.[ext] 
| quests/global/Nexus_Scion.lua 

| quests/zoneshortname/v[instance_version]/default.[ext] 
| quests/tutorialb/v0/default.pl 

| quests/zoneshortname/default.[ext] 
| quests/tutorialb/default.pl 

| quests/global/default.[ext] 
| quests/global/default.lua 

## Players

In order of operations, a Player's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zoneshortname/v[instance_version]/player.[ext] 
| quests/qeynos/v0/player.pl 

| quests/zoneshortname/player_v[instance_version].[ext] 
| quests/qeynos/player_v1.pl 

| quests/zoneshortname/player.[ext] 
| quests/qeynos/player.lua 

| quests/global/player.[ext] 
| quests/global/player.pl 

## Spells

Spells will load a script on the first event that triggers them and will load one and only one from the following location.

In order of operations, a Spell's script will be dictated by the first script that it finds below:

| 

Hierarchy 
| Example 

| quests/zone/v[instance_version]/spells/spell_id.[ext] 
| quests/qeynos/v0/spells/1234.pl 

| quests/zone/spells/spell_id.[ext] 
| quests/qeynos/spells/1234.pl 

| quests/global/spells/spell_id.[ext] 
| quests/global/spells/1234.lua 

| quests/zone/spells/default.[ext] 
| quests/qeynos/spells/default.lua 

| quests/global/spells/default.[ext] 
| quests/global/spells/default.pl

---

## Client Methods

*Source: server/expedition-system/quest-api-lua/client-methods/index.html*

# Client Methods

## `void` AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid = "")

Assigns the specified lockout to the client. If the client already has the lockout it's replaced with this one. If a uuid isn't supplied one is generated

```
`e.other:AddExpeditionLockout("Anguish, the Fallen Palace", "Ture", 300)
`
```

## `void` AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid = "")

Adds `seconds` to the specified client lockout duration. If `seconds` is negative then the duration of the lockout is reduced (limited to 0).

If the client does not have the lockout and `seconds` is positive, a new lockout is created with the specified uuid. If a uuid isn't supplied one is generated.

```
` -- Decrease Ture lockout by 5 minutes
e.other:AddExpeditionLockoutDuration("Anguish, the Fallen Palace", "Ture", -300)
 -- Increase keldovan lockout by 5 minutes
e.other:AddExpeditionLockoutDuration("Anguish, the Fallen Palace", "Keldovan the Harrier", 300)
`
```

## `Expedition*` CreateExpedition(string zone_short_name, int zone_version, int duration, string expedition_name, int min_players, int max_players, bool disable_messages = false)

This initiates an expedition creation request by the client. All members in the client's current group or raid (if in one) are validated for the expedition request. On success an expedition object is returned and all members of the client's group/raid are added to the expedition. Returns nullptr if the request is rejected

This method takes both the instance zone details and expedition details

Passing `true` for the optional `disable_messages` parameter disables all expedition rejection messages sent to the leader (member lockout conflicts, etc)

Note: Expedition creation follows behavior introduced with the live September 16, 2020 patch. The expedition may be created even if the group or raid exceeds the expedition's max player requirement, but only members up to the max are added to it. Players are added based on priority of raid group number followed by ungrouped players. The raid leader is added first. Players inside groups or raid groups may not be added in displayed order.

```
`function event_say(e)
 if e.message == "request" then
 local expedition = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if expedition.valid then
 eq.debug("Expedition creation was succesful")
 end
 end
end
`
```

## `Expedition*` CreateExpedition(LUA_TTABLE expedition_info)

This is an alternate expedition request method that uses a table containing all creation data.

This table supports adding all dynamic zone data at creation time rather than post-creation. This has the benefit of only hitting the database once to insert the expedition's dz data.

Option data is placed in the table as hash keys. The `expedition` and `instance` keys are required to define creation

Keys marked as `optional` may be excluded if not used

| 

key name 
| supported keys 
| description 

| `expedition` 
| name, min_players, max_players, disable_messages 
| expedition options 

| `instance` 
| zone, version, duration 
| dz instance details 

| `compass` 
| zone, x, y, z 
| `(optional)` compass coordinates 

| `safereturn` 
| zone, x, y, z, h 
| `(optional)` safe return coordinates 

| `zonein` 
| x, y, z, h 
| `(optional)` dz zone-in coordinates 

#### expedition keys

| 

key 
| type 
| description 

| `name` 
| string 
| expedition name 

| `min_players` 
| int 
| minimum players to request expedition 

| `max_players` 
| int 
| maximum expedition players 

| `disable_messages` 
| bool 
| `(optional)` disable leader messages on request 

#### instance keys

| 

key 
| type 
| description 

| `zone` 
| int or string 
| zone id or zone short_name of the expedition's dz instance 

| `version` 
| int 
| dz instance version 

| `duration` 
| int 
| dz expire time (seconds) 

#### compass, safereturn, and zonein keys

| 

key 
| type 
| description 

| `zone` 
| int or string 
| zone id or zone short name 

| `x` 
| float 
| `(optional)` x coordinate (default: `0`) 

| `y` 
| float 
| `(optional)` y coordinate (default: `0`) 

| `z` 
| float 
| `(optional)` z coordinate (default: `0`) 

| `h` 
| float 
| `(optional)` heading (default: `0`) 

```
`local anguish_info = {
 expedition = { name="Anguish, the Fallen Palace", min_players=6, max_players=54 },
 instance = { zone="anguish", version=0, duration=21600 },
 compass = { zone=300, x=1353.15, y=1712.19, z=109.001 },
 safereturn = { zone="wallofslaughter", x=1349.13, y=1715.00, z=123.81, h=0 },
 zonein = { x=-9, y=-2466, z=-79, h=0 }
}
local dz = e.other:CreateExpedition(anguish_info)
if dz.valid then
 eq.debug("Expedition creation was successful")
end
`
```

## `Expedition*` GetExpedition()

Return client's current expedition if client is in one, otherwise returns nullptr

```
`local dz = e.other:GetExpedition()
if not dz.valid then
 eq.debug("Client is not in an expedition")
end
`
```

## `LUA_TTABLE` GetExpeditionLockouts(string expedition_name = "")

Returns a hash table keyed on expedition name containing an event hash table with client's current lockouts. If expedition_name is supplied then just an event hash table is returned for that expedition. The value of event hash tables is the lockout's remaining duration. Returns empty table if client doesn't have any lockouts

```
`local lockouts = e.other:GetLockouts()
for expedition_name,event_lockouts in pairs(lockouts) do
 for event_name,remaining in pairs(event_lockouts) do
 eq.debug(string.format("expedition: (%s) event: (%s) remaining: (%s) s",
 expedition_name, event_name, remaining))
 end
end
`
```

```
`-- filtered on expedition name
local lockouts = e.other:GetLockouts("Anguish, the Fallen Palace")
for event_name,remaining in pairs(lockouts) do
 eq.debug(string.format("Anguish lockouts event: (%s) remaining: (%s) s",
 event_name, remaining))
end
`
```

## `string` GetLockoutExpeditionUUID(string expedition_name, string event_name)

Returns uuid string of the expedition the lockout was received in. Returns an empty string if client doesn't have the lockout

```
`local uuid = e.other:GetLockoutExpeditionUUID("Anguish, the Fallen Palace", "Ture")
if uuid ~= "" then
 eq.debug(string.format("Client received lockout in expedition uuid %s", uuid))
end
`
```

## `bool` HasExpeditionLockout(string expedition_name, string event_name)

Returns true of the client has the lockout, false otherwise

```
`local has_lockout = e.other:HasExpeditionLockout("Anguish, the Fallen Palace", "Ture")
if has_lockout then
 eq.debug("Client has the lockout")
else
 eq.debug("Client does not have the lockout")
end
`
```

## `void` MovePCDynamicZone(int zone_id, int zone_version = -1, bool msg_if_invalid = true)

## `void` MovePCDynamicZone(string zone_short_name, int zone_version = -1, bool msg_if_invalid = true)

Attempts to move the client to the specified zone if the client is part of a system (expedition or otherwise) with an associated dynamic zone instance in the target zone.

If a valid `zone_version` (0 or higher) is supplied then the move will only be allowed if a player's dz to `zone_id` is also for that `zone_version`.

If the client is not associated with a dz for the specified zone, the client is not moved. If `msg_if_invalid` is true (default) the client is sent a message that the way is blocked.

If the client is associated with multiple dz systems to the same zone, the client's `DynamicZoneSwitchListWnd` interface window is invoked to allow the client to choose which dynamic zone to enter.

On success, the player is moved to the dynamic zone's zone in coordinates (set on creation or afterwards) If no zone in coordinates are set, the player is moved to the zone's default safe coords.

`MovePCInstance` should be used if finer control of zone in location is required, but care must be taken to validate the client is part of an instance for the target zone

```
`e.other:MovePCDynamicZone(317) -- by zone id
e.other:MovePCDynamicZone("anguish") -- by zone short name
`
```

## `void` RemoveAllExpeditionLockouts(string expedition_name = "")

Removes all expedition lockouts from the character, optionally filtered on an expedition name

```
`-- removes all lockouts
e.other:RemoveAllExpeditionLockouts(e.other:CharacterID())
-- removes all anguish lockouts
e.other:RemoveAllExpeditionLockouts(e.other:CharacterID(), "Anguish, the Fallen Palace")
`
```

## `void` RemoveExpeditionLockout(string expedition_name, string event_name)

Removes the specified lockout from the character. No-op if the character doesn't have the lockout

```
`e.other:RemoveExpeditionLockout("Anguish, the Fallen Palace", "Ture")
`
```

---

## Example

*Source: server/expedition-system/quest-api-lua/example/index.html*

# Example

This is a full example to demonstrate usage. Guard Pineshade at the orc lift in gfaydark provides an expedition to crushbone

`gfaydark/Guard_Pineshade.lua`

```
`local expedition_name = "Crushbone, DVinn's Stronghold"

local expedition_info = {
 expedition = { name=expedition_name, min_players=1, max_players=6 },
 instance = { zone="crushbone", version=0, duration=3600 },
 compass = { zone="gfaydark", x=238.00, y=987.00, z=-24.90 }, -- pointing to guard pineshade
 safereturn = { zone="gfaydark", x=245.84, y=987.93, z=-27.6, h=484.0 }, -- at orc lift in gfay
 zonein = { x=479.44, y=-500.18, z=5.75, h=421.8 } -- on bridge
}

function event_say(e)
 if e.message:findi("hail") then
 local dz = e.other:GetExpedition()
 if dz.valid and dz:GetName() == expedition_name then
 e.self:Say("Tell me when you're [" .. eq.say_link("ready") .. "] to enter")
 else
 e.self:Say("You may [" .. eq.say_link("request") .. "] the expedition")
 end
 elseif e.message:findi("request") then
 local dz = e.other:CreateExpedition(expedition_info) -- request expedition
 if dz.valid then
 dz:AddReplayLockout(7200) -- immediately add a 2 hour replay lockout on creation
 e.self:Say("Tell me when you're [" .. eq.say_link("ready") .. "] to enter")
 end
 elseif e.message:findi("ready") then
 e.other:MovePCDynamicZone("crushbone")
 end
end
`
```

`crushbone/script_init.lua`

```
`local dz = eq.get_expedition()
if dz.valid then
 -- bind unique npc types to events to prevent any looting exploits
 dz:SetLootEventByNPCTypeID(58032, "Emperor Crush") -- npc: Emperor_Crush
 dz:SetLootEventByNPCTypeID(317109, "Ambassador Mata Muram") -- npc: Overlord_Mata_Muram

 -- spawn any events that the expedition doesn't have a lockout for
 -- (can't depop npcs that spawn by default from this script, handle elsewhere)
 if not dz:HasLockout("Ambassador Mata Muram") then
 eq.spawn2(317109, 0, 0, 130.78, -149.09, 88.70, 270.8) -- npc: Overlord_Mata_Muram
 end
end
`
```

`crushbone/Emperor_Crush.lua`

```
`function event_spawn(e)
 local dz = eq.get_expedition()
 if dz.valid and dz:HasLockout("Emperor Crush") then
 eq.depop()
 end
end

function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 dz:AddLockout("Emperor Crush", 86400) -- 1 day lockout
 end
end
`
```

`crushbone/Overlord_Mata_Muram.lua`

```
`function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 dz:AddLockout("Ambassador Mata Muram", 604800) -- 7 day lockout

 -- spawn a chest and bind its spawn id to the event to prevent loot exploits
 local chest = eq.spawn2(893, 0, 0, e.self:GetX(), e.self:GetY(), e.self:GetZ(), e.self:GetHeading())
 dz:SetLootEventBySpawnID(chest:GetID(), "Ambassador Mata Muram")
 end
end
`
```

---

## Expedition Methods

*Source: server/expedition-system/quest-api-lua/expedition-methods/index.html*

# Expedition Methods

## `void` AddLockout(string event_name, uint32 seconds_duration) 

Adds an event lockout timer to the expedition with the specified duration.

The lockout is added to all current members of the expedition whether they're inside the zone or not. This also adds the lockout to any clients inside the dynamic zone that are not part of the expedition (in the event that they've quit the expedition and haven't been teleported out yet)

The lockout is also stored internally in the expedition. New members added to the expedition will receive these lockouts once they zone into the expedition's dynamic zone.

The lockout replaces any existing lockout held by the expedition and members.

The lockout is assigned the current expedition's internal uuid for tracking.

Note: The source adds 60s to the lockout timer sent to clients to compensate for the client displaying lockouts rounded down to the nearest minute. If adding lockout times using live packet data subtract 60s from the time (live adds 60s as well)

```
`function event_death(e)
 local expedition = eq.get_expedition() -- current instance's expedition (we should be inside a dz)
 if not expedition.valid then
 eq.debug("report a bug") -- possible fallback would be to manually iterate clients and add lockouts
 else
 expedition:AddLockout("Keldovan the Harrier", 86400) -- add a 1 day lockout
 end
end
`
```

## `void` AddLockoutDuration(string event_name, int seconds, bool members_only = true) 

Adds duration to existing member lockouts for the event. If `seconds` is negative then lockout duration is reduced.

Unlike UpdateLockoutDuration which applies a static lockout duration to all members based on the expedition's internal lockout, this modifies each member's existing lockout duration separately.

If a member does not have the specified event lockout and `seconds` is positive, the lockout is added to the member with the current expedition's uuid.

By default this only updates expedition members. Passing `false` for `members_only` will update the expedition's internal lockout duration as well which will affect any future members added to the expedition.

Non-expedition members inside the expedition's dynamic zone instance are always updated

```
`-- inside dz, after killing some progression npcs
function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 -- add durations to each member's current event lockout when specific npcs killed
 -- the expedition's lockout is unaffected, new members will receive original lockout
 if e.self:GetNPCTypeID() == 294042 then
 dz:AddLockout("Some Event", 25200) -- create 7 hour lockout when this npc is killed
 elseif e.self:GetNPCTypeID() == 294043 then
 dz:AddLockoutDuration("Some Event", 57600) -- add 16 hours when this npc is killed
 end
 end
end
`
```

## `void` AddReplayLockout(int seconds_duration) 

Adds a `Replay Timer` lockout to the expedition. This is a shortcut alternative to adding the lockout by name through the `AddLockout` method.

Replay Timer's use a hardcoded event name and are used as a lockout against requesting the expedition itself.

Unlike normal event lockouts, any members added to the expedition after a replay timer has been assigned will receive the lockout immediately with a reset expiration timer based on the original duration.

```
`function event_say(e)
 if e.message == "request" then
 local expedition = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if expedition.valid then
 eq.debug("Expedition creation was succesful")
 expedition:AddReplayLockout(7200) -- 2 hour request lockout
 end
 end
end
`
```

## `void` AddReplayLockoutDuration(int seconds, bool members_only = true) 

Adds duration to expedition's `Replay Timer` lockout. See AddLockoutDuration

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("ikkinz", 0, 21600, "Ikkinz, Chambers of Singular Might", 1, 6)
 if dz.valid then
 expedition:AddReplayLockout(3600) -- 1 hour replay lockout
 end
 end
end

-- inside dz, after killing some progression npcs
function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 if e.self:GetNPCTypeID() == 294042 then
 dz:AddReplayLockoutDuration(25200) -- add 7 hours to replay lockout when this npc is killed
 elseif e.self:GetNPCTypeID() == 294043 then
 -- add 16 hours to replay lockout when this npc is killed
 -- expedition lockout is unaffected, new members will receive the original (7 hours - elapsed)
 dz:AddReplayLockoutDuration(57600)
 end
 end
end
`
```

## `uint32_t` GetDynamicZoneID() 

Returns the expedition's dynamic zone id

```
`local dz_id = expedition:GetDynamicZoneID()
`
```

## `uint32_t` GetID() 

Returns the expedition's id

```
`local id = expedition:GetID()
`
```

## `int` GetInstanceID() 

Returns the expedition's dynamic zone instance id

```
`local instance_id = expedition:GetInstanceID()
`
```

## `string` GetLeaderName() 

Returns the expedition's current leader name

```
`local leader_name = expedition:GetLeaderName()
`
```

## `LUA_TTABLE` GetLockouts() 

Returns a table containing the expedition's current internal lockouts and time remaining. This includes lockouts that were inherited by the leader on creation and not just lockouts assigned during the current expedition.

```
`local lockouts = expedition:GetLockouts()
for event_name,remaining in pairs(lockouts) do
 eq.debug(string.format("event: (%s) remaining: (%s)s", event_name, remaining))
end
`
```

## `string` GetLootEventByNPCTypeID(uint32 npc_type_id) 

## `string` GetLootEventBySpawnID(uint32 spawn_id) 

Returns an event name associated with an npc type id or spawn id set by the SetLootEventByNPCTypeID or SetLootEventBySpawnID apis.

Returns an empty string if no event set

Important: This is only valid inside the expedition's dynamic zone instance

```
`function event_death(e)
 local npc_type_id = e.self:GetNPCTypeID()
 local spawn_id = e.self:GetID()
 local dz = eq.get_expedition() -- current instance's expedition (we should be inside a dz)
 if dz.valid then
 local event_name = dz:GetLootEventByNPCTypeID(npc_type_id)
 eq.debug(string.format("Npc type (%s) was associated with event (%s)", npc_type_id, event_name))
 event_name = dz:GetLootEventBySpawnID(spawn_id)
 eq.debug(string.format("This npc entity id (%s) was associated with event (%s)", spawn_id, event_name))
 end
end
`
```

## `int` GetMemberCount() 

Returns number of members in expedition

```
`local count = dz:GetMemberCount()
`
```

## `LUA_TTABLE` GetMembers() 

Returns a Lua table containing member names and character ids

```
`local members = dz:GetMembers()
for name,id in pairs(members) do
 eq.debug(string.format("Member name (%s) character id (%s)", name, id))
end
`
```

## `string` GetName() 

Returns name of the expedition

```
`local expedition_name = dz:GetName()
`
```

## `int` GetSecondsRemaining() 

Returns seconds remaining until expedition's dynamic zone expires

```
`local seconds_remaining = dz:GetSecondsRemaining()
`
```

## `string` GetUUID() 

Returns expedition's internal uuid assigned on creation

```
`local uuid = dz:GetUUID()
`
```

## `int` GetZoneID() 

Returns zone id of the expedition's dynamic zone

```
`local zone_id = dz:GetZoneID()
`
```

## `string` GetZoneName() 

Returns zone short name of the expedition's dynamic zone

```
`local zone_short_name = dz:GetZoneName()
`
```

## `int` GetZoneVersion() 

Returns zone version of the expedition's dynamic zone instance

```
`local zone_version = dz:GetZoneVersion()
`
```

## `bool` HasLockout(string event_name) 

Returns whether the expedition internally has the specified event lockout. This is the primary function that should be used for initialization scripts to determine which events are available to an expedition.

```
`function init()
 local dz = eq.get_expedition()
 if dz.valid then
 local has_lockout = dz:HasLockout("Ture")
 if not has_lockout then
 eq.debug("Expedition doesn't have this lockout, we can spawn this event")
 end
 end
end
`
```

## `bool` HasReplayLockout() 

Returns whether the expedition internally has a `Replay Timer` lockout set. Shortcut alternative to checking `HasLockout`

```
`local has_replay_lockout = dz:HasReplayLockout()
`
```

## `bool` IsLocked() 

Returns if the expedition is currently locked by `SetLocked`

```
`local dz = eq.get_expedition()
if dz.valid then
 if dz:IsLocked() then
 eq.debug("expedition is locked")
 else
 eq.debug("expedition is not locked")
 end
end
`
```

## `void` RemoveCompass() 

Removes any compass set by `SetCompass`

```
`dz:RemoveCompass()
`
```

## `void` RemoveLockout(string event_name) 

Removes the lockout from the expedition and from any current members

```
`dz:RemoveLockout("Ture")
`
```

## `void` SetCompass(int zone_id, float x, float y, float z) 

## `void` SetCompass(string zone_short_name, float x, float y, float z) 

Set the location of the expedition's dynamic zone compass. This only applies to non-instances outside of the dz.

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if dz.valid then
 -- set compass to the anguish door inside wallofslaughter by zone id
 dz:SetCompass(300, 1353.15, 1712.19, 109.001)
 -- set compass to the anguish door inside wallofslaughter by zone name
 dz:SetCompass("wallofslaughter", 1353.15, 1712.19, 109.001)
 end
 end
end
`
```

## `void` SetLocked(bool locked, ExpeditionLockMessage lock_msg = ExpeditionLockMessage::None, uint32_t msg_color = Chat::Yellow) 

If true, lock an expedition to prevent new members from being added. False unlocks.

Passing a `lock_msg` sends an expedition locked message to clients inside the expedition's dynamic zone. See ExpeditionLockMessage for types and messages

```
`function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 -- no new members may be added to this expedition until it's unlocked
 dz:SetLocked(true, ExpeditionLockMessage.Close)
 end
end
`
```

## `void` SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name) 

Important: This must be set from a script inside the expedition's dynamic zone instance

Associates an event with the specified npc type id to prevent it from being looted by characters that didn't receive the event lockout from the current expedition.

This is an important initialization step to prevent exploits in expeditions

```
`function init()
 local dz = eq.get_expedition()
 if dz.valid then
 -- associate the "Keldovan the Harrier" event with his npc type id
 dz:SetLootEventByNPCTypeID(317005, 'Keldovan the Harrier')
 end
end
`
```

## `void` SetLootEventBySpawnID(uint32_t spawn_id, string event_name) 

Important: This must be set from a script inside the expedition's dynamic zone instance

Associates an event with the specified entity spawn id to prevent it from being looted by characters that didn't receive the event lockout from the current expedition.

This is an important initialization step to prevent exploits in expeditions

Unlike `SetLootEventByNPCTypeID` this associates the event with specific spawns inside the dynamic zone. This is for cases where multiple npc types may exist like spawnable chests which should be associated with the event that spawned them.

```
`function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 dz:AddLockout("Lower Globe of Discordant Energy")

 -- associate this spawned chest with the event
 local chest = eq.spawn2(317087, 0, 0, -301 ,702, -201, 0);
 dz:SetLootEventBySpawnID(chest:GetID(), "Lower Globe of Discordant Energy")
 end
end
`
```

## `void` SetReplayLockoutOnMemberJoin(bool value) 

This toggles whether `Replay Timer` lockouts are automatically added to new members that join an expedition

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if dz.valid then
 dz:SetReplayLockoutOnMemberJoin(false)
 end
 end
end
`
```

## `void` SetSafeReturn(uint32_t zone_id, float x, float y, float z, float heading) 

## `void` SetSafeReturn(string zone_short_name, float x, float y, float z, float heading) 

Set the expedition's dynamic zone safe return zone and coordinates. This is the location clients are moved to when an expedition expires or for clients that are automatically teleported out of the zone by the kick timer if they quit the expedition

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if dz.valid then
 -- by zone id
 dz:SetSafeReturn(300, 1349.13, 1715.00, 123.81, 0)
 -- or by zone name
 dz:SetSafeReturn("wallofslaughter", 1349.13, 1715.00, 123.81, 0)
 end
 end
end
`
```

## `void` SetSecondsRemaining(uint32 seconds_remaining) 

Set seconds remaining on expedition's dynamic zone before it expires. This currently only supports reducing time. It will have no effect if the new seconds remaining is larger than the current time remaining.

Note: this method is async, GetSecondsRemaining will not immediately show the change.

```
`function event_timer(e)
 if e.timer == "event_fail_timer" then
 eq.depop()
 local dz = eq.get_expedition()
 if dz.valid then
 dz:SetSecondsRemaining(300) -- close down expedition in 5 minutes
 end
 end
end
`
```

## `void` SetZoneInLocation(float x, float y, float z, float heading) 

Override the zone-in location of the expedition's dynamic zone used by `Client::MovePCDynamicZone`

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if dz.valid then
 dz:SetZoneInLocation(-9, -2466, -79, 0)
 end
 end
end
`
```

## `void` UpdateLockoutDuration(string event_name, uint32_t seconds, bool members_only = true) 

Sets the lockout of all members in the expedition to the specified duration based on the expedition's internal lockout start time.

Unlike `AddLockout` which replaces lockouts with a new lockout timer, this modifies the duration of an existing lockout relative to its original start time.

Calling this on an expedition that does not have the internal lockout has no effect. All members essentially receive an updated lockout copied from the expedition's internal timer.

Prefer using AddLockoutDuration to update individual member lockouts

The expedition's internal lockout is NOT modified by default. New members added to the expedition that zone in to the dz will receive the lockout as originally added. This can be overridden by passing false for the `members_only` parameter.

Note: Member lockouts updated with this method are assigned the current expedition's uuid

```
`function event_say(e)
 if e.message == "request" then
 local dz = e.other:CreateExpedition("anguish", 0, 36000, "Anguish, the Fallen Palace", 6, 54)
 if dz.valid then
 expedition:AddReplayLockout(7200) -- 2 hour replay lockout
 end
 end
end

-- inside dz, after killing some progression npc
function event_death(e)
 local dz = eq.get_expedition()
 if dz.valid then
 -- copies expedition's lockout to all current members with modified duration.
 -- member lockout durations will be (7 hours - elapsed time since added)
 dz:UpdateLockoutDuration("Replay Timer", 25200) -- 7 hours
 end
end
`
```

---

## Global Methods

*Source: server/expedition-system/quest-api-lua/global-methods/index.html*

# Global Methods

## `void` add_expedition_lockout_all_clients(string expedition_name, string event_name, int seconds, string uuid = "")

Adds the specified lockout to all clients in the current zone. If a client already has the lockout it's replaced with this one. If a uuid is not supplied one is generated and applied to all clients.

```
`eq.add_expedition_lockout_all_clients("Anguish, the Fallen Palace", "Ture", 300)
`
```

## `void` add_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name, int seconds, string uuid = "")

Adds the specified lockout to the character with an optional specified uuid. If the client already has the lockout it's replaced with this one. If a uuid is not supplied one is generated when the lockout is added to the character

```
`-- 5 minute lockout
eq.add_expedition_lockout_by_char_id(e.other:CharacterID(), "Anguish, the Fallen Palace", "Ture", 300)
`
```

## `Expedition*` get_expedition()

Returns an Expedition object corresponding to current zone if it's a valid dynamic zone instance being used for an expedition, otherwise returns nullptr.

```
`local dz = eq.get_expedition()
if dz.valid then
 eq.debug("Current zone is an expedition's dz instance")
end
`
```

## `Expedition*` get_expedition_by_char_id(int character_id)

Returns the character's current Expedition if the character is in one, otherwise returns nullptr.

```
`local dz = eq.get_expedition_by_char_id(e.other:CharacterID())
if dz.null then
 eq.debug("Character is not in an expedition")
end
`
```

## `Expedition*` get_expedition_by_dz_id(int dz_id)

Returns the Expedition for the specified dynamic zone id if it's valid, otherwise returns nullptr.

```
`local dz = eq.get_expedition_by_dz_id(dz_id)
if not dz.valid then
 eq.debug("that dynamic zone id is not in use by an expedition")
end
`
```

## `Expedition*` get_expedition_by_zone_instance(int zone_id, int instance_id)

Returns the Expedition for the specified zone and instance id if it's a valid dynamic zone instance, otherwise returns nullptr.

```
`local dz = eq.get_expedition_by_zone_instance(zone_id, instance_id)
if dz.valid then
 eq.debug("that zone instance is an expedition dynamic zone")
end
`
```

## `LUA_TTABLE` get_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name)

Returns a Lua table containing lockout details.

The table contains two hash keys `remaining` and `uuid`. T["remaining"] is the seconds remaining on the lockout and T["uuid"] is the expedition uuid the lockout was originally assigned in.

If the character doesn't have a lockout for the specified expedition event an empty table is returned.

```
`local lockout = eq.get_expedition_lockout_by_char_id(
 e.other:CharacterID(), "Anguish, the Fallen Palace", "Ture")

if next(lockout) == nil then
 eq.debug("Character does not have a Ture lockout")
else
 eq.debug(string.format("Lockout remaining: (%s)s uuid: (%s)", lockout.remaining, lockout.uuid))
end
`
```

## `LUA_TTABLE` get_expedition_lockouts_by_char_id(int character_id, string expedition_name = "")

Returns a Lua table containing all of character's current lockouts keyed by expedition name. If an optional `expedition_name` is passed in it returns a table of lockouts keyed by event name for that expedition.

Each character lockout contains a hash table with `remaining` and `uuid` keys

If the character has no lockouts, the table is empty

```
`-- without filter on expedition name
local lockouts = eq.get_expedition_lockouts_by_char_id(e.other:CharacterID())

for expedition_name,event_lockouts in pairs(lockouts) do
 for event_name,lockout in pairs(event_lockouts) do
 eq.debug(string.format("expedition: (%s) event: (%s) remaining: (%s)s uuid: (%s)",
 expedition_name, event_name, lockout.remaining, lockout.uuid))
 end
end
`
```

```
`-- with filter on expedition name
local lockouts = eq.get_expedition_lockouts_by_char_id(e.other:CharacterID(), "Anguish, the Fallen Palace")

for event_name,lockout in pairs(lockouts) do
 eq.debug(string.format("event: (%s) remaining: (%s)s uuid: (%s)",
 event_name, lockout.remaining, lockout.uuid))
end
`
```

## `void` remove_all_expedition_lockouts_by_char_id(int character_id, string expedition_name = "")

Removes all expedition lockouts from the character, optionally filtered on an expedition name

```
`-- removes all lockouts
eq.remove_expedition_lockout_by_char_id(e.other:CharacterID())
-- removes all anguish lockouts
eq.remove_expedition_lockout_by_char_id(e.other:CharacterID(), "Anguish, the Fallen Palace")
`
```

## `void` remove_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name)

Removes the specified lockout from the character. No-op if the character doesn't have the lockout

```
`eq.remove_expedition_lockout_by_char_id(e.other:CharacterID(), "Anguish, the Fallen Palace", "Ture")
`
```

---

## Group/Raid Methods

*Source: server/expedition-system/quest-api-lua/group-raid-methods/index.html*

# Group/Raid Methods

## Group methods

### `bool` DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count = 0)

Returns true if any group member has the specified lockout.

Passing a non-zero `max_check_count` will limit to checking that number of group members in no guaranteed order.

See Raid::DoesAnyMemberHaveExpeditionLockout for example. .

## Raid methods

### `bool` DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count = 0)

Returns true if any raid member has the specified lockout.

Passing a non-zero `max_check_count` will limit to checking that number of raid members. The order that raid members are checked is leader first, followed by raid member group number, and finally ungrouped members. The order of group members within raid groups is not guaranteed to be the same as displayed.

```
`local member_has_lockout = false

if e.other:GetRaid().valid then
 member_has_lockout = e.other:GetRaid():DoesAnyMemberHaveExpeditionLockout("foo", "bar")
elseif e.other:GetGroup().valid then
 member_has_lockout = e.other:GetGroup():DoesAnyMemberHaveExpeditionLockout("foo", "bar")
else
 member_has_lockout = e.other:HasExpeditionLockout("foo", "bar")
end

if member_has_lockout then
 e.self:Say("Insert custom quest dialogue if someone has a lockout")
else
 local expedition = e.other:CreateExpedition("zone", 0, 36000, "foo", 6, 54)
end
`
```

---

## Quest API (Lua)

*Source: server/expedition-system/quest-api-lua/index.html*

# Quest API (Lua)

Note: Methods described as returning a `nullptr` for Expedition return types refers to the internal wrapped pointer and should not be validated with Lua's `nil`. Use `result.valid` or `result.null` to check the return result.

## Global methods

| 

return type 
| function 

| void 
| eq.add_expedition_lockout_all_clients(string expedition_name, string event_name, int seconds, string uuid = "") 

| void 
| eq.add_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name, int seconds, string uuid = "") 

| Expedition* 
| eq.get_expedition() 

| Expedition* 
| eq.get_expedition_by_char_id(int character_id) 

| Expedition* 
| eq.get_expedition_by_dz_id(int dz_id) 

| Expedition* 
| eq.get_expedition_by_zone_instance(int zone_id, int instance_id) 

| LUA_TTABLE 
| eq.get_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

| LUA_TTABLE 
| eq.get_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

| void 
| eq.remove_all_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

| void 
| eq.remove_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

## Client methods

| 

return type 
| function 

| void 
| AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid = "") 

| void 
| AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid = "") 

| Expedition* 
| CreateExpedition(string zone_short_name, int zone_version, int duration, string expedition_name, int min_players, int max_players, bool disable_messages = false) 

| Expedition* 
| CreateExpedition(LUA_TTABLE expedition_info) 

| Expedition* 
| GetExpedition() 

| LUA_TTABLE 
| GetExpeditionLockouts(string expedition_name = "") 

| string 
| GetLockoutExpeditionUUID(string expedition_name, string event_name) 

| bool 
| HasExpeditionLockout(string expedition_name, string event_name) 

| void 
| MovePCDynamicZone(int zone_id, int zone_version = -1, bool msg_if_invalid = true) 

| void 
| MovePCDynamicZone(string zone_short_name, int zone_version = -1, bool msg_if_invalid = true) 

| void 
| RemoveAllExpeditionLockouts(string expedition_name = "") 

| void 
| RemoveExpeditionLockout(string expedition_name, string event_name) 

## Group methods

| 

return type 
| function 

| bool 
| DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_member_check_count = 0) 

## Raid methods

| 

return type 
| function 

| bool 
| DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_member_check_count = 0) 

## Expedition methods

| 

return type 
| property 

| bool 
| valid 

| bool 
| null 

| 

return type 
| function 

| void 
| AddLockout(string event_name, uint32 seconds_duration) 

| void 
| AddLockoutDuration(string event_name, int seconds, bool members_only = true) 

| void 
| AddReplayLockout(int seconds_duration) 

| void 
| AddReplayLockoutDuration(int seconds_duration, bool members_only = true) 

| uint32 
| GetDynamicZoneID() 

| uint32 
| GetID() 

| int 
| GetInstanceID() 

| string 
| GetLeaderName() 

| LUA_TTABLE 
| GetLockouts() 

| string 
| GetLootEventByNPCTypeID(uint32 npc_type_id) 

| string 
| GetLootEventBySpawnID(uint32 spawn_id) 

| uint32 
| GetMemberCount() 

| LUA_TTABLE 
| GetMembers() 

| string 
| GetName() 

| int 
| GetSecondsRemaining() 

| string 
| GetUUID() 

| int 
| GetZoneID() 

| string 
| GetZoneName() 

| int 
| GetZoneVersion() 

| bool 
| HasLockout(string event_name) 

| bool 
| HasReplayLockout() 

| bool 
| IsLocked() 

| void 
| RemoveCompass() 

| void 
| RemoveLockout(string event_name) 

| void 
| SetCompass(int zone_id, float x, float y, float z) 

| void 
| SetCompass(string zone_short_name, float x, float y, float z) 

| void 
| SetLocked(bool value, ExpeditionLockMessage lock_msg = ExpeditionLockMessage::None, uint32 msg_color = Chat::Yellow) 

| void 
| SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name) 

| void 
| SetLootEventBySpawnID(uint32_t spawn_id, string event_name) 

| void 
| SetReplayLockoutOnMemberJoin(bool value) 

| void 
| SetSafeReturn(uint32_t zone_id, float x, float y, float z, float heading) 

| void 
| SetSafeReturn(string zone_short_name, float x, float y, float z, float heading) 

| void 
| SetZoneInLocation(float x, float y, float z, float heading) 

| void 
| SetSecondsRemaining(uint32 seconds_remaining) 

| void 
| UpdateLockoutDuration(string event_name, uint32_t seconds, bool members_only = true) 

## Expedition constants 

#### `ExpeditionLockMessage` 

| 

constant 
| value 
| lock message 

| None 
| 0 
| 

| Close 
| 1 
| "Your expedition is nearing its close. You cannot bring any additional people into your expedition at this time." 

| Begin 
| 2 
| "The trial has begun. You cannot bring any additional people into your expedition at this time."

---

## Client Methods

*Source: server/expedition-system/quest-api-perl/client-methods/index.html*

# Client Methods

## `void` AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid = "") 

Assigns the specified lockout to the client. If the client already has the lockout it's replaced with this one. If a uuid isn't supplied one is generated

```
`# Add 10 minute lockouts
$client->AddExpeditionLockout("Anguish, the Fallen Palace", "Ture", 600);
$client->AddExpeditionLockout("Anguish, the Fallen Palace", "Keldovan the Harrier", 600);
`
```

## `void` AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid = "") 

Adds `seconds` to the specified client lockout duration. If `seconds` is negative then the duration of the lockout is reduced (limited to 0).

If the client does not have the lockout and `seconds` is positive, a new lockout is created with the specified uuid. If a uuid isn't supplied one is generated.

```
`# Decrease Ture lockout by 5 minutes
$client->AddExpeditionLockoutDuration("Anguish, the Fallen Palace", "Ture", -300);
# Increase keldovan lockout by 5 minutes
$client->AddExpeditionLockoutDuration("Anguish, the Fallen Palace", "Keldovan the Harrier", 300);
`
```

## `Expedition*` CreateExpedition(string zone_short_name, int zone_version, int duration, string expedition_name, int min_players, int max_players, bool disable_messages = false) 

This initiates an expedition creation request by the client. All members in the client's current group or raid (if in one) are validated for the expedition request. On success an expedition object is returned and all members of the client's group/raid are added to the expedition. Returns nullptr if the request is rejected

This method takes both the instance zone details and expedition details

Passing `true` for the optional `disable_messages` parameter disables all expedition rejection messages sent to the leader (member lockout conflicts, etc)

Note: Expedition creation follows behavior introduced with the live September 16, 2020 patch. The expedition may be created even if the group or raid exceeds the expedition's max player requirement, but only members up to the max are added to it. Players are added based on priority of raid group number followed by ungrouped players. The raid leader is added first. Players inside groups or raid groups may not be added in displayed order.

```
`my $dz = $client->CreateExpedition("anguish", 0, 3600, "Anguish, the Fallen Palace", 6, 54);
if ($dz) {
 quest::debug(sprintf("expedition [%d] created", $dz->GetID()));
} else {
 quest::debug(sprintf("expedition request failed"));
}
`
```

## `Expedition*` GetExpedition() 

Return client's current expedition if client is in one, otherwise returns nullptr

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug(sprintf("client in expedition [%d]", $dz->GetID()));
} else {
 quest::debug(sprintf("client is not in an expedition"));
}
`
```

## `HASHREF` GetExpeditionLockouts(string expedition_name = "") 

Returns a hash reference keyed on expedition name containing an event hash reference with client's current lockouts. If expedition_name is supplied then just an event hash reference is returned for that expedition. The value of event hash references is the lockout's remaining duration. Returns empty value if client doesn't have any lockouts

```
`my $lockouts = $client->GetExpeditionLockouts();
foreach my $expedition_name (keys %{ $lockouts }) {
 my $events = $lockouts->{$expedition_name};
 foreach my $event_name (keys %{ $events }) {
 my $remaining = $events->{$event_name};
 quest::debug("expedition: [$expedition_name] event: [$event_name] seconds remaining: [$remaining]");
 }
}
`
```

```
`# filtered on expedition name
my $lockouts = $client->GetExpeditionLockouts("Anguish, the Fallen Palace");
foreach my $event_name (keys %{ $lockouts }) {
 my $remaining = $lockouts->{$event_name};
 quest::debug("anguish event: [$event_name] seconds remaining: [$remaining]");
}
`
```

## `string` GetLockoutExpeditionUUID(string expedition_name, string event_name) 

Returns uuid string of the expedition the lockout was received in. Returns an empty string if client doesn't have the lockout

```
`my $uuid = $client->GetLockoutExpeditionUUID("Anguish, the Fallen Palace", "Ture");
quest::debug("client received lockout in expedition uuid: [$uuid]");
`
```

## `bool` HasExpeditionLockout(string expedition_name, string event_name) 

Returns true of the client has the lockout, false otherwise

```
`my $has_lockout = $client->HasExpeditionLockout("Anguish, the Fallen Palace", "Ture");
quest::debug("client has lockout: [$has_lockout]");
`
```

## `void` MovePCDynamicZone(int zone_id, int zone_version = -1, bool msg_if_invalid = true) 

## `void` MovePCDynamicZone(string zone_short_name, int zone_version = -1, bool msg_if_invalid = true) 

Attempts to move the client to the specified zone if the client is part of a system (expedition or otherwise) with an associated dynamic zone instance in the target zone.

If a valid `zone_version` (0 or higher) is supplied then the move will only be allowed if a player's dz to `zone_id` is also for that `zone_version`.

If the client is not associated with a dz for the specified zone, the client is not moved. If `msg_if_invalid` is true (default) the client is sent a message that the way is blocked.

If the client is associated with multiple dz systems to the same zone, the client's `DynamicZoneSwitchListWnd` interface window is invoked to allow the client to choose which dynamic zone to enter.

On success, the player is moved to the dynamic zone's zone in coordinates (set on creation or afterwards) If no zone in coordinates are set, the player is moved to the zone's default safe coords.

`MovePCInstance` should be used if finer control of zone in location is required, but care must be taken to validate the client is part of an instance for the target zone

```
`$client->MovePCDynamicZone(317); # by zone id
$client->MovePCDynamicZone("anguish"); # by zone short name
`
```

## `void` RemoveAllExpeditionLockouts(string expedition_name = "") 

Removes all expedition lockouts from the character, optionally filtered on an expedition name

```
`# removes all lockouts
$client->RemoveAllExpeditionLockouts();
# removes all anguish lockouts
$client->RemoveAllExpeditionLockouts("Anguish, the Fallen Palace");
`
```

## `void` RemoveExpeditionLockout(string expedition_name, string event_name) 

Removes the specified lockout from the character. No-op if the character doesn't have the lockout

```
`$client->RemoveExpeditionLockout("Anguish, the Fallen Palace", "Ture");
`
```

---

## Example

*Source: server/expedition-system/quest-api-perl/example/index.html*

# Example

This is a full example to demonstrate usage. Guard Pineshade at the orc lift in gfaydark provides an expedition to crushbone

`gfaydark/Guard_Pineshade.pl`

```
`my $expedition_name = "Crushbone, DVinn's Stronghold";
my $min_players = 1;
my $max_players = 6;
my $dz_zone = "crushbone";
my $dz_version = 0;
my $dz_duration = 3600; # 1 hour

sub EVENT_SAY {
 if ($text =~ /hail/i) {
 my $dz = $client->GetExpedition();
 if ($dz && $dz->GetName() eq $expedition_name) {
 quest::say("Tell me when you're [" . quest::saylink("ready") . "] to enter");
 }
 else {
 quest::say("Would you like to [" . quest::saylink("request") . "] the expedition?");
 }
 }
 elsif ($text =~ /request/i) {
 my $dz = $client->CreateExpedition($dz_zone, $dz_version, $dz_duration, $expedition_name, $min_players, $max_players);
 if ($dz) {
 $dz->SetCompass("gfaydark", 238.0, 987.0, -24.90); # pointing to guard pineshade
 $dz->SetSafeReturn("gfaydark", 245.84, 987.93, -27.6, 484.0); # orc lift in gfay
 $dz->SetZoneInLocation(479.44, -500.18, 5.75, 421.8); # bridge in crushbone
 $dz->AddReplayLockout(7200); # immediately add a 2 hour replay lockout on creation
 quest::say("Tell me when you're [" . quest::saylink("ready") . "] to enter");
 }
 }
 elsif ($text =~ /ready/i) {
 $client->MovePCDynamicZone("crushbone");
 }
}
`
```

`crushbone/zone_controller.pl`

```
`# this requires the Zone:UseZoneController rule to be enabled
my $initialized = 0;

sub Initialize {
 quest::debug("Initializing expedition");
 my $dz = quest::get_expedition();
 if ($dz) {
 # bind unique npc types to events to prevent any looting exploits
 $dz->SetLootEventByNPCTypeID(58032, "Emperor Crush"); # npc: Emperor_Crush
 $dz->SetLootEventByNPCTypeID(317109, "Ambassador Mata Muram"); # npc: Overlord_Mata_Muram

 # spawn any events that the expedition doesn't have a lockout for
 if (!$dz->HasLockout("Ambassador Mata Muram")) {
 quest::spawn2(317109, 0, 0, 130.78, -149.09, 88.70, 270.8); # npc: Overlord_Mata_Muram
 }
 }
}

sub EVENT_SPAWN_ZONE {
 # note: zone_controller spawns before expeditions can be cached, so we delay
 # expedition init until first npc spawns instead of using our EVENT_SPAWN
 if (!$initialized) {
 $initialized = 1; # set first to prevent infinite recursion from spawning npcs in init()
 Initialize();
 }

 if ($spawned_npc_id == 58032) { # npc: Emperor_Crush
 my $dz = quest::get_expedition();
 if ($dz && $dz->HasLockout("Emperor Crush")) {
 quest::depop(58032); # depop emperor crush due to lockout
 }
 }
}

sub EVENT_DEATH_ZONE {
 if ($killed_npc_id == 58032) { # npc: Emperor_Crush
 my $dz = quest::get_expedition();
 if ($dz) {
 $dz->AddLockout("Emperor Crush", 86400); # 1 day lockout
 }
 }
 elsif ($killed_npc_id == 317109) { # npc: Overlord_Mata_Muram
 my $dz = quest::get_expedition();
 if ($dz) {
 $dz->AddLockout("Ambassador Mata Muram", 604800); # 7 day lockout

 # spawn a chest and bind its spawn id to the event to prevent loot exploits
 my $chest_id = quest::spawn2(893, 0, 0, 130.78, -149.09, 88.70, 0);
 $dz->SetLootEventBySpawnID($chest_id, "Ambassador Mata Muram");
 }
 }
}
`
```

---

## Expedition Methods

*Source: server/expedition-system/quest-api-perl/expedition-methods/index.html*

# Expedition Methods

## `void` AddLockout(string event_name, uint32 seconds_duration) 

Adds an event lockout timer to the expedition with the specified duration.

The lockout is added to all current members of the expedition whether they're inside the zone or not. This also adds the lockout to any clients inside the dynamic zone that are not part of the expedition (in the event that they've quit the expedition and haven't been teleported out yet)

The lockout is also stored internally in the expedition. New members added to the expedition will receive these lockouts once they zone into the expedition's dynamic zone.

The lockout replaces any existing lockout held by the expedition and members.

The lockout is assigned the current expedition's internal uuid for tracking.

Note: The source adds 60s to the lockout timer sent to clients to compensate for the client displaying lockouts rounded down to the nearest minute. If adding lockout times using live packet data subtract 60s from the time (live adds 60s as well)

```
`my $dz = $client->GetExpedition();
if ($dz) {
 $dz->AddLockout("Expedition Event Name", 3600); # 1 hour lockout
}
`
```

## `void` AddLockoutDuration(string event_name, int seconds, bool members_only = true) 

Adds duration to existing member lockouts for the event. If `seconds` is negative then lockout duration is reduced.

Unlike UpdateLockoutDuration which applies a static lockout duration to all members based on the expedition's internal lockout, this modifies each member's existing lockout duration separately.

If a member does not have the specified event lockout and `seconds` is positive, the lockout is added to the member with the current expedition's uuid.

By default this only updates expedition members. Passing `false` for `members_only` will update the expedition's internal lockout duration as well which will affect any future members added to the expedition.

Non-expedition members inside the expedition's dynamic zone instance are always updated

```
`my $dz = $client->GetExpedition();
if ($dz) {
 $dz->AddLockoutDuration("Expedition Event Name", 3600); # add 1 hour to lockout
}
`
```

## `void` AddReplayLockout(int seconds_duration) 

Adds a `Replay Timer` lockout to the expedition. This is a shortcut alternative to adding the lockout by name through the `AddLockout` method.

Replay Timer's use a hardcoded event name and are used as a lockout against requesting the expedition itself.

Unlike normal event lockouts, any members added to the expedition after a replay timer has been assigned will receive the lockout immediately with a reset expiration timer based on the original duration.

```
`my $dz = $client->GetExpedition();
if ($dz) {
 $dz->AddReplayLockout(7200); # 2 hour replay timer
}
`
```

## `void` AddReplayLockoutDuration(int seconds, bool members_only = true) 

Adds duration to expedition's `Replay Timer` lockout. See AddLockoutDuration

```
`my $dz = $client->GetExpedition();
if ($dz) {
 $dz->AddReplayLockoutDuration(7200); # add 2 hours to replay timer
}
`
```

## `uint32_t` GetDynamicZoneID() 

Returns the expedition's dynamic zone id

```
`my $dz_id = $expedition->GetDynamicZoneID();
`
```

## `uint32_t` GetID() 

Returns the expedition's id

```
`my $id = $expedition->GetID();
`
```

## `int` GetInstanceID() 

Returns the expedition's dynamic zone instance id

```
`my $id = $expedition->GetInstanceID();
`
```

## `string` GetLeaderName() 

Returns the expedition's current leader name

```
`my $leader_name = expedition:GetLeaderName();
`
```

## `HASHREF` GetLockouts() 

Returns a hash reference containing the expedition's current internal lockouts and time remaining. This includes lockouts that were inherited by the leader on creation and not just lockouts assigned during the current expedition.

```
`my $dz = $client->GetExpedition();
if ($dz) {
 my $lockouts = $dz->GetLockouts();
 foreach my $event_name (keys %{ $lockouts }) {
 quest::debug("event: [$event_name] seconds remaining: [$lockouts->{$event_name}]");
 }
}
`
```

## `string` GetLootEventByNPCTypeID(uint32 npc_type_id) 

## `string` GetLootEventBySpawnID(uint32 spawn_id) 

Returns an event name associated with an npc type id or spawn id set by the SetLootEventByNPCTypeID or SetLootEventBySpawnID apis.

Returns an empty string if no event set

Important: This is only valid inside the expedition's dynamic zone instance

```
`my $dz = quest::get_expedition();
if ($dz) {
 quest::debug("npc type id 12345 event: " . $dz->GetLootEventByNPCTypeID(12345));
 quest::debug("spawn id 20 event: " . $dz->GetLootEventBySpawnID(20));
}
`
```

## `int` GetMemberCount() 

Returns number of members in expedition

```
`my $count = $dz->GetMemberCount();
`
```

## `HASHREF` GetMembers() 

Returns a hash reference containing member names and character ids

```
`my $dz = $client->GetExpedition();
if ($dz) {
 my $members = $dz->GetMembers();
 foreach my $member_name (keys %{ $members }) {
 quest::debug("char name: [$member_name] char id: [$members->{$member_name}]");
 }
}
`
```

## `string` GetName() 

Returns name of the expedition

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition name: " . $dz->GetName());
}
`
```

## `int` GetSecondsRemaining() 

Returns seconds remaining until expedition's dynamic zone expires

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition seconds remaining: " . $dz->GetSecondsRemaining());
}
`
```

## `string` GetUUID() 

Returns expedition's internal uuid assigned on creation

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition uuid: " . $dz->GetUUID());
}
`
```

## `int` GetZoneID() 

Returns zone id of the expedition's dynamic zone

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition's dz zone id: " . $dz->GetZoneID());
}
`
```

## `string` GetZoneName() 

Returns zone short name of the expedition's dynamic zone

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition's dz zone name: " . $dz->GetZoneName());
}
`
```

## `int` GetZoneVersion() 

Returns zone version of the expedition's dynamic zone instance

```
`my $dz = $client->GetExpedition();
if ($dz) {
 quest::debug("expedition's dz zone version: " . $dz->GetZoneVersion());
}
`
```

## `bool` HasLockout(string event_name) 

Returns whether the expedition internally has the specified event lockout. This is the primary function that should be used for initialization scripts to determine which events are available to an expedition.

```
`my $dz = quest::get_expedition();
if ($dz) {
 my $has_lockout = $dz->HasLockout("Ture") ? 1 : 0;
 quest::debug("expedition has Ture lockout: " . $has_lockout);
}
`
```

## `bool` HasReplayLockout() 

Returns whether the expedition internally has a `Replay Timer` lockout set. Shortcut alternative to checking `HasLockout`

```
`my $dz = quest::get_expedition();
if ($dz) {
 my $has_lockout = $dz->HasReplayLockout() ? 1 : 0;
 quest::debug("expedition has Replay lockout: " . $has_lockout);
}
`
```

## `bool` IsLocked() 

Returns if the expedition is currently locked by `SetLocked`

```
`my $dz = quest::get_expedition();
if ($dz) {
 if ($dz->IsLocked()) {
 quest::debug("expedition is locked");
 } else {
 quest::debug("expedition is not locked");
 }
}
`
```

## `void` RemoveCompass() 

Removes any compass set by `SetCompass`

```
`$dz->RemoveCompass();
`
```

## `void` RemoveLockout(string event_name) 

Removes the lockout from the expedition and from any current members

```
`$dz->RemoveLockout("Ture");
`
```

## `void` SetCompass(int zone_id, float x, float y, float z) 

## `void` SetCompass(string zone_short_name, float x, float y, float z) 

Set the location of the expedition's dynamic zone compass. This only applies to non-instances outside of the dz.

```
`$dz->SetCompass(300, 1353.15, 1712.19, 109.001); # by zone id
$dz->SetCompass("wallofslaughter", 1353.15, 1712.19, 109.001); # by zone name
`
```

## `void` SetLocked(bool locked, ExpeditionLockMessage lock_msg = ExpeditionLockMessage::None, uint32_t msg_color = Chat::Yellow) 

If true, lock an expedition to prevent new members from being added. False unlocks.

Passing a `lock_msg` sends an expedition locked message to clients inside the expedition's dynamic zone. See ExpeditionLockMessage for types and messages

```
`$dz->SetLocked(true, ExpeditionLockMessage::None); # lock with no message
$dz->SetLocked(true, ExpeditionLockMessage::Close); # lock with "closing" message
`
```

## `void` SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name) 

Important: This must be set from a script inside the expedition's dynamic zone instance

Associates an event with the specified npc type id to prevent it from being looted by characters that didn't receive the event lockout from the current expedition.

This is an important initialization step to prevent exploits in expeditions

```
`$dz->SetLootEventByNPCTypeID(317005, 'Keldovan the Harrier');
`
```

## `void` SetLootEventBySpawnID(uint32_t spawn_id, string event_name) 

Important: This must be set from a script inside the expedition's dynamic zone instance

Associates an event with the specified entity spawn id to prevent it from being looted by characters that didn't receive the event lockout from the current expedition.

This is an important initialization step to prevent exploits in expeditions

Unlike `SetLootEventByNPCTypeID` this associates the event with specific spawns inside the dynamic zone. This is for cases where multiple npc types may exist like spawnable chests which should be associated with the event that spawned them.

```
`my $chest_id = quest::spawn2(317087, 0, 0, -301 ,702, -201, 0);
$dz->SetLootEventBySpawnID($chest_id, "Lower Globe of Discordant Energy");
`
```

## `void` SetReplayLockoutOnMemberJoin(bool value) 

This toggles whether `Replay Timer` lockouts are automatically added to new members that join an expedition

```
`$dz->SetReplayLockoutOnMemberJoin(0);
`
```

## `void` SetSafeReturn(uint32_t zone_id, float x, float y, float z, float heading) 

## `void` SetSafeReturn(string zone_short_name, float x, float y, float z, float heading) 

Set the expedition's dynamic zone safe return zone and coordinates. This is the location clients are moved to when an expedition expires or for clients that are automatically teleported out of the zone by the kick timer if they quit the expedition

```
`$dz->SetSafeReturn("wallofslaughter", 1349.13, 1715.00, 123.81, 0);
`
```

## `void` SetSecondsRemaining(uint32 seconds_remaining) 

Set seconds remaining on expedition's dynamic zone before it expires. This currently only supports reducing time. It will have no effect if the new seconds remaining is larger than the current time remaining.

Note: this method is async, GetSecondsRemaining will not immediately show the change.

```
`$dz->SetSecondsRemaining(300); # close down expedition in 5 minutes
`
```

## `void` SetZoneInLocation(float x, float y, float z, float heading) 

Override the zone-in location of the expedition's dynamic zone used by `Client::MovePCDynamicZone`

```
`$dz->SetZoneInLocation(-9, -2466, -79, 0);
`
```

## `void` UpdateLockoutDuration(string event_name, uint32_t seconds, bool members_only = true) 

Sets the lockout of all members in the expedition to the specified duration based on the expedition's internal lockout start time.

Unlike `AddLockout` which replaces lockouts with a new lockout timer, this modifies the duration of an existing lockout relative to its original start time.

Calling this on an expedition that does not have the internal lockout has no effect. All members essentially receive an updated lockout copied from the expedition's internal timer.

Prefer using AddLockoutDuration to update individual member lockouts

The expedition's internal lockout is NOT modified by default. New members added to the expedition that zone in to the dz will receive the lockout as originally added. This can be overridden by passing false for the `members_only` parameter.

Note: Member lockouts updated with this method are assigned the current expedition's uuid

```
`$dz->UpdateLockoutDuration("Replay Timer", 25200) # 7 hours
`
```

---

## Global Methods

*Source: server/expedition-system/quest-api-perl/global-methods/index.html*

# Global Methods

## `void` add_expedition_lockout_all_clients(string expedition_name, string event_name, int seconds, string uuid = "") 

Adds the specified lockout to all clients in the current zone. If a client already has the lockout it's replaced with this one. If a uuid is not supplied one is generated and applied to all clients.

```
`quest::add_expedition_lockout_all_clients("Added expedition", "Added event", 7200);
`
```

## `void` add_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name, int seconds, string uuid = "") 

Adds the specified lockout to the character with an optional specified uuid. If the client already has the lockout it's replaced with this one. If a uuid is not supplied one is generated when the lockout is added to the character

```
`quest::add_expedition_lockout_by_char_id($client->CharacterID(), "Added expedition", "Added event", 7200);
`
```

## `Expedition*` get_expedition() 

Returns an Expedition object corresponding to current zone if it's a valid dynamic zone instance being used for an expedition, otherwise returns nullptr.

```
`my $dz = quest::get_expedition();
if ($dz) {
 quest::debug(sprintf("current zone is expedition id [%d]'s dz instance", $dz->GetID()));
}
`
```

## `Expedition*` get_expedition_by_char_id(int character_id) 

Returns the character's current Expedition if the character is in one, otherwise returns nullptr.

```
`my $dz = quest::get_expedition_by_char_id($client->CharacterID());
if ($dz) {
 quest::debug(sprintf("client [%d] is in expedition id [%d]", $client->CharacterID(), $dz->GetID()));
}
`
```

## `Expedition*` get_expedition_by_dz_id(int dz_id) 

Returns the Expedition for the specified dynamic zone id if it's valid, otherwise returns nullptr.

```
`my $dzid = 0;
my $dz = quest::get_expedition_by_char_id($client->CharacterID());
if ($dz) {
 $dzid = $dz->GetDynamicZoneID();
}

if ($dzid > 0) {
 my $expedition_from_dzid = quest::get_expedition_by_dz_id($dzid);
 if ($expedition_from_dzid) {
 quest::debug(sprintf("dz id [%d] is for expedition id [%d]", $dzid, $expedition_from_dzid->GetID()));
 }
}
`
```

## `Expedition*` get_expedition_by_zone_instance(int zone_id, int instance_id) 

Returns the Expedition for the specified zone and instance id if it's a valid dynamic zone instance, otherwise returns nullptr.

```
`# assuming character is in an anguish expedition
my $zoneid = quest::GetZoneID("anguish");
my $instanceid = quest::GetInstanceIDByCharID("anguish", 0, $client->CharacterID());

my $dz = quest::get_expedition_by_zone_instance($zoneid, $instanceid);
if ($dz) {
 quest::debug(sprintf("zone id [%d] instance id [%d] is for expedition id [%d]", $zoneid, $instanceid, $dz->GetID()));
}
`
```

## `HASHREF` get_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

Returns a hash reference containing lockout details.

The hash contains the keys `remaining` and `uuid`. `remaining` is the seconds remaining on the lockout and `uuid` is the expedition uuid the lockout was originally assigned in.

If the character doesn't have a lockout for the specified expedition event empty hash values are returned

```
`my $lockout = quest::get_expedition_lockout_by_char_id($client->CharacterID(), "Anguish, the Fallen Palace", "Ture");
if (keys %{ $lockout }) {
 quest::debug(sprintf("lockout remaining: [%d] seconds, uuid: [%s]", $lockout->{'remaining'}, $lockout->{'uuid'}));
} else {
 quest::debug(sprintf("character [%d] does not have this lockout", $client->CharacterID()));
}
`
```

## `HASHREF` get_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

Returns a hash reference containing all of character's current lockouts keyed by expedition name. If an optional `expedition_name` is passed in it returns a hash reference of lockouts keyed by event name for that expedition.

Each character lockout contains a hash reference with `remaining` and `uuid` keys

If the character has no lockouts, the hash values are empty

```
`# without filter on expedition name
my $lockouts = quest::get_expedition_lockouts_by_char_id($client->CharacterID());
foreach my $expedition_name (keys %{ $lockouts }) {
 my $events = $lockouts->{$expedition_name};
 foreach my $event_name (keys %{ $events }) {
 my $lockout = $events->{$event_name};
 quest::debug("expedition: [$expedition_name] event: [$event_name] seconds remaining: [$lockout->{'remaining'}] uuid: [$lockout->{'uuid'}]");
 }
}
`
```

```
`# with filter on expedition name
my $anguish_lockouts = quest::get_expedition_lockouts_by_char_id($client->CharacterID(), "Anguish, the Fallen Palace");
foreach my $event_name (keys %{ $anguish_lockouts }) {
 my $lockout = $anguish_lockouts->{$event_name};
 quest::debug("event: [$event_name] seconds remaining: [$lockout->{'remaining'}] uuid: [$lockout->{'uuid'}]");
}
`
```

## `void` remove_all_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

Removes all expedition lockouts from the character, optionally filtered on an expedition name

```
`# removes all lockouts
quest::remove_all_expedition_lockouts_by_char_id($client->CharacterID());
# removes all anguish lockouts
quest::remove_all_expedition_lockouts_by_char_id($client->CharacterID(), "Anguish, the Fallen Palace");
`
```

## `void` remove_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

Removes the specified lockout from the character. No-op if the character doesn't have the lockout

```
`quest::remove_expedition_lockout_by_char_id($client->CharacterID(), "Added expedition", "Added event");
`
```

---

## Group/Raid Methods

*Source: server/expedition-system/quest-api-perl/group-raid-methods/index.html*

# Group/Raid Methods

## Group methods

### `bool` DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count = 0)

Returns true if any group member has the specified lockout.

Passing a non-zero `max_check_count` will limit to checking that number of group members in no guaranteed order.

See Raid::DoesAnyMemberHaveExpeditionLockout for example. \

## Raid methods

### `bool` DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_check_count = 0)

Returns true if any raid member has the specified lockout.

Passing a non-zero `max_check_count` will limit to checking that number of raid members. The order that raid members are checked is leader first, followed by raid member group number, and finally ungrouped members. The order of group members within raid groups is not guaranteed to be the same as displayed.

```
`my $member_has_lockout = 0;

my $raid = $client->GetRaid();
my $group = $client->GetGroup();

if ($raid) {
 $member_has_lockout = $raid->DoesAnyMemberHaveExpeditionLockout("foo", "bar");
} elsif ($group) {
 $member_has_lockout = $group->DoesAnyMemberHaveExpeditionLockout("foo", "bar");
} else {
 $member_has_lockout = $client->HasExpeditionLockout("foo", "bar");
}

quest::debug("member has lockout: [$member_has_lockout]");
`
```

---

## Quest API (Perl)

*Source: server/expedition-system/quest-api-perl/index.html*

# Quest API (Perl)

Note: `HASHREF` designates a ***reference*** to `SVt_PVHV` hash type

## Global methods

| 

return type 
| function 

| void 
| add_expedition_lockout_all_clients(string expedition_name, string event_name, int seconds, string uuid = "") 

| void 
| add_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name, int seconds, string uuid = "") 

| Expedition* 
| get_expedition() 

| Expedition* 
| get_expedition_by_char_id(int character_id) 

| Expedition* 
| get_expedition_by_dz_id(int dz_id) 

| Expedition* 
| get_expedition_by_zone_instance(int zone_id, int instance_id) 

| HASHREF 
| get_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

| HASHREF 
| get_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

| void 
| remove_all_expedition_lockouts_by_char_id(int character_id, string expedition_name = "") 

| void 
| remove_expedition_lockout_by_char_id(int character_id, string expedition_name, string event_name) 

## Client methods

| 

return type 
| function 

| void 
| AddExpeditionLockout(string expedition_name, string event_name, uint32 seconds, string uuid = "") 

| void 
| AddExpeditionLockoutDuration(string expedition_name, string event_name, int seconds, string uuid = "") 

| Expedition* 
| CreateExpedition(string zone_short_name, int zone_version, int duration, string expedition_name, int min_players, int max_players, bool disable_messages = false) 

| Expedition* 
| GetExpedition() 

| HASHREF 
| GetExpeditionLockouts(string expedition_name = "") 

| string 
| GetLockoutExpeditionUUID(string expedition_name, string event_name) 

| bool 
| HasExpeditionLockout(string expedition_name, string event_name) 

| void 
| MovePCDynamicZone(int zone_id, int zone_version = -1, bool msg_if_invalid = true) 

| void 
| MovePCDynamicZone(string zone_short_name, int zone_version = -1, bool msg_if_invalid = true) 

| void 
| RemoveAllExpeditionLockouts(string expedition_name = "") 

| void 
| RemoveExpeditionLockout(string expedition_name, string event_name) 

## Group methods

| 

return type 
| function 

| bool 
| DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_member_check_count = 0) 

## Raid methods

| 

return type 
| function 

| bool 
| DoesAnyMemberHaveExpeditionLockout(string expedition_name, string event_name, int max_member_check_count = 0) 

## Expedition methods

| 

return type 
| function 

| void 
| AddLockout(string event_name, uint32 seconds_duration) 

| void 
| AddLockoutDuration(string event_name, int seconds, bool members_only = true) 

| void 
| AddReplayLockout(int seconds_duration) 

| void 
| AddReplayLockoutDuration(int seconds_duration, bool members_only = true) 

| uint32 
| GetDynamicZoneID() 

| uint32 
| GetID() 

| int 
| GetInstanceID() 

| string 
| GetLeaderName() 

| HASHREF 
| GetLockouts() 

| string 
| GetLootEventByNPCTypeID(uint32 npc_type_id) 

| string 
| GetLootEventBySpawnID(uint32 spawn_id) 

| uint32 
| GetMemberCount() 

| HASHREF 
| GetMembers() 

| string 
| GetName() 

| int 
| GetSecondsRemaining() 

| string 
| GetUUID() 

| int 
| GetZoneID() 

| string 
| GetZoneName() 

| int 
| GetZoneVersion() 

| bool 
| HasLockout(string event_name) 

| bool 
| HasReplayLockout() 

| bool 
| IsLocked() 

| void 
| RemoveCompass() 

| void 
| RemoveLockout(string event_name) 

| void 
| SetCompass(int zone_id, float x, float y, float z) 

| void 
| SetCompass(string zone_short_name, float x, float y, float z) 

| void 
| SetLocked(bool value, ExpeditionLockMessage lock_msg = ExpeditionLockMessage::None, uint32 msg_color = Chat::Yellow) 

| void 
| SetLootEventByNPCTypeID(uint32_t npc_type_id, string event_name) 

| void 
| SetLootEventBySpawnID(uint32_t spawn_id, string event_name) 

| void 
| SetReplayLockoutOnMemberJoin(bool value) 

| void 
| SetSafeReturn(uint32_t zone_id, float x, float y, float z, float heading) 

| void 
| SetSafeReturn(string zone_short_name, float x, float y, float z, float heading) 

| void 
| SetZoneInLocation(float x, float y, float z, float heading) 

| void 
| SetSecondsRemaining(uint32 seconds_remaining) 

| void 
| UpdateLockoutDuration(string event_name, uint32_t seconds, bool members_only = true) 

## Expedition constants 

#### `ExpeditionLockMessage` 

| 

constant 
| value 
| lock message 

| None 
| 0 
| 

| Close 
| 1 
| "Your expedition is nearing its close. You cannot bring any additional people into your expedition at this time." 

| Begin 
| 2 
| "The trial has begun. You cannot bring any additional people into your expedition at this time."

---

